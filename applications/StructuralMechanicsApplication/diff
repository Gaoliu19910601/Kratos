diff --git a/applications/StructuralMechanicsApplication/CMakeLists.txt b/applications/StructuralMechanicsApplication/CMakeLists.txt
index aedafe8b48..ccd42c93f1 100644
--- a/applications/StructuralMechanicsApplication/CMakeLists.txt
+++ b/applications/StructuralMechanicsApplication/CMakeLists.txt
@@ -23,7 +23,6 @@ set( KRATOS_STRUCTURAL_MECHANICS_APPLICATION_CORE
   ${CMAKE_CURRENT_SOURCE_DIR}/custom_utilities/constitutive_law_utilities.cpp
   ${CMAKE_CURRENT_SOURCE_DIR}/custom_utilities/rayleigh_damping_coefficients_utilities.cpp
   ${CMAKE_CURRENT_SOURCE_DIR}/custom_utilities/explicit_integration_utilities.cpp
-  ${CMAKE_CURRENT_SOURCE_DIR}/custom_utilities/rve_periodicity_utility.cpp
 
   ## RESPONSE UTILITIES
   ${CMAKE_CURRENT_SOURCE_DIR}/custom_response_functions/response_utilities/adjoint_structural_response_function.cpp
@@ -69,8 +68,8 @@ set( KRATOS_STRUCTURAL_MECHANICS_APPLICATION_CORE
   ${CMAKE_CURRENT_SOURCE_DIR}/custom_constitutive/linear_elastic_orthotropic_2D_law.cpp
   ${CMAKE_CURRENT_SOURCE_DIR}/custom_constitutive/small_strain_j2_plasticity_plane_strain_2d.cpp
   ${CMAKE_CURRENT_SOURCE_DIR}/custom_constitutive/small_strain_j2_plasticity_3d.cpp
-  ${CMAKE_CURRENT_SOURCE_DIR}/custom_constitutive/small_strain_isotropic_damage_plane_strain_2d.cpp
-  ${CMAKE_CURRENT_SOURCE_DIR}/custom_constitutive/small_strain_isotropic_damage_3d.cpp
+  ${CMAKE_CURRENT_SOURCE_DIR}/custom_constitutive/linear_isotropic_damage_plane_strain_2d.cpp
+  ${CMAKE_CURRENT_SOURCE_DIR}/custom_constitutive/linear_isotropic_damage_3D_law.cpp
   ${CMAKE_CURRENT_SOURCE_DIR}/custom_constitutive/small_strain_isotropic_damage_factory.cpp
   ${CMAKE_CURRENT_SOURCE_DIR}/custom_constitutive/small_strain_isotropic_plasticity_factory.cpp
   ${CMAKE_CURRENT_SOURCE_DIR}/custom_constitutive/finite_strain_isotropic_plasticity_factory.cpp
@@ -83,8 +82,6 @@ set( KRATOS_STRUCTURAL_MECHANICS_APPLICATION_CORE
   ${CMAKE_CURRENT_SOURCE_DIR}/custom_constitutive/generic_small_strain_d_plus_d_minus_damage.cpp
   ${CMAKE_CURRENT_SOURCE_DIR}/custom_constitutive/generic_small_strain_kinematic_plasticity.cpp
   ${CMAKE_CURRENT_SOURCE_DIR}/custom_constitutive/plasticity_isotropic_kinematic_j2.cpp
-  ${CMAKE_CURRENT_SOURCE_DIR}/custom_constitutive/plane_stress_d_plus_d_minus_damage_masonry_2d.cpp
-  ${CMAKE_CURRENT_SOURCE_DIR}/custom_constitutive/d_plus_d_minus_damage_masonry_3d.cpp
 
   ## ELEMENTS
   #Adding truss element
diff --git a/applications/StructuralMechanicsApplication/custom_conditions/surface_load_condition_3d.cpp b/applications/StructuralMechanicsApplication/custom_conditions/surface_load_condition_3d.cpp
index 9b190ab13d..76f5ac56a6 100644
--- a/applications/StructuralMechanicsApplication/custom_conditions/surface_load_condition_3d.cpp
+++ b/applications/StructuralMechanicsApplication/custom_conditions/surface_load_condition_3d.cpp
@@ -17,7 +17,6 @@
 // Project includes
 #include "custom_conditions/surface_load_condition_3d.h"
 #include "utilities/math_utils.h"
-#include "utilities/beam_math_utilities.hpp"
 #include "utilities/geometry_utilities.h"
 #include "utilities/integration_utilities.h"
 
@@ -122,21 +121,23 @@ void SurfaceLoadCondition3D::CalculateAndSubKp(
     double coeff = 1.0;
     const std::size_t number_of_nodes = GetGeometry().size();
 
-    BeamMathUtils<double>::VectorToSkewSymmetricTensor(rTangentXi, cross_tangent_xi);
-    BeamMathUtils<double>::VectorToSkewSymmetricTensor(rTangentEta, cross_tangent_eta);
+    MakeCrossMatrix(cross_tangent_xi, rTangentXi);
+    MakeCrossMatrix(cross_tangent_eta, rTangentEta);
 
     for (std::size_t i = 0; i < number_of_nodes; ++i) {
-        const std::size_t row_index = i * 3;
+        const std::size_t RowIndex = i * 3;
         for (std::size_t j = 0; j < number_of_nodes; ++j) {
             const std::size_t column_index = j * 3;
 
+            coeff = Pressure * rN[i] * rDN_De(j, 1) * Weight;
+            noalias(Kij) = coeff * cross_tangent_xi;
+
             coeff = Pressure * rN[i] * rDN_De(j, 0) * Weight;
-            noalias(Kij) = coeff * cross_tangent_eta;
 
-            coeff = Pressure * rN[i] * rDN_De(j, 1) * Weight;
-            noalias(Kij) -= coeff * cross_tangent_xi;
+            noalias(Kij) -= coeff * cross_tangent_eta;
 
-            MathUtils<double>::AddMatrix(rK, Kij, row_index, column_index);
+            // NOTE TAKE CARE: the load correction matrix should be SUBTRACTED not added
+            MathUtils<double>::SubtractMatrix(rK, Kij, RowIndex, column_index);
         }
     }
 
@@ -146,6 +147,25 @@ void SurfaceLoadCondition3D::CalculateAndSubKp(
 /***********************************************************************************/
 /***********************************************************************************/
 
+void SurfaceLoadCondition3D::MakeCrossMatrix(
+    BoundedMatrix<double, 3, 3>& rM,
+    const array_1d<double, 3>& rU
+    ) const
+{
+    rM(0, 0) = 0.0;
+    rM(0, 1) = -rU[2];
+    rM(0, 2) = rU[1];
+    rM(1, 0) = rU[2];
+    rM(1, 1) = 0.0;
+    rM(1, 2) = -rU[0];
+    rM(2, 0) = -rU[1];
+    rM(2, 1) = rU[0];
+    rM(2, 2) = 0.0;
+}
+
+/***********************************************************************************/
+/***********************************************************************************/
+
 void SurfaceLoadCondition3D::CalculateAndAddPressureForce(
     VectorType& rResidualVector,
     const Vector& rN,
@@ -255,7 +275,7 @@ void SurfaceLoadCondition3D::CalculateAll(
         tangent_eta[1] = J(1, 1);
         tangent_xi[2]  = J(2, 0);
         tangent_eta[2] = J(2, 1);
-        
+
         array_1d<double, 3 > normal;
         MathUtils<double>::UnitCrossProduct(normal, tangent_eta, tangent_xi);
 
diff --git a/applications/StructuralMechanicsApplication/custom_conditions/surface_load_condition_3d.h b/applications/StructuralMechanicsApplication/custom_conditions/surface_load_condition_3d.h
index 49ac9e29cc..496a19574e 100644
--- a/applications/StructuralMechanicsApplication/custom_conditions/surface_load_condition_3d.h
+++ b/applications/StructuralMechanicsApplication/custom_conditions/surface_load_condition_3d.h
@@ -221,6 +221,16 @@ protected:
         const double Weight
         ) const;
 
+    /**
+     * @brief This method computes the cross product matrix
+     * @param rM The matrix to be build
+     * @param rU The vector that defines the
+     */
+    void MakeCrossMatrix(
+        BoundedMatrix<double, 3, 3>& rM,
+        const array_1d<double, 3>& rU
+        ) const;
+
     /**
      * @brief This method adds the pressure contribution to the RHS
      * @param rResidualVector The local contribution to the RHS
diff --git a/applications/StructuralMechanicsApplication/custom_constitutive/constitutive_laws_integrators/generic_constitutive_law_integrator_kinematic_plasticity.h b/applications/StructuralMechanicsApplication/custom_constitutive/constitutive_laws_integrators/generic_constitutive_law_integrator_kinematic_plasticity.h
index 1d17abe678..da3bb1702e 100644
--- a/applications/StructuralMechanicsApplication/custom_constitutive/constitutive_laws_integrators/generic_constitutive_law_integrator_kinematic_plasticity.h
+++ b/applications/StructuralMechanicsApplication/custom_constitutive/constitutive_laws_integrators/generic_constitutive_law_integrator_kinematic_plasticity.h
@@ -183,23 +183,20 @@ class GenericConstitutiveLawIntegratorKinematicPlasticity
         IndexType iteration = 0, max_iter = 100;
         array_1d<double, VoigtSize> delta_sigma;
         double plastic_consistency_factor_increment, threshold_indicator;
-        array_1d<double, VoigtSize> r_kin_hard_stress_vector;
 
         // Backward Euler
         while (is_converged == false && iteration <= max_iter) {
             threshold_indicator = rUniaxialStress - rThreshold;
             plastic_consistency_factor_increment = threshold_indicator * rPlasticDenominator;
-
+            //if (plastic_consistency_factor_increment < 0.0) plastic_consistency_factor_increment = 0.0;
             noalias(rPlasticStrainIncrement) = plastic_consistency_factor_increment * rGflux;
             noalias(rPlasticStrain) += rPlasticStrainIncrement;
             noalias(delta_sigma) = prod(rConstitutiveMatrix, rPlasticStrainIncrement);
             noalias(rPredictiveStressVector) -= delta_sigma;
 
-            CalculateBackStress(rPredictiveStressVector, rValues, rPreviousStressVector,
+            CalculateAndSubstractBackStress(rPredictiveStressVector, rValues, rPreviousStressVector,
                                             rPlasticStrainIncrement, rBackStressVector);
-
-            noalias(r_kin_hard_stress_vector) = rPredictiveStressVector - rBackStressVector;
-            threshold_indicator = CalculatePlasticParameters(r_kin_hard_stress_vector, rStrainVector, rUniaxialStress, rThreshold,
+            threshold_indicator = CalculatePlasticParameters(rPredictiveStressVector, rStrainVector, rUniaxialStress, rThreshold,
                                        rPlasticDenominator, rFflux, rGflux, rPlasticDissipation, rPlasticStrainIncrement,
                                        rConstitutiveMatrix, rValues, CharacteristicLength, rPlasticStrain, rBackStressVector);
 
@@ -256,7 +253,7 @@ class GenericConstitutiveLawIntegratorKinematicPlasticity
         CalculateIndicatorsFactors(rPredictiveStressVector, tensile_indicator_factor,compression_indicator_factor);
         CalculatePlasticDissipation(rPredictiveStressVector, tensile_indicator_factor,compression_indicator_factor, rPlasticStrainIncrement,rPlasticDissipation, h_capa, rValues, CharacteristicLength);
         CalculateEquivalentPlasticStrain(rPredictiveStressVector, rUniaxialStress, rPlasticStrain, tensile_indicator_factor, rValues, equivalent_plastic_strain);
-        CalculateEquivalentStressThreshold(rPlasticDissipation, tensile_indicator_factor,compression_indicator_factor, rThreshold, slope, rValues, equivalent_plastic_strain);
+        CalculateEquivalentStressThreshold( rPlasticDissipation, tensile_indicator_factor,compression_indicator_factor, rThreshold, slope, rValues, equivalent_plastic_strain);
         CalculateHardeningParameter(rFflux, slope, h_capa, hardening_parameter);
         CalculatePlasticDenominator(rFflux, rGflux, rConstitutiveMatrix, hardening_parameter, rPlasticDenominator, rBackStressVector, rValues);
         
@@ -294,7 +291,7 @@ class GenericConstitutiveLawIntegratorKinematicPlasticity
      * @param rPlasticStrainIncrement The plastic strain increment of this iteration
      * @param rBackStressVector The back-stress vector for the kinematic plasticity
      */
-    static void CalculateBackStress(
+    static void CalculateAndSubstractBackStress(
         array_1d<double, VoigtSize>& rPredictiveStressVector,
         ConstitutiveLaw::Parameters& rValues,
         const Vector& rPreviousStressVector,
@@ -302,48 +299,50 @@ class GenericConstitutiveLawIntegratorKinematicPlasticity
         Vector& rBackStressVector
         )
     {
-        const Vector& r_kinematic_parameters = rValues.GetMaterialProperties()[KINEMATIC_PLASTICITY_PARAMETERS];
+        const Vector& kinematic_parameters = rValues.GetMaterialProperties()[KINEMATIC_PLASTICITY_PARAMETERS];
         const unsigned int kinematic_hardening_type = rValues.GetMaterialProperties()[KINEMATIC_HARDENING_TYPE];
 
         switch (static_cast<KinematicHardeningType>(kinematic_hardening_type))
         {
             double pDot, denominator, dot_product_dp;
             case KinematicHardeningType::LinearKinematicHardening:
-                KRATOS_ERROR_IF(r_kinematic_parameters.size() == 0) << "Kinematic Parameters not defined..." << std::endl;
-                rBackStressVector += 2.0 / 3.0 * r_kinematic_parameters[0] * rPlasticStrainIncrement;
+                KRATOS_ERROR_IF(kinematic_parameters.size() == 0) << "Kinematic Parameters not defined..." << std::endl;
+                rBackStressVector += 2.0 / 3.0 * kinematic_parameters[0] * rPlasticStrainIncrement;
                 break;
 
             case KinematicHardeningType::AmstrongFrederickKinematicHardening:
-                KRATOS_ERROR_IF(r_kinematic_parameters.size() < 2) << "Kinematic Parameters not defined..." << std::endl;
+                KRATOS_ERROR_IF(kinematic_parameters.size() < 2) << "Kinematic Parameters not defined..." << std::endl;
                 dot_product_dp = 0.0;
                 for (IndexType i = 0; i < rPlasticStrainIncrement.size(); ++i) {
                     dot_product_dp += rPlasticStrainIncrement[i] * rPlasticStrainIncrement[i];
                 }
                 pDot = std::sqrt(2.0 / 3.0 * dot_product_dp);
-                denominator = 1.0 + (r_kinematic_parameters[1] * pDot);
-                rBackStressVector += (2.0 / 3.0 * r_kinematic_parameters[0] * rPlasticStrainIncrement) / denominator;
+                denominator = 1.0 + (kinematic_parameters[1] * pDot);
+                rBackStressVector += (2.0 / 3.0 * kinematic_parameters[0] * rPlasticStrainIncrement) / denominator;
 				break;
 
             case KinematicHardeningType::AraujoVoyiadjisKinematicHardening:
-                KRATOS_ERROR_IF(r_kinematic_parameters.size() != 3) << "Kinematic Parameters not defined..." << std::endl;
+                KRATOS_ERROR_IF(kinematic_parameters.size() != 3) << "Kinematic Parameters not defined..." << std::endl;
                 dot_product_dp = 0.0;
                 for (IndexType i = 0; i < rPlasticStrainIncrement.size(); ++i) {
                     dot_product_dp += rPlasticStrainIncrement[i] * rPlasticStrainIncrement[i];
                 }
                 pDot = std::sqrt(2.0 / 3.0 * dot_product_dp);
-                denominator = 1.0 + (r_kinematic_parameters[1] * pDot);
+                denominator = 1.0 + (kinematic_parameters[1] * pDot);
                 if (pDot > tolerance) {
-                    rBackStressVector += (2.0 / 3.0 * r_kinematic_parameters[0] * rPlasticStrainIncrement) / denominator;
+                    rBackStressVector += (2.0 / 3.0 * kinematic_parameters[0] * rPlasticStrainIncrement) / denominator;
                 } else {
-                    const Vector& r_delta_stress = rPredictiveStressVector - rPreviousStressVector;
-                    rBackStressVector += ((2.0 / 3.0 * r_kinematic_parameters[0] * rPlasticStrainIncrement) +
-                                         r_kinematic_parameters[2] * r_delta_stress) / denominator;
+                    const Vector& delta_stress = rPredictiveStressVector - rPreviousStressVector;
+                    rBackStressVector += ((2.0 / 3.0 * kinematic_parameters[0] * rPlasticStrainIncrement) +
+                                         kinematic_parameters[2] * delta_stress) / denominator;
                 }
                 break;
+
             default:
                 KRATOS_ERROR << " The Kinematic hardening type of plasticity is not set or wrong..." << kinematic_hardening_type << std::endl;
                 break;
         }
+        rPredictiveStressVector -= rBackStressVector;
     }
 
     /**
@@ -844,7 +843,7 @@ class GenericConstitutiveLawIntegratorKinematicPlasticity
         ConstitutiveLaw::Parameters& rValues
         )
     {
-        const Vector& r_kinematic_parameters = rValues.GetMaterialProperties()[KINEMATIC_PLASTICITY_PARAMETERS];
+        const Vector& kinematic_parameters = rValues.GetMaterialProperties()[KINEMATIC_PLASTICITY_PARAMETERS];
         const int kinematic_hardening_type = rValues.GetMaterialProperties()[KINEMATIC_HARDENING_TYPE];
 
         const array_1d<double, VoigtSize> delta_vector = prod(rGFlux, rConstitutiveMatrix);
@@ -852,8 +851,8 @@ class GenericConstitutiveLawIntegratorKinematicPlasticity
         for (IndexType i = 0; i < VoigtSize; ++i) {
             A1 += rFFlux[i] * delta_vector[i];
         }
-        if (r_kinematic_parameters.size() == 3) {
-            A1 *= (1.0 - r_kinematic_parameters[2]);
+        if (kinematic_parameters.size() == 3) {
+            A1 *= (1.0 - kinematic_parameters[2]);
         } // Araujo case with 3 params
         
         double dot_fflux_gflux = 0.0, A2;
@@ -865,29 +864,29 @@ class GenericConstitutiveLawIntegratorKinematicPlasticity
         switch (static_cast<KinematicHardeningType>(kinematic_hardening_type))
         {
             case KinematicHardeningType::LinearKinematicHardening:
-                A2 = two_thirds * r_kinematic_parameters[0] * dot_fflux_gflux;
+                A2 = two_thirds * kinematic_parameters[0] * dot_fflux_gflux;
                 break;
 
             case KinematicHardeningType::AmstrongFrederickKinematicHardening:
-                A2 = two_thirds * r_kinematic_parameters[0] * dot_fflux_gflux;
+                A2 = two_thirds * kinematic_parameters[0] * dot_fflux_gflux;
                 for (IndexType i = 0; i < VoigtSize; ++i) {
                     dot_fflux_backstress += rFFlux[i] * rBackStressVector[i];
                 }
                 for (IndexType i = 0; i < VoigtSize; ++i) {
                     dot_gflux_gflux += rGFlux[i] * rGFlux[i];
                 }
-                A2 -= r_kinematic_parameters[1] * dot_fflux_backstress * std::sqrt(two_thirds * dot_gflux_gflux);
+                A2 -= kinematic_parameters[1] * dot_fflux_backstress * std::sqrt(two_thirds * dot_gflux_gflux);
                 break;
 
             case KinematicHardeningType::AraujoVoyiadjisKinematicHardening:
-                A2 = two_thirds * r_kinematic_parameters[0] * dot_fflux_gflux;
+                A2 = two_thirds * kinematic_parameters[0] * dot_fflux_gflux;
                 for (IndexType i = 0; i < VoigtSize; ++i) {
                     dot_fflux_backstress += rFFlux[i] * rBackStressVector[i];
                 }
                 for (IndexType i = 0; i < VoigtSize; ++i) {
                     dot_gflux_gflux += rGFlux[i] * rGFlux[i];
                 }
-                A2 -= r_kinematic_parameters[1] * dot_fflux_backstress * std::sqrt(two_thirds * dot_gflux_gflux);
+                A2 -= kinematic_parameters[1] * dot_fflux_backstress * std::sqrt(two_thirds * dot_gflux_gflux);
                 break;
 
             default:
@@ -898,8 +897,8 @@ class GenericConstitutiveLawIntegratorKinematicPlasticity
         const double A3 = rHardeningParameter;
         rPlasticDenominator = 1.0 / (A1 + A2 + A3);
 
-        if (r_kinematic_parameters.size() == 3) {
-           rPlasticDenominator *= (1.0 - r_kinematic_parameters[2]);
+        if (kinematic_parameters.size() == 3) {
+           rPlasticDenominator *= (1.0 - kinematic_parameters[2]);
         } // Araujo case with 3 params
     }
 
diff --git a/applications/StructuralMechanicsApplication/custom_constitutive/d_plus_d_minus_damage_masonry_3d.cpp b/applications/StructuralMechanicsApplication/custom_constitutive/d_plus_d_minus_damage_masonry_3d.cpp
deleted file mode 100644
index c8795f3984..0000000000
--- a/applications/StructuralMechanicsApplication/custom_constitutive/d_plus_d_minus_damage_masonry_3d.cpp
+++ /dev/null
@@ -1,726 +0,0 @@
-// KRATOS  ___|  |                   |                   |
-//       \___ \  __|  __| |   |  __| __| |   |  __| _` | |
-//             | |   |    |   | (    |   |   | |   (   | |
-//       _____/ \__|_|   \__,_|\___|\__|\__,_|_|  \__,_|_| MECHANICS
-//
-//  License:         BSD License
-//                   license: structural_mechanics_application/license.txt
-//
-//  Main authors:    Philip Kalkbrenner
-//                   Alejandro Cornejo
-//
-//
-
-// System includes
-
-// External includes
-
-// Project includes
-
-#include "includes/checks.h"
-#include "custom_utilities/tangent_operator_calculator_utility.h"
-#include "custom_utilities/constitutive_law_utilities.h"
-#include "structural_mechanics_application_variables.h"
-#include "custom_constitutive/d_plus_d_minus_damage_masonry_3d.h"
-
-namespace Kratos
-{
-
-DamageDPlusDMinusMasonry3DLaw::DamageDPlusDMinusMasonry3DLaw() {
-
-}
-/***********************************************************************************/
-/***********************************************************************************/
-void DamageDPlusDMinusMasonry3DLaw::CalculateMaterialResponsePK2(ConstitutiveLaw::Parameters& rValues)
-{
-    this->CalculateMaterialResponseCauchy(rValues);
-}
-/***********************************************************************************/
-/***********************************************************************************/
-void DamageDPlusDMinusMasonry3DLaw::CalculateMaterialResponseKirchhoff(ConstitutiveLaw::Parameters& rValues)
-{
-    this->CalculateMaterialResponseCauchy(rValues);
-}
-/***********************************************************************************/
-/***********************************************************************************/
-void DamageDPlusDMinusMasonry3DLaw::CalculateMaterialResponsePK1(ConstitutiveLaw::Parameters& rValues)
-{
-    this->CalculateMaterialResponseCauchy(rValues);
-}
-/***********************************************************************************/
-/***********************************************************************************/
-void DamageDPlusDMinusMasonry3DLaw::CalculateMaterialResponseCauchy(ConstitutiveLaw::Parameters& rValues)
-{
-    KRATOS_TRY
-
-    // Integrate Stress Damage
-    Vector& integrated_stress_vector = rValues.GetStressVector();
-    array_1d<double, VoigtSize> auxiliar_integrated_stress_vector = integrated_stress_vector;
-    Matrix& r_tangent_tensor = rValues.GetConstitutiveMatrix(); // todo modify after integration
-    const Flags& r_constitutive_law_options = rValues.GetOptions();
-
-    // We get the strain vector
-    Vector& r_strain_vector = rValues.GetStrainVector();
-
-    //NOTE: SINCE THE ELEMENT IS IN SMALL STRAINS WE CAN USE ANY STRAIN MEASURE. HERE EMPLOYING THE CAUCHY_GREEN
-    if( r_constitutive_law_options.IsNot( ConstitutiveLaw::USE_ELEMENT_PROVIDED_STRAIN )) {
-        this->CalculateValue(rValues, STRAIN, r_strain_vector);
-    }
-
-    // Elastic Matrix
-    if( r_constitutive_law_options.Is( ConstitutiveLaw::COMPUTE_CONSTITUTIVE_TENSOR ) ) {
-        Matrix& r_constitutive_matrix = rValues.GetConstitutiveMatrix();
-        this->CalculateValue(rValues, CONSTITUTIVE_MATRIX, r_constitutive_matrix);
-    }
-
-    // We compute the stress
-    if (r_constitutive_law_options.Is(ConstitutiveLaw::COMPUTE_STRESS)) {
-        // Elastic Matrix
-        Matrix& r_constitutive_matrix = rValues.GetConstitutiveMatrix();
-        this->CalculateValue(rValues, CONSTITUTIVE_MATRIX, r_constitutive_matrix);
-
-        DamageParameters damage_parameters;
-        damage_parameters.ThresholdTension = this->GetTensionThreshold();
-        damage_parameters.DamageTension    = this->GetTensionDamage();
-        damage_parameters.ThresholdCompression = this->GetCompressionThreshold();
-        damage_parameters.DamageCompression    = this->GetCompressionDamage();
-
-        // S0 = C0:E
-        array_1d<double, VoigtSize> predictive_stress_vector = prod(r_constitutive_matrix, r_strain_vector);
-
-        // Perform the separation of the Stress in tension and compression
-        array_1d<double, VoigtSize> predictive_stress_vector_tension, predictive_stress_vector_compression;
-        ConstitutiveLawUtilities<VoigtSize>::SpectralDecomposition(predictive_stress_vector, predictive_stress_vector_tension, predictive_stress_vector_compression);
-        noalias(damage_parameters.TensionStressVector)     = predictive_stress_vector_tension;
-        noalias(damage_parameters.CompressionStressVector) = predictive_stress_vector_compression;
-
-        // Compute the equivalent uniaxial Stress in tension and compression
-        this->CalculateEquivalentStressTension(predictive_stress_vector, damage_parameters.UniaxialTensionStress, rValues);
-
-        this->CalculateEquivalentStressCompression(predictive_stress_vector, damage_parameters.UniaxialCompressionStress, rValues);
-
-        const double F_tension = damage_parameters.UniaxialTensionStress - damage_parameters.ThresholdTension;
-        const double F_compression = damage_parameters.UniaxialCompressionStress - damage_parameters.ThresholdCompression;
-        const bool is_damaging_tension = this->IntegrateStressTensionIfNecessary(F_tension, damage_parameters, predictive_stress_vector_tension, predictive_stress_vector, rValues);
-        const bool is_damaging_compression = this->IntegrateStressCompressionIfNecessary(F_compression, damage_parameters, predictive_stress_vector_compression, predictive_stress_vector, rValues);
-
-        if (r_constitutive_law_options.Is(ConstitutiveLaw::COMPUTE_CONSTITUTIVE_TENSOR)) {
-            if (is_damaging_tension || is_damaging_compression) { // Perturbations
-                this->CalculateTangentTensor(rValues);
-            } else { // Secant matrix
-                this->CalculateSecantTensor(rValues, r_tangent_tensor);
-            }
-        }
-        this->CalculateIntegratedStressVector(integrated_stress_vector, damage_parameters, rValues);
-    }
-    KRATOS_CATCH("")
-}
-/***********************************************************************************/
-/***********************************************************************************/
-bool DamageDPlusDMinusMasonry3DLaw::IntegrateStressTensionIfNecessary(
-    const double F_tension,
-    DamageParameters& rParameters,
-    array_1d<double,VoigtSize>& rIntegratedStressVectorTension,
-    array_1d<double,VoigtSize> effective_stress_vector,
-    ConstitutiveLaw::Parameters& rValues)
-{
-    bool is_damaging = false;
-    const Flags& r_constitutive_law_options = rValues.GetOptions();
-    if (F_tension <= tolerance) { //Elastic Case
-        if (r_constitutive_law_options.Is( ConstitutiveLaw::COMPUTE_CONSTITUTIVE_TENSOR ) ) {
-            this->SetNonConvTensionDamage(rParameters.DamageTension);
-            this->SetNonConvTensionThreshold(rParameters.ThresholdTension);
-        }
-        rIntegratedStressVectorTension *= (1.0 - rParameters.DamageTension);
-    } else { // Increasing damage...
-        const double characteristic_length = ConstitutiveLawUtilities<3>::CalculateCharacteristicLengthOnReferenceConfiguration(rValues.GetElementGeometry());
-        // This routine updates the IntegratedStressVectorTension to verify the yield surf
-        this->IntegrateStressVectorTension(
-            rIntegratedStressVectorTension,
-            rParameters.UniaxialTensionStress,
-            rParameters.DamageTension,
-            rParameters.ThresholdTension,
-            rValues, characteristic_length);
-        if (r_constitutive_law_options.Is( ConstitutiveLaw::COMPUTE_CONSTITUTIVE_TENSOR)) {
-            this->SetNonConvTensionDamage(rParameters.DamageTension);
-            this->SetNonConvTensionThreshold(rParameters.UniaxialTensionStress);
-        }
-        is_damaging = true;
-    }
-    // Just for Plotting
-
-    double uniaxial_stress_tension = 0.0;
-    this->CalculateEquivalentStressTension(effective_stress_vector, uniaxial_stress_tension, rValues);
-    this->SetTensionStress(uniaxial_stress_tension);
-
-    return is_damaging;
-}
-/***********************************************************************************/
-/***********************************************************************************/
-bool DamageDPlusDMinusMasonry3DLaw::IntegrateStressCompressionIfNecessary(
-    const double F_compression,
-    DamageParameters& rParameters,
-    array_1d<double,VoigtSize>& rIntegratedStressVectorCompression,
-    array_1d<double,VoigtSize> effective_stress_vector,
-    ConstitutiveLaw::Parameters& rValues)
-{
-    bool is_damaging = false;
-    const Flags& r_constitutive_law_options = rValues.GetOptions();
-    if (F_compression <= tolerance) { // Elastic case
-        if (r_constitutive_law_options.Is(ConstitutiveLaw::COMPUTE_CONSTITUTIVE_TENSOR)) {
-            this->SetNonConvCompressionDamage(rParameters.DamageCompression);
-            this->SetNonConvCompressionThreshold(rParameters.ThresholdCompression);
-        }
-        rIntegratedStressVectorCompression *= (1.0 - rParameters.DamageCompression);
-    } else { // Increasing damage...
-        const double characteristic_length = ConstitutiveLawUtilities<3>::CalculateCharacteristicLengthOnReferenceConfiguration(rValues.GetElementGeometry());
-
-        // This routine updates the IntegratedStressVectorCompression to verify the yield surf
-        this->IntegrateStressVectorCompression(
-            rIntegratedStressVectorCompression,
-            rParameters.UniaxialCompressionStress,
-            rParameters.DamageCompression,
-            rParameters.ThresholdCompression,
-            rValues, characteristic_length);
-        if (r_constitutive_law_options.Is( ConstitutiveLaw::COMPUTE_CONSTITUTIVE_TENSOR ) ) {
-            this->SetNonConvCompressionDamage(rParameters.DamageCompression);
-            this->SetNonConvCompressionThreshold(rParameters.UniaxialCompressionStress);
-        }
-        is_damaging =  true;
-    }
-    // Just for Plotting
-    double uniaxial_stress_compression = 0.0;
-    this->CalculateEquivalentStressCompression(effective_stress_vector, uniaxial_stress_compression, rValues);
-    this->SetCompressionStress(uniaxial_stress_compression);
-    return is_damaging;
-}
-/***********************************************************************************/
-/***********************************************************************************/
-void DamageDPlusDMinusMasonry3DLaw::CalculateIntegratedStressVector(
-    Vector& rIntegratedStressVector,
-    const DamageParameters& rParameters,
-    ConstitutiveLaw::Parameters& rValues)
-{
-    rIntegratedStressVector = (1.0 - rParameters.DamageTension) * rParameters.TensionStressVector +
-                              (1.0 - rParameters.DamageCompression) * rParameters.CompressionStressVector;
-}
-/***********************************************************************************/
-/***********************************************************************************/
-void DamageDPlusDMinusMasonry3DLaw::CalculateTangentTensor(ConstitutiveLaw::Parameters& rValues)
-{
-    const Properties& r_material_properties = rValues.GetMaterialProperties();
-
-    const bool consider_perturbation_threshold = r_material_properties.Has(CONSIDER_PERTURBATION_THRESHOLD) ? r_material_properties[CONSIDER_PERTURBATION_THRESHOLD] : true;
-    const TangentOperatorEstimation tangent_operator_estimation = r_material_properties.Has(TANGENT_OPERATOR_ESTIMATION) ? static_cast<TangentOperatorEstimation>(r_material_properties[TANGENT_OPERATOR_ESTIMATION]) : TangentOperatorEstimation::SecondOrderPerturbation;
-
-    if (tangent_operator_estimation == TangentOperatorEstimation::Analytic) {
-        KRATOS_ERROR << "Analytic solution not available" << std::endl;
-    } else if (tangent_operator_estimation == TangentOperatorEstimation::FirstOrderPerturbation) {
-        // Calculates the Tangent Constitutive Tensor by perturbation (first order)
-        TangentOperatorCalculatorUtility::CalculateTangentTensor(rValues, this, ConstitutiveLaw::StressMeasure_Cauchy, consider_perturbation_threshold, 1);
-    } else if (tangent_operator_estimation == TangentOperatorEstimation::SecondOrderPerturbation) {
-        // Calculates the Tangent Constitutive Tensor by perturbation (second order)
-        TangentOperatorCalculatorUtility::CalculateTangentTensor(rValues, this, ConstitutiveLaw::StressMeasure_Cauchy, consider_perturbation_threshold, 2);
-    }
-}
-/***********************************************************************************/
-/***********************************************************************************/
-void DamageDPlusDMinusMasonry3DLaw::CalculateSecantTensor(ConstitutiveLaw::Parameters& rValues, Matrix& rSecantTensor)
-{
-    this->CalculateValue(rValues, CONSTITUTIVE_MATRIX, rSecantTensor);
-}
-/***********************************************************************************/
-/***********************************************************************************/
-void DamageDPlusDMinusMasonry3DLaw::InitializeMaterial(
-        const Properties& rMaterialProperties,
-        const GeometryType& rElementGeometry,
-        const Vector& rShapeFunctionsValues)
-{
-    // We construct the CL parameters
-    double initial_threshold_tension = rMaterialProperties[YIELD_STRESS_TENSION];
-    double initial_threshold_compression = rMaterialProperties[DAMAGE_ONSET_STRESS_COMPRESSION];
-
-    this->SetTensionThreshold(initial_threshold_tension);
-    this->SetCompressionThreshold(initial_threshold_compression);
-}
-/***********************************************************************************/
-/***********************************************************************************/
-void DamageDPlusDMinusMasonry3DLaw::FinalizeSolutionStep(
-    const Properties& rMaterialProperties,
-    const GeometryType &rElementGeometry,
-    const Vector& rShapeFunctionsValues,
-    const ProcessInfo& rCurrentProcessInfo
-    )
-{
-    this->SetTensionDamage(this->GetNonConvTensionDamage());
-    this->SetTensionThreshold(this->GetNonConvTensionThreshold());
-
-    this->SetCompressionDamage(this->GetNonConvCompressionDamage());
-    this->SetCompressionThreshold(this->GetNonConvCompressionThreshold());
-}
-/***********************************************************************************/
-/***********************************************************************************/
-void DamageDPlusDMinusMasonry3DLaw::FinalizeMaterialResponsePK1(ConstitutiveLaw::Parameters& rValues)
-{
-}
-/***********************************************************************************/
-/***********************************************************************************/
-void DamageDPlusDMinusMasonry3DLaw::FinalizeMaterialResponsePK2(ConstitutiveLaw::Parameters& rValues)
-{
-}
-/***********************************************************************************/
-/***********************************************************************************/
-void DamageDPlusDMinusMasonry3DLaw::FinalizeMaterialResponseKirchhoff(ConstitutiveLaw::Parameters& rValues)
-{
-}
-
-/***********************************************************************************/
-/***********************************************************************************/
-void DamageDPlusDMinusMasonry3DLaw::FinalizeMaterialResponseCauchy(ConstitutiveLaw::Parameters& rValues)
-{
-}
-/***********************************************************************************/
-/***********************************************************************************/
-bool DamageDPlusDMinusMasonry3DLaw::Has(const Variable<double>& rThisVariable)
-{
-    if (rThisVariable == DAMAGE_TENSION) {
-        return true;
-    } else if (rThisVariable == THRESHOLD_TENSION) {
-        return true;
-    } else if (rThisVariable == DAMAGE_COMPRESSION) {
-        return true;
-    } else if (rThisVariable == THRESHOLD_COMPRESSION) {
-        return true;
-    } else if (rThisVariable == UNIAXIAL_STRESS_COMPRESSION) {
-        return true;
-    } else if (rThisVariable == UNIAXIAL_STRESS_TENSION) {
-        return true;
-    } else {
-        return BaseType::Has(rThisVariable);
-    }
-    return false;
-}
-/***********************************************************************************/
-/***********************************************************************************/
-bool DamageDPlusDMinusMasonry3DLaw::Has(const Variable<Vector>& rThisVariable)
-{
-    return BaseType::Has(rThisVariable);
-}
-/***********************************************************************************/
-/***********************************************************************************/
-bool DamageDPlusDMinusMasonry3DLaw::Has(const Variable<Matrix>& rThisVariable)
-{
-    return BaseType::Has(rThisVariable);
-}
-/***********************************************************************************/
-/***********************************************************************************/
-void DamageDPlusDMinusMasonry3DLaw::SetValue(
-    const Variable<double>& rThisVariable,
-    const double& rValue,
-    const ProcessInfo& rCurrentProcessInfo
-    )
-{
-    if (rThisVariable == DAMAGE_TENSION) {
-       mTensionDamage = rValue;
-    } else if (rThisVariable == THRESHOLD_TENSION) {
-       mTensionThreshold = rValue;
-    } else if (rThisVariable == DAMAGE_COMPRESSION) {
-       mCompressionDamage = rValue;
-    } else if (rThisVariable == THRESHOLD_COMPRESSION) {
-       mCompressionThreshold = rValue;
-    } else if (rThisVariable == UNIAXIAL_STRESS_COMPRESSION) {
-       mCompressionUniaxialStress = rValue;
-    } else if (rThisVariable == UNIAXIAL_STRESS_TENSION) {
-       mTensionUniaxialStress = rValue;
-    } else {
-       return BaseType::SetValue(rThisVariable, rValue, rCurrentProcessInfo);
-    }
-}
-/***********************************************************************************/
-/***********************************************************************************/
-double& DamageDPlusDMinusMasonry3DLaw::GetValue(
-    const Variable<double>& rThisVariable,
-    double& rValue
-    )
-{
-    if (rThisVariable == DAMAGE_TENSION) {
-       rValue = mTensionDamage;
-    } else if (rThisVariable == THRESHOLD_TENSION) {
-       rValue = mTensionThreshold;
-    } else if (rThisVariable == DAMAGE_COMPRESSION) {
-       rValue = mCompressionDamage;
-    } else if (rThisVariable == THRESHOLD_COMPRESSION) {
-       rValue = mCompressionThreshold;
-    } else if (rThisVariable == UNIAXIAL_STRESS_COMPRESSION) {
-       rValue = mCompressionUniaxialStress;
-    } else if (rThisVariable == UNIAXIAL_STRESS_TENSION) {
-       rValue = mTensionUniaxialStress;
-    } else {
-       return BaseType::GetValue(rThisVariable, rValue);
-    }
-    return rValue;
-}
-/***********************************************************************************/
-/***********************************************************************************/
-Vector& DamageDPlusDMinusMasonry3DLaw::GetValue(
-    const Variable<Vector>& rThisVariable,
-    Vector& rValue
-    )
-{
-    return BaseType::GetValue(rThisVariable, rValue);
-}
-/***********************************************************************************/
-/***********************************************************************************/
-Matrix& DamageDPlusDMinusMasonry3DLaw::GetValue(
-    const Variable<Matrix>& rThisVariable,
-    Matrix& rValue
-    )
-{
-    return BaseType::GetValue(rThisVariable, rValue);
-}
-/***********************************************************************************/
-/***********************************************************************************/
-double& DamageDPlusDMinusMasonry3DLaw::CalculateValue(
-    ConstitutiveLaw::Parameters& rParameterValues,
-    const Variable<double>& rThisVariable,
-    double& rValue
-    )
-{
-    return this->GetValue(rThisVariable, rValue);
-}
-/***********************************************************************************/
-/***********************************************************************************/
-Vector& DamageDPlusDMinusMasonry3DLaw::CalculateValue(
-    ConstitutiveLaw::Parameters& rParameterValues,
-    const Variable<Vector>& rThisVariable,
-    Vector& rValue
-    )
-{
-    return BaseType::CalculateValue(rParameterValues, rThisVariable, rValue);
-}
-/***********************************************************************************/
-/***********************************************************************************/
-Matrix& DamageDPlusDMinusMasonry3DLaw::CalculateValue(
-    ConstitutiveLaw::Parameters& rParameterValues,
-    const Variable<Matrix>& rThisVariable,
-    Matrix& rValue
-    )
-{
-    if (rThisVariable == INTEGRATED_STRESS_TENSOR) {
-        //1.-Compute total deformation gradient
-        const Matrix& deformation_gradient_F = rParameterValues.GetDeformationGradientF();
-        //2.-Right Cauchy-Green tensor C
-        Matrix right_cauchy_green = prod(trans(deformation_gradient_F), deformation_gradient_F);
-        Vector strain_vector = ZeroVector(6);
-
-        //E= 0.5*(FT*F-1) or E = 0.5*(C-1)
-        strain_vector[0] = 0.5 * (right_cauchy_green(0, 0) - 1.00);
-        strain_vector[1] = 0.5 * (right_cauchy_green(1, 1) - 1.00);
-        strain_vector[2] = 0.5 * (right_cauchy_green(2, 2) - 1.00);
-        strain_vector[3] = right_cauchy_green(0, 1); // xy
-        strain_vector[4] = right_cauchy_green(1, 2); // yz
-        strain_vector[5] = right_cauchy_green(0, 2); // xz
-
-        Matrix constitutive_matrix;
-        this->CalculateElasticMatrix(constitutive_matrix, rParameterValues);
-
-        Vector stress = prod(constitutive_matrix, strain_vector);
-        //stress *= (1.0 - mDamage);
-        rValue =  MathUtils<double>::StressVectorToTensor(stress);
-        return rValue;
-    } else if (this->Has(rThisVariable)) {
-        return this->GetValue(rThisVariable, rValue);
-    } else {
-        return BaseType::CalculateValue(rParameterValues, rThisVariable, rValue);
-    }
-    return rValue;
-}
-/***********************************************************************************/
-/***********************************************************************************/
-int DamageDPlusDMinusMasonry3DLaw::Check(
-    const Properties& rMaterialProperties,
-    const GeometryType& rElementGeometry,
-    const ProcessInfo& rCurrentProcessInfo
-    )
-{
-    const int check_base = BaseType::Check(rMaterialProperties, rElementGeometry, rCurrentProcessInfo);
-
-    KRATOS_CHECK_VARIABLE_KEY(YOUNG_MODULUS);
-    KRATOS_CHECK_VARIABLE_KEY(POISSON_RATIO);
-    KRATOS_CHECK_VARIABLE_KEY(YIELD_STRESS_TENSION);
-    KRATOS_CHECK_VARIABLE_KEY(FRACTURE_ENERGY_TENSION);
-    KRATOS_CHECK_VARIABLE_KEY(DAMAGE_ONSET_STRESS_COMPRESSION);
-    KRATOS_CHECK_VARIABLE_KEY(YIELD_STRESS_COMPRESSION);
-    KRATOS_CHECK_VARIABLE_KEY(YIELD_STRAIN_COMPRESSION);
-    KRATOS_CHECK_VARIABLE_KEY(RESIDUAL_STRESS_COMPRESSION);
-    KRATOS_CHECK_VARIABLE_KEY(FRACTURE_ENERGY_COMPRESSION);
-    KRATOS_CHECK_VARIABLE_KEY(BIAXIAL_COMPRESSION_MULTIPLIER);
-    KRATOS_CHECK_VARIABLE_KEY(BEZIER_CONTROLLER_C1);
-    KRATOS_CHECK_VARIABLE_KEY(BEZIER_CONTROLLER_C2);
-    KRATOS_CHECK_VARIABLE_KEY(BEZIER_CONTROLLER_C3);
-    KRATOS_CHECK_VARIABLE_KEY(TRIAXIAL_COMPRESSION_COEFFICIENT);
-
-    if (check_base > 0) return 1;
-    return 0;
-}
-/***********************************************************************************/
-/***********************************************************************************/
-void DamageDPlusDMinusMasonry3DLaw::CalculateEquivalentStressTension(
-    array_1d<double, VoigtSize>& rPredictiveStressVector,
-    double& rEquivalentStress,
-    ConstitutiveLaw::Parameters& rValues
-    )
-{
-    const Properties& r_material_properties = rValues.GetMaterialProperties();
-
-    const double yield_tension = r_material_properties[YIELD_STRESS_TENSION];
-    const double yield_compression = r_material_properties[YIELD_STRESS_COMPRESSION];
-    const double biaxial_compression_multiplier = r_material_properties[BIAXIAL_COMPRESSION_MULTIPLIER];
-    const double alpha = (biaxial_compression_multiplier - 1.0)/(2 * biaxial_compression_multiplier - 1.0);
-    const double alpha_factor = 1.0 / (1.0 - alpha);
-    const double beta = (yield_compression / yield_tension) * (1.0 - alpha) - (1.0 + alpha);
-
-    double I1,J2;
-    ConstitutiveLawUtilities<VoigtSize>::CalculateI1Invariant(rPredictiveStressVector, I1);
-    array_1d<double, VoigtSize> deviator = ZeroVector(VoigtSize);
-    ConstitutiveLawUtilities<VoigtSize>::CalculateJ2Invariant(rPredictiveStressVector, I1, deviator, J2);
-
-    array_1d<double, Dimension> principal_stress_vector;
-    ConstitutiveLawUtilities<VoigtSize>::CalculatePrincipalStresses(principal_stress_vector, rPredictiveStressVector);
-    const double principal_stress_1 = principal_stress_vector[0];
-
-    if (principal_stress_1 > 0.0){
-        rEquivalentStress = alpha_factor * (alpha*I1 + std::sqrt(3.0 * J2) + beta * principal_stress_1) * (yield_tension / yield_compression);
-    }
-}
-/***********************************************************************************/
-/***********************************************************************************/
-void DamageDPlusDMinusMasonry3DLaw::CalculateEquivalentStressCompression(
-    array_1d<double, VoigtSize>& rPredictiveStressVector,
-    double& rEquivalentStress,
-    ConstitutiveLaw::Parameters& rValues
-    )
-{
-    const Properties& r_material_properties = rValues.GetMaterialProperties();
-
-    const double yield_tension = r_material_properties[YIELD_STRESS_TENSION];
-    const double yield_compression = r_material_properties[YIELD_STRESS_COMPRESSION];
-    const double biaxial_compression_multiplier = r_material_properties[BIAXIAL_COMPRESSION_MULTIPLIER];
-    const double shear_compression_reductor = r_material_properties[SHEAR_COMPRESSION_REDUCTOR];
-    const double rho = r_material_properties[TRIAXIAL_COMPRESSION_COEFFICIENT];
-
-    KRATOS_ERROR_IF(shear_compression_reductor < 0.0)<< "The SHEAR_COMPRESSION_REDUCTOR is supposed to be a value between 0.0 and 1.0" << std::endl;
-    KRATOS_ERROR_IF(shear_compression_reductor > 1.0)<< "The SHEAR_COMPRESSION_REDUCTOR is supposed to be a value between 0.0 and 1.0" << std::endl;
-    KRATOS_ERROR_IF(rho <= 0.5)<< "The TRIAXIAL_COMPRESSION_COEFFICIENT is supposed to be a value between 0.5 and 1.0" << std::endl;
-    KRATOS_ERROR_IF(rho > 1.0)<< "The TRIAXIAL_COMPRESSION_COEFFICIENT is supposed to be a value between 0.5 and 1.0" << std::endl;
-
-    const double alpha = (biaxial_compression_multiplier - 1.0)/(2.0* biaxial_compression_multiplier - 1.0);
-    const double alpha_factor = 1.0 / (1.0 - alpha);
-    const double beta = (yield_compression / yield_tension) * (1.0 - alpha) - (1.0 + alpha);
-    const double gamma = 3.0 * (1.0 - rho) / (2.0 * rho - 1.0);
-
-    double I1,J2;
-    ConstitutiveLawUtilities<VoigtSize>::CalculateI1Invariant(rPredictiveStressVector, I1);
-    array_1d<double, VoigtSize> deviator = ZeroVector(VoigtSize);
-    ConstitutiveLawUtilities<VoigtSize>::CalculateJ2Invariant(rPredictiveStressVector, I1, deviator, J2);
-
-    array_1d<double, Dimension> principal_stress_vector;
-    ConstitutiveLawUtilities<VoigtSize>::CalculatePrincipalStresses(principal_stress_vector, rPredictiveStressVector);
-    const double principal_stress_1 = principal_stress_vector[0];
-    const double principal_stress_3 = principal_stress_vector[2];
-    const double smax_macaulay = std::max(principal_stress_1, 0.0);
-    const double smax_macaulay_neg = std::abs(std::min(principal_stress_1, 0.0));
-
-    if (principal_stress_3 < 0.0){
-        rEquivalentStress = alpha_factor * (alpha*I1 + std::sqrt(3.0 * J2) +
-                                            beta * shear_compression_reductor * smax_macaulay +
-                                            gamma * smax_macaulay_neg);
-    }
-}
-/***********************************************************************************/
-/***********************************************************************************/
-void DamageDPlusDMinusMasonry3DLaw::IntegrateStressVectorTension(
-    array_1d<double,VoigtSize>& rPredictiveStressVector,
-    const double UniaxialStress,
-    double& rDamage,
-    double& rThreshold,
-    ConstitutiveLaw::Parameters& rValues,
-    const double CharacteristicLength)
-{
-    double damage_parameter;
-    this->CalculateDamageParameterTension(rValues, damage_parameter, CharacteristicLength);
-    this->CalculateExponentialDamageTension(UniaxialStress, rThreshold, damage_parameter, CharacteristicLength, rValues, rDamage);
-
-    rPredictiveStressVector *= (1.0 - rDamage);
-}
-/***********************************************************************************/
-/***********************************************************************************/
-void DamageDPlusDMinusMasonry3DLaw::CalculateDamageParameterTension(
-    ConstitutiveLaw::Parameters& rValues,
-    double& rAParameter,
-    const double CharacteristicLength)
-{
-    const Properties& r_material_properties = rValues.GetMaterialProperties();
-
-    const double Gf = r_material_properties[FRACTURE_ENERGY_TENSION];
-    const double E = r_material_properties[YOUNG_MODULUS];
-    const double yield_tension = r_material_properties[YIELD_STRESS_TENSION];
-    const double l_mat = 2.0 * E * Gf / (std::pow(yield_tension, 2));
-
-    KRATOS_ERROR_IF(CharacteristicLength >= l_mat) << "FRACTURE_ENERGY_TENSION is too low:  2*E*Gt/(ft*ft) = " << l_mat
-        << ",   Characteristic Length = " << CharacteristicLength << std::endl;
-
-    rAParameter = 2.0 * (CharacteristicLength / (l_mat - CharacteristicLength));
-}
-/***********************************************************************************/
-/***********************************************************************************/
-void DamageDPlusDMinusMasonry3DLaw::CalculateExponentialDamageTension(
-    const double UniaxialStress,
-    const double Threshold,
-    const double DamageParameter,
-    const double CharacteristicLength,
-    ConstitutiveLaw::Parameters& rValues,
-    double& rDamage)
-{
-    const Properties& r_material_properties = rValues.GetMaterialProperties();
-    const double initial_threshold = r_material_properties[YIELD_STRESS_TENSION];
-    rDamage = 1.0 - (initial_threshold / UniaxialStress) * std::exp(DamageParameter * (1.0 - (UniaxialStress / initial_threshold)));
-}
-/***********************************************************************************/
-/***********************************************************************************/
-void DamageDPlusDMinusMasonry3DLaw::IntegrateStressVectorCompression(
-    array_1d<double,VoigtSize>& rPredictiveStressVector,
-    const double UniaxialStress,
-    double& rDamage,
-    double& rThreshold,
-    ConstitutiveLaw::Parameters& rValues,
-    const double CharacteristicLength)
-{
-    this->CalculateBezier3DamageCompression(UniaxialStress, rDamage, rThreshold, CharacteristicLength, rValues);
-    rPredictiveStressVector *= (1.0 - rDamage);
-}
-/***********************************************************************************/
-/***********************************************************************************/
-void DamageDPlusDMinusMasonry3DLaw::CalculateBezier3DamageCompression(
-    const double UniaxialStress,
-    double& rDamage,
-    double& rThreshold,
-    const double CharacteristicLength,
-    ConstitutiveLaw::Parameters& rValues)
-{
-    // Call the Material Properties
-    const Properties& r_material_properties = rValues.GetMaterialProperties();
-    const double young_modulus = r_material_properties[YOUNG_MODULUS];
-    const double stress_damage_onset = r_material_properties[DAMAGE_ONSET_STRESS_COMPRESSION];
-    const double yield_stress_compression = r_material_properties[YIELD_STRESS_COMPRESSION];
-    const double yield_strain_compression = r_material_properties[YIELD_STRAIN_COMPRESSION];
-    const double residual_stress_compression = r_material_properties[RESIDUAL_STRESS_COMPRESSION];
-    const double bezier_controller_c1 = r_material_properties[BEZIER_CONTROLLER_C1];
-    const double bezier_controller_c2 = r_material_properties[BEZIER_CONTROLLER_C2];
-    const double bezier_controller_c3 = r_material_properties[BEZIER_CONTROLLER_C3];
-    const double fracture_energy_compression = r_material_properties[FRACTURE_ENERGY_COMPRESSION];
-
-    // Calculate missing Bezier Determinators
-    const double bezier_control_alpha = 2.0 * (yield_strain_compression - (yield_stress_compression / young_modulus));
-    const double strain_damage_onset = stress_damage_onset / young_modulus;
-    const double bezier_control_strain_i = yield_stress_compression / young_modulus;
-    const double bezier_control_stress_k = residual_stress_compression +
-                 (yield_stress_compression - residual_stress_compression) * bezier_controller_c1;
-    double bezier_control_strain_j = yield_strain_compression + bezier_control_alpha * bezier_controller_c2;
-    double bezier_control_strain_k = 3.0 * yield_strain_compression - 2.0 * yield_stress_compression / young_modulus;
-    double bezier_control_strain_r = ( (bezier_control_strain_k - bezier_control_strain_j) *
-           (yield_stress_compression - residual_stress_compression)/(yield_stress_compression - bezier_control_stress_k) )
-           + bezier_control_strain_j;
-    double bezier_control_strain_u = bezier_control_strain_r * bezier_controller_c3;
-    const double specific_fracture_energy_compression = fracture_energy_compression / CharacteristicLength;
-
-    // Perform the Energy Regularization of the Bezier Determinators
-    this->RegulateBezierDeterminators(
-        specific_fracture_energy_compression,
-        yield_stress_compression, bezier_control_stress_k, residual_stress_compression, yield_strain_compression,
-        bezier_control_strain_j, bezier_control_strain_k, bezier_control_strain_r, bezier_control_strain_u);
-
-    // Compute rDamage
-    const double strain_like_counterpart = UniaxialStress / young_modulus;
-    double damage_variable_bezier = UniaxialStress;
-    if (strain_like_counterpart <= yield_strain_compression) {
-        damage_variable_bezier = this->EvaluateBezierCurve(
-            strain_like_counterpart,
-            strain_damage_onset, bezier_control_strain_i, yield_strain_compression,
-            stress_damage_onset, yield_stress_compression, yield_stress_compression);
-    } else if (strain_like_counterpart <= bezier_control_strain_k) {
-        damage_variable_bezier = this->EvaluateBezierCurve(
-            strain_like_counterpart,
-            yield_strain_compression, bezier_control_strain_j, bezier_control_strain_k,
-            yield_stress_compression, yield_stress_compression, bezier_control_stress_k);
-    } else if (strain_like_counterpart <= bezier_control_strain_u) {
-        damage_variable_bezier = this->EvaluateBezierCurve(
-            strain_like_counterpart,
-            bezier_control_strain_k, bezier_control_strain_r, bezier_control_strain_u,
-            bezier_control_stress_k, residual_stress_compression, residual_stress_compression);
-    } else {
-        damage_variable_bezier = residual_stress_compression;
-    }
-
-    rDamage = 1.0 - damage_variable_bezier / UniaxialStress;
-}
-/***********************************************************************************/
-/***********************************************************************************/
-void DamageDPlusDMinusMasonry3DLaw::RegulateBezierDeterminators(
-    const double specific_dissipated_fracture_energy,
-    const double sp, const double sk, const double sr, const double ep,
-    double& ej, double& ek, double& er, double& eu)
-{
-    const double bezier_energy_1 = sp * ep / 2.0;
-    double bezier_energy_2;
-    double bezier_energy_3;
-    this->ComputeBezierEnergy(bezier_energy_2, ep, ej, ek, sp, sp, sk);
-    this->ComputeBezierEnergy(bezier_energy_3, ek, er, eu, sk, sr, sr);
-    const double BezierEnergy = bezier_energy_1 + bezier_energy_2 + bezier_energy_3;
-
-    const double bezier_stretcher = ((specific_dissipated_fracture_energy - bezier_energy_1) /
-                                   (BezierEnergy - bezier_energy_1)) - 1.0;
-
-    KRATOS_ERROR_IF(bezier_stretcher <= -1.0) << "Error in Compression Damage: FRACTURE_ENERGY_COMPRESSION is too low, increase it to avoid constitutive snap-back!" << std::endl;
-
-    // Update Strain values
-    ej += bezier_stretcher * (ej - ep);
-    ek += bezier_stretcher * (ek - ep);
-    er += bezier_stretcher * (er - ep);
-    eu += bezier_stretcher * (eu - ep);
-}
-/***********************************************************************************/
-/***********************************************************************************/
-void DamageDPlusDMinusMasonry3DLaw::ComputeBezierEnergy(
-    double& rBezier_energy,
-    const double x1, const double x2, const double x3,
-    const double y1, const double y2, const double y3)
-{
-    rBezier_energy = (x2*y1/3.0) + (x3*y1/6.0) - (x2*y3/3) + (x3*y2/3) + (x3*y3/2.0) - x1*((y1/2.0) + (y2/3.0) + (y3/6.0));
-}
-/***********************************************************************************/
-/***********************************************************************************/
-double DamageDPlusDMinusMasonry3DLaw::EvaluateBezierCurve(
-    const double Xi,
-    const double x1, double x2, const double x3,
-    const double y1, const double y2, const double y3)
-{
-    double A = x1 - 2.0 * x2 + x3;
-    double B = 2.0 * (x2 - x1);
-    double C = x1 - Xi;
-    if (std::abs(A) < 1.0e-12) {
-        x2 = x2 + 1.0E-6 * (x3-x1);
-        A =  x1 - 2.0 * x2 + x3;
-        B = 2.0 * (x2 - x1);
-        C = x1 - Xi;
-    }
-
-    const double D = B * B - 4.0 * A * C;
-    const double t = (-B + std::sqrt(D)) / (2.0 * A);
-    const double bezier_damage_parameter =  (y1 - 2.0 * y2 + y3) * t * t + (y2 - y1) * 2.0 * t + y1;
-    return bezier_damage_parameter;
-}
-/***********************************************************************************/
-/***********************************************************************************/
-
-}// namespace Kratos
diff --git a/applications/StructuralMechanicsApplication/custom_constitutive/d_plus_d_minus_damage_masonry_3d.h b/applications/StructuralMechanicsApplication/custom_constitutive/d_plus_d_minus_damage_masonry_3d.h
deleted file mode 100644
index df285119e6..0000000000
--- a/applications/StructuralMechanicsApplication/custom_constitutive/d_plus_d_minus_damage_masonry_3d.h
+++ /dev/null
@@ -1,718 +0,0 @@
-// KRATOS  ___|  |                   |                   |
-//       \___ \  __|  __| |   |  __| __| |   |  __| _` | |
-//             | |   |    |   | (    |   |   | |   (   | |
-//       _____/ \__|_|   \__,_|\___|\__|\__,_|_|  \__,_|_| MECHANICS
-//
-//  License:         BSD License
-//                   license: structural_mechanics_application/license.txt
-//
-//  Main authors:    Philip Kalkbrenner
-//                   Alejandro Cornejo
-//
-//
-#if !defined(KRATOS_D_PLUS_D_MINUS_DAMAGE_MASONRY_3D_H_INCLUDED)
-#define KRATOS_D_PLUS_D_MINUS_DAMAGE_MASONRY_3D_H_INCLUDED
-
-// System includes
-
-// External includes
-
-// Project includes
-#include "custom_constitutive/elastic_isotropic_3d.h"
-
-namespace Kratos
-{
-///@name Kratos Globals
-///@{
-
-///@}
-///@name Type Definitions
-///@{
-
-    // The size type definition
-    typedef std::size_t SizeType;
-
-
-///@}
-///@name  Enum's
-///@{
-
-///@}
-///@name  Functions
-///@{
-
-///@}
-///@name Kratos Classes
-///@{
-/**
- * @class DamageDPlusDMinusMasonry3DLaw
- * @ingroup StructuralMechanicsApplication
- */
- class KRATOS_API(STRUCTURAL_MECHANICS_APPLICATION) DamageDPlusDMinusMasonry3DLaw
-    : public ElasticIsotropic3D
-{
-public:
-    ///@name Type Definitions
-    ///@{
-
-
-    /// The define the working dimension size, already defined in the integrator
-    static constexpr SizeType Dimension = 3;
-
-    /// The define the Voigt size, already defined in the  integrator
-    static constexpr SizeType VoigtSize = 6;
-
-    /// Definition of the base class
-    typedef ElasticIsotropic3D BaseType;
-
-    // Adding the respective using to avoid overload conflicts
-    //using BaseType::Has;
-    //using BaseType::GetValue;
-
-    /// Counted pointer of GenericYieldSurface
-    KRATOS_CLASS_POINTER_DEFINITION(DamageDPlusDMinusMasonry3DLaw);
-
-    /// The node definition
-    typedef Node<3> NodeType;
-
-    /// The geometry definition
-    typedef Geometry<NodeType> GeometryType;
-
-    /// Definition of the machine precision tolerance
-    static constexpr double tolerance = std::numeric_limits<double>::epsilon();
-
-    struct DamageParameters {
-        double DamageTension = 0.0;
-        double DamageCompression = 0.0;
-        double ThresholdTension = 0.0;
-        double ThresholdCompression = 0.0;
-        array_1d<double, VoigtSize> TensionStressVector;
-        array_1d<double, VoigtSize> CompressionStressVector;
-        double UniaxialTensionStress = 0.0;
-        double UniaxialCompressionStress = 0.0;
-    };
-    ///@}
-    ///@name Life Cycle
-    ///@{
-
-    /**
-    * Default constructor.
-    */
-    DamageDPlusDMinusMasonry3DLaw();
-
-
-    /**
-    * Clone.
-    */
-    ConstitutiveLaw::Pointer Clone() const override
-    {
-        return Kratos::make_shared<DamageDPlusDMinusMasonry3DLaw>(*this);
-    }
-    /**
-     * @brief Dimension of the law:
-     */
-    SizeType WorkingSpaceDimension() override
-    {
-        return Dimension;
-    };
-
-    /**
-     * @brief Voigt tensor size:
-     */
-    SizeType GetStrainSize() override
-    {
-        return VoigtSize;
-    };
-
-    /**
-    * Copy constructor.
-    */
-    DamageDPlusDMinusMasonry3DLaw(const DamageDPlusDMinusMasonry3DLaw &rOther)
-        : BaseType(rOther),
-          mTensionDamage(rOther.mTensionDamage),
-          mTensionThreshold(rOther.mTensionThreshold),
-          mNonConvTensionDamage(rOther.mNonConvTensionDamage),
-          mNonConvTensionThreshold(rOther.mNonConvTensionThreshold),
-          mCompressionDamage(rOther.mCompressionDamage),
-          mCompressionThreshold(rOther.mCompressionThreshold),
-          mNonConvCompressionDamage(rOther.mNonConvCompressionDamage),
-          mNonConvCompressionThreshold(rOther.mNonConvCompressionThreshold)
-    {
-    }
-
-    /**
-    * Destructor.
-    */
-    ~DamageDPlusDMinusMasonry3DLaw() override
-    {
-    }
-
-   /**
-     * @brief Computes the material response in terms of 1st Piola-Kirchhoff stresses and constitutive tensor
-     * @see Parameters
-     */
-    void CalculateMaterialResponsePK1(ConstitutiveLaw::Parameters &rValues) override;
-
-    /**
-     * @brief Computes the material response in terms of 2nd Piola-Kirchhoff stresses and constitutive tensor
-     * @see Parameters
-     */
-    void CalculateMaterialResponsePK2(ConstitutiveLaw::Parameters &rValues) override;
-
-    /**
-     * @brief Computes the material response in terms of Kirchhoff stresses and constitutive tensor
-     * @see Parameters
-     */
-    void CalculateMaterialResponseKirchhoff(ConstitutiveLaw::Parameters &rValues) override;
-
-    /**
-     * @brief Computes the material response in terms of Cauchy stresses and constitutive tensor
-     * @see Parameters
-     */
-    void CalculateMaterialResponseCauchy(ConstitutiveLaw::Parameters &rValues) override;
-
-    /**
-     * @brief Integrates the predictive tension stress vector if necessary
-     * @param F_compression = uniaxial_stress_tension - threshold
-     */
-    bool IntegrateStressTensionIfNecessary(
-        const double F_tension,
-        DamageParameters& Parameters,
-        array_1d<double, VoigtSize>& IntegratedStressVectorTension,
-        const array_1d<double, VoigtSize> rIntegratedStressVector,
-        ConstitutiveLaw::Parameters& rValues
-        );
-
-    /**
-     * @brief Integrates the predictive tension stress vector if necessary
-     * @param F_compression = uniaxial_stress_compression - threshold
-     */
-    bool IntegrateStressCompressionIfNecessary(
-        const double F_compression,
-        DamageParameters& Parameters,
-        array_1d<double, VoigtSize>& IntegratedStressVectorCompression,
-        array_1d<double, VoigtSize> rIntegratedStressVector,
-        ConstitutiveLaw::Parameters& rValues
-        );
-
-    /**
-     * @brief Computes the inetgarted stress vector S = A:D0:A:E
-     */
-    void CalculateIntegratedStressVector(
-        Vector& IntegratedStressVectorTension,
-        const DamageParameters& Parameters,
-        ConstitutiveLaw::Parameters& rValues
-        );
-
-    /**
-     * @brief This is to be called at the very beginning of the calculation
-     * @details (e.g. from InitializeElement) in order to initialize all relevant attributes of the constitutive law
-     * @param rMaterialProperties the Properties instance of the current element
-     * @param rElementGeometry the geometry of the current element
-     * @param rShapeFunctionsValues the shape functions values in the current integration point
-     */
-    void InitializeMaterial(
-        const Properties& rMaterialProperties,
-        const GeometryType& rElementGeometry,
-        const Vector& rShapeFunctionsValues
-        ) override;
-
-    /**
-     * @brief To be called at the end of each solution step
-     * @details (e.g. from Element::FinalizeSolutionStep)
-     * @param rMaterialProperties the Properties instance of the current element
-     * @param rElementGeometry the geometry of the current element
-     * @param rShapeFunctionsValues the shape functions values in the current integration point
-     * @param rCurrentProcessInfo the current ProcessInfo instance
-     */
-    void FinalizeSolutionStep(
-        const Properties &rMaterialProperties,
-        const GeometryType &rElementGeometry,
-        const Vector& rShapeFunctionsValues,
-        const ProcessInfo& rCurrentProcessInfo
-        ) override;
-
-    /**
-     * @brief Finalize the material response in terms of 1st Piola-Kirchhoff stresses
-     * @see Parameters
-     */
-    void FinalizeMaterialResponsePK1(ConstitutiveLaw::Parameters &rValues) override;
-
-    /**
-     * @brief Finalize the material response in terms of 2nd Piola-Kirchhoff stresses
-     * @see Parameters
-     */
-    void FinalizeMaterialResponsePK2(ConstitutiveLaw::Parameters &rValues) override;
-
-    /**
-     * @brief Finalize the material response in terms of Kirchhoff stresses
-     * @see Parameters
-     */
-    void FinalizeMaterialResponseKirchhoff(ConstitutiveLaw::Parameters &rValues) override;
-    /**
-     * Finalize the material response in terms of Cauchy stresses
-     * @see Parameters
-     */
-    void FinalizeMaterialResponseCauchy(ConstitutiveLaw::Parameters &rValues) override;
-
-    /**
-     * @brief Returns whether this constitutive Law has specified variable (double)
-     * @param rThisVariable the variable to be checked for
-     * @return true if the variable is defined in the constitutive law
-     */
-    bool Has(const Variable<double> &rThisVariable) override;
-
-    /**
-     * @brief Returns whether this constitutive Law has specified variable (Vector)
-     * @param rThisVariable the variable to be checked for
-     * @return true if the variable is defined in the constitutive law
-     */
-    bool Has(const Variable<Vector> &rThisVariable) override;
-
-    /**
-     * @brief Returns whether this constitutive Law has specified variable (Matrix)
-     * @param rThisVariable the variable to be checked for
-     * @return true if the variable is defined in the constitutive law
-     */
-    bool Has(const Variable<Matrix> &rThisVariable) override;
-
-    /**
-     * @brief Sets the value of a specified variable (double)
-     * @param rVariable the variable to be returned
-     * @param rValue new value of the specified variable
-     * @param rCurrentProcessInfo the process info
-     */
-    void SetValue(
-        const Variable<double> &rThisVariable,
-        const double& rValue,
-        const ProcessInfo& rCurrentProcessInfo
-        ) override;
-
-    /**
-     * @brief Returns the value of a specified variable (double)
-     * @param rThisVariable the variable to be returned
-     * @param rValue a reference to the returned value
-     * @return rValue output: the value of the specified variable
-     */
-    double& GetValue(
-        const Variable<double> &rThisVariable,
-        double& rValue
-        ) override;
-
-    /**
-     * @brief Returns the value of a specified variable (Vector)
-     * @param rThisVariable the variable to be returned
-     * @param rValue a reference to the returned value
-     * @return rValue output: the value of the specified variable
-     */
-    Vector& GetValue(
-        const Variable<Vector> &rThisVariable,
-        Vector& rValue
-        ) override;
-
-    /**
-     * @brief Returns the value of a specified variable (matrix)
-     * @param rThisVariable the variable to be returned
-     * @param rValue a reference to the returned value
-     * @return rValue output: the value of the specified variable
-     */
-    Matrix& GetValue(
-        const Variable<Matrix>& rThisVariable,
-        Matrix& rValue
-        ) override;
-
-    /**
-     * @brief Returns the value of a specified variable (double)
-     * @param rParameterValues the needed parameters for the CL calculation
-     * @param rThisVariable the variable to be returned
-     * @param rValue a reference to the returned value
-     * @param rValue output: the value of the specified variable
-     */
-    double& CalculateValue(
-        ConstitutiveLaw::Parameters& rParameterValues,
-        const Variable<double>& rThisVariable,
-        double& rValue) override;
-
-    /**
-     * @brief Returns the value of a specified variable (vector)
-     * @param rParameterValues the needed parameters for the CL calculation
-     * @param rThisVariable the variable to be returned
-     * @param rValue a reference to the returned value
-     * @param rValue output: the value of the specified variable
-     */
-    Vector& CalculateValue(
-        ConstitutiveLaw::Parameters& rParameterValues,
-        const Variable<Vector>& rThisVariable,
-        Vector& rValue
-        ) override;
-
-    /**
-     * @brief Returns the value of a specified variable (matrix)
-     * @param rParameterValues the needed parameters for the CL calculation
-     * @param rThisVariable the variable to be returned
-     * @param rValue a reference to the returned value
-     * @param rValue output: the value of the specified variable
-     */
-    Matrix& CalculateValue(
-        ConstitutiveLaw::Parameters& rParameterValues,
-        const Variable<Matrix>& rThisVariable,
-        Matrix& rValue
-        ) override;
-
-    /**
-     * @brief This function provides the place to perform checks on the completeness of the input.
-     * @details It is designed to be called only once (or anyway, not often) typically at the beginning
-     * of the calculations, so to verify that nothing is missing from the input or that no common error is found.
-     * @param rMaterialProperties The properties of the material
-     * @param rElementGeometry The geometry of the element
-     * @param rCurrentProcessInfo The current process info instance
-     * @return 0 if OK, 1 otherwise
-     */
-    int Check(
-        const Properties& rMaterialProperties,
-        const GeometryType& rElementGeometry,
-        const ProcessInfo& rCurrentProcessInfo
-        ) override;
-
-    ///@}
-    ///@name Access
-    ///@{
-
-    ///@}
-    ///@name Inquiry
-    ///@{
-
-    ///@}
-    ///@name Input and output
-    ///@{
-
-    ///@}
-    ///@name Friends
-    ///@{
-
-    ///@}
-
-protected:
-    ///@name Protected static Member Variables
-    ///@{
-
-    ///@}
-    ///@name Protected member Variables
-    ///@{
-
-    ///@}
-    ///@name Protected Operators
-    ///@{
-
-    ///@}
-    ///@name Protected Operations
-    ///@{
-    // Tension values
-    double& GetTensionThreshold() { return mTensionThreshold; }
-    double& GetTensionDamage() { return mTensionDamage; }
-    double& GetNonConvTensionThreshold() { return mNonConvTensionThreshold; }
-    double& GetNonConvTensionDamage() { return mNonConvTensionDamage; }
-
-    void SetTensionThreshold(const double toThreshold) { mTensionThreshold = toThreshold; }
-    void SetTensionDamage(const double toDamage) { mTensionDamage = toDamage; }
-    void SetNonConvTensionThreshold(const double toThreshold) { mNonConvTensionThreshold = toThreshold; }
-    void SetNonConvTensionDamage(const double toDamage) { mNonConvTensionDamage = toDamage; }
-
-    // Compression values
-    double& GetCompressionThreshold() { return mCompressionThreshold; }
-    double& GetCompressionDamage() { return mCompressionDamage; }
-    double& GetNonConvCompressionThreshold() { return mNonConvCompressionThreshold; }
-    double& GetNonConvCompressionDamage() { return mNonConvCompressionDamage; }
-
-    void SetCompressionThreshold(const double toThreshold) { mCompressionThreshold = toThreshold; }
-    void SetCompressionDamage(const double toDamage) { mCompressionDamage = toDamage; }
-    void SetNonConvCompressionThreshold(const double toThreshold) { mNonConvCompressionThreshold = toThreshold; }
-    void SetNonConvCompressionDamage(const double toDamage) { mNonConvCompressionDamage = toDamage; }
-
-    void SetTensionStress(const double toS){mTensionUniaxialStress = toS;}
-    void SetCompressionStress(const double toS){mCompressionUniaxialStress = toS;}
-
-    ///@}
-    ///@name Protected  Access
-    ///@{
-
-    ///@}
-    ///@name Protected Inquiry
-    ///@{
-
-    ///@}
-    ///@name Protected LifeCycle
-    ///@{
-
-    ///@}
-
-private:
-   ///@name Static Member Variables
-    ///@{
-
-    ///@}
-    ///@name Member Variables
-    ///@{
-
-    // Converged values
-    double mTensionDamage = 0.0;
-    double mTensionThreshold = 0.0;
-
-    // Non Converged values
-    double mNonConvTensionDamage = 0.0;
-    double mNonConvTensionThreshold = 0.0;
-
-    double mCompressionDamage = 0.0;
-    double mCompressionThreshold = 0.0;
-    // double mUniaxialStress = 0.0;
-
-    // Non Converged values
-    double mNonConvCompressionDamage = 0.0;
-    double mNonConvCompressionThreshold = 0.0;
-
-    double mTensionUniaxialStress = 0.0;
-    double mCompressionUniaxialStress = 0.0;
-    ///@}
-    ///@name Private Operators
-    ///@{
-
-    ///@}
-    ///@name Private Operations
-    ///@{
-
-    /**
-     * @brief This method computes the tangent tensor
-     * @param rValues The constitutive law parameters and flags
-     */
-    void CalculateTangentTensor(ConstitutiveLaw::Parameters &rValues);
-
-    /**
-     * @brief This method computes the secant tensor
-     * @param rValues The constitutive law parameters and flags
-     */
-    void CalculateSecantTensor(ConstitutiveLaw::Parameters& rValues, Matrix& rSecantTensor);
-
-
-    // Serialization
-
-    friend class Serializer;
-
-    void save(Serializer &rSerializer) const override
-    {
-        KRATOS_SERIALIZE_SAVE_BASE_CLASS(rSerializer, ConstitutiveLaw)
-        rSerializer.save("TensionDamage", mTensionDamage);
-        rSerializer.save("TensionThreshold", mTensionThreshold);
-        rSerializer.save("NonConvTensionDamage", mNonConvTensionDamage);
-        rSerializer.save("NonConvTensionThreshold", mNonConvTensionThreshold);
-        rSerializer.save("CompressionDamage", mCompressionDamage);
-        rSerializer.save("CompressionThreshold", mCompressionThreshold);
-        rSerializer.save("NonConvCompressionnDamage", mNonConvCompressionDamage);
-        rSerializer.save("NonConvCompressionThreshold", mNonConvCompressionThreshold);
-    }
-
-    void load(Serializer &rSerializer) override
-    {
-        KRATOS_SERIALIZE_LOAD_BASE_CLASS(rSerializer, ConstitutiveLaw)
-        rSerializer.load("TensionDamage", mTensionDamage);
-        rSerializer.load("TensionThreshold", mTensionThreshold);
-        rSerializer.load("NonConvTensionDamage", mNonConvTensionDamage);
-        rSerializer.load("NonConvTensionThreshold", mNonConvTensionThreshold);
-        rSerializer.load("CompressionDamage", mCompressionDamage);
-        rSerializer.load("CompressionThreshold", mCompressionThreshold);
-        rSerializer.load("NonConvCompressionnDamage", mNonConvCompressionDamage);
-        rSerializer.load("NonConvCompressionThreshold", mNonConvCompressionThreshold);
-    }
-
-    /**
-     * @brief This method computes the equivalent stress in Tension
-     * @param rValues The constitutive law parameters and flags
-     *           rPredictiveStressVector Predictive or effective Stress Vector
-     *        rEquivalentStress The equivalent Stress to be filled by method
-     */
-    void CalculateEquivalentStressTension(
-    array_1d<double, VoigtSize>& rPredictiveStressVector,
-    double& rEquivalentStress,
-    ConstitutiveLaw::Parameters& rValues);
-
-    /**
-     * @brief This method computes the equivalent stress in Compression
-     * @param rValues The constitutive law parameters and flags
-     *           rPredictiveStressVector Predictive or effective Stress Vector
-     *        rEquivalentStress The equivalent Stress to be filled by method
-     */
-    void CalculateEquivalentStressCompression(
-    array_1d<double, VoigtSize>& rPredictiveStressVector,
-    double& rEquivalentStress,
-    ConstitutiveLaw::Parameters& rValues);
-
-    /**
-     * @brief This method computes the final stress vector in Tension
-     * @param rValues The constitutive law parameters and flags
-     *           rPredictiveStressVector Tension Part of the predictive or effective stress vector
-     *        UniaxialStress The equivalent uniaxial stress in Tension
-     *        rDamage The damage variable in Tension
-     *          rThreshold The Damage Threshold in Tension
-     *          CharacteristicLength The finite element charecteristic length
-     */
-    void IntegrateStressVectorTension(
-    array_1d<double,VoigtSize>& rPredictiveStressVector,
-    const double UniaxialStress,
-    double& rDamage,
-    double& rThreshold,
-    ConstitutiveLaw::Parameters& rValues,
-    const double CharacteristicLength);
-
-    /**
-     *  @brief This method computes the damage parameter for the exponential softening behavior in tension
-     *  @params rValues The constitutive law parameters and flags
-     *          rAParameter The damage parameter filled by method
-     *          CharacteristicLength The finite element charecteristic length
-     */
-    void CalculateDamageParameterTension(
-    ConstitutiveLaw::Parameters& rValues,
-    double& rAParameter,
-    const double CharacteristicLength);
-
-    /**
-     * @brief This method computes the tension damage variable for the exponential softening law in tension
-     * @params rValues The constitutive law parameters and flags
-     *            UniaxialStress The equivalent uniaxial stress in Tension
-     *         Threshold The damage threshold in Tension
-     *         DamageParameter The damage parameter for the exponential softening law
-     *         CharacteristicLength The finite element charecteristic length
-     *         rDamage The tension damage variable filled by the method
-     */
-
-    void CalculateExponentialDamageTension(
-    const double UniaxialStress,
-    const double Threshold,
-    const double DamageParameter,
-    const double CharacteristicLength,
-    ConstitutiveLaw::Parameters& rValues,
-    double& rDamage);
-
-    /**
-     * @brief This method computes the final stress vector in Tension
-     * @param rValues The constitutive law parameters and flags
-     *           rPredictiveStressVector Compression Part of the predictive or effective stress vector
-     *        UniaxialStress The equivalent uniaxial stress in Compression
-     *        rDamage The damage variable in Compression
-     *          rThreshold The Damage Threshold in Compression
-     *          CharacteristicLength The finite element charecteristic length
-     */
-    void IntegrateStressVectorCompression(
-    array_1d<double,VoigtSize>& rPredictiveStressVector,
-    const double UniaxialStress,
-    double& rDamage,
-    double& rThreshold,
-    ConstitutiveLaw::Parameters& rValues,
-    const double CharacteristicLength);
-
-    /**
-     *  BRIEF DOCUMENTATION OF THE USED UNIAXIAL SOFTENING BEHAVIOR IN COMPRESSION
-     *  Entire documentation can be found in the the Phd Thesis of Massimo Petracca
-     *  << Computational Multiscale Analysis of Masonry Structures>>
-     *
-     *  UNIAXIAL BEZIER COMPRESSION DAMAGE
-     *  {I}   Linear Elastic
-     *  {II}  Hardening Quadratic Bezier Curve
-     *          Control nodes:  0=(e_0,s_0); I=(e_i,s_p); P=(e_p,s_p)
-     *  {III} Softening Quadratic Bezier Curve
-     *          Control nodes:  P=(e_p,s_p); J=(e_j,s_j); K=(e_k,s_k)
-     *  {IV}  Softening Quadratic Bezier Curve
-     *          Control nodes:  K=(e_k,s_k); R=(e_r,s_r); U=(e_u,s_u)
-     *  {V}   Residual Strength
-     *
-     *    STRESS
-     *       ^
-     *      /|\
-     *       |                     (P)
-     * s_p = |------------(I)+----#####--+(J)
-     * s_i = |               ' ###  ' ####
-     * s_j   |              ###     '    ####
-     *       |            ###'      '    ' ###
-     * s_k   |-----------##--+------+----+--## (K)
-     * s_0   |---------##(0) '      '    '   ###
-     *       |        ## '   '      '    '    '##
-     *       |       ##  '   '      '    '    '   ####
-     *       |      ##   '   '      '    '    '      #####
-     *       |     ##    '   '      '    '    '          #####
-     *       |    ##     '   '      '    '    '    (R)       ######## (U)
-     * s_r = |---##------+---+------'----+----+-----+-----------------######################
-     * s_u   |  ##       '   '      '    '    '     '                 '
-     *       |_##________+___+______+____+____+_____+_________________+______________________________\
-     *                  e_0 e_i    e_p  e_j  e_k   e_r               e_u                             / STRAIN
-     *        '          '          '         '                       '
-     *        '   {I}    '   {II}   '  {III}  '        {IV}           '          {V}
-     *        '          '          '         '                       '
-     *
-     */
-    /**
-     * @brief This method computes the Damage Variable in Compression by considering three Bezier curves (hardening + softening + softening + residual)
-     * @param rValues The constitutive law parameters and flags
-     *        UniaxialStress The equivalent uniaxial stress in Compression
-     *        rDamage The damage variable in Compression
-     *          rThreshold The Damage Threshold in Compression
-     *        CharacteristicLength The finite element charecteristic length
-     */
-    void CalculateBezier3DamageCompression(
-    const double UniaxialStress,
-    double& rDamage,
-    double& rThreshold,
-    const double CharacteristicLength,
-    ConstitutiveLaw::Parameters& rValues);
-
-    /**
-     * @brief This method regulates the four bezier control strains to avoid a constitutive snap-back (fracture energy considerations)
-     * @param specific_dissipated_fracture_energy FRACTURE_ENERGY_CMOPRESSION devided by CharacteristicLength
-     *        sp, sk, sr stress Values to control the bezier curves
-     *        ep strain pproperty to control the bezier curve
-     *        ej, ek, er, eu strain properties to be regulated in method
-     */
-    void RegulateBezierDeterminators(
-    const double specific_dissipated_fracture_energy,
-    const double sp, const double sk, const double sr, const double ep,
-    double& ej, double& ek, double& er, double& eu);
-
-    /**
-     * @brief This method computes the area beneath the parts of the bezier curves, respectively
-     * @param BezierG Area beneath the curve, to be filled by method
-     *        x1, x2, x3, y1, y2, y3 coordinates of the control points of the bezier
-     */
-    void ComputeBezierEnergy(
-    double& BezierG,
-    const double x1, const double x2, const double x3,
-    const double y1, const double y2, const double y3);
-
-    /**
-     * @brief This method returns the bezier damage parameter
-     * @param Xi Strain-like counterpart of the uniaxial compression stress
-     *        x1, x2, x3 Necesarry Stress values to define the uniaxial compression damage bezier curve
-     *        y1, y2, y3 Necesarry Strain vlaues to define the uniaxial compression damage bezier curve
-     */
-    double EvaluateBezierCurve(
-    const double Xi,
-    const double x1, double x2, const double x3,
-    const double y1, const double y2, const double y3);
-
-
-    ///@}
-    ///@name Private  Access
-    ///@{
-
-    ///@}
-    ///@name Private Inquiry
-    ///@{
-
-    ///@}
-    ///@name Un accessible methods
-    ///@{
-
-
-
-    ///@}
-
-}; // Class DamageDPlusDMinusMasonry3DLaw
-}// namespace Kratos
-#endif
-
diff --git a/applications/StructuralMechanicsApplication/custom_constitutive/generic_finite_strain_isotropic_plasticity.h b/applications/StructuralMechanicsApplication/custom_constitutive/generic_finite_strain_isotropic_plasticity.h
index ec0dcfcf82..b9adab2e52 100644
--- a/applications/StructuralMechanicsApplication/custom_constitutive/generic_finite_strain_isotropic_plasticity.h
+++ b/applications/StructuralMechanicsApplication/custom_constitutive/generic_finite_strain_isotropic_plasticity.h
@@ -429,12 +429,12 @@ protected:
     // Converged values
     double mPlasticDissipation = 0.0;
     double mThreshold = 0.0;
-    Matrix mPlasticDeformationGradient = IdentityMatrix(Dimension);
+    Matrix mPlasticDeformationGradient = IdentityMatrix(Dimension, Dimension);
 
     // Non Converged values
     double mNonConvPlasticDissipation = 0.0;
     double mNonConvThreshold = 0.0;
-    Matrix mNonConvPlasticDeformationGradient = IdentityMatrix(Dimension);
+    Matrix mNonConvPlasticDeformationGradient = IdentityMatrix(Dimension, Dimension);
 
     // Auxiliar to print (NOTE: Alejandro do we need this now?)
     double mUniaxialStress = 0.0;
diff --git a/applications/StructuralMechanicsApplication/custom_constitutive/generic_small_strain_kinematic_plasticity.cpp b/applications/StructuralMechanicsApplication/custom_constitutive/generic_small_strain_kinematic_plasticity.cpp
index 307f242251..957a8ebc91 100644
--- a/applications/StructuralMechanicsApplication/custom_constitutive/generic_small_strain_kinematic_plasticity.cpp
+++ b/applications/StructuralMechanicsApplication/custom_constitutive/generic_small_strain_kinematic_plasticity.cpp
@@ -70,7 +70,7 @@ template <class TConstLawIntegratorType>
 void GenericSmallStrainKinematicPlasticity<TConstLawIntegratorType>::CalculateMaterialResponseCauchy(ConstitutiveLaw::Parameters& rValues)
 {
     // Integrate Stress plasticity
-    Vector& r_integrated_stress_vector = rValues.GetStressVector();
+    Vector& integrated_stress_vector = rValues.GetStressVector();
     const double characteristic_length = ConstitutiveLawUtilities<VoigtSize>::CalculateCharacteristicLength(rValues.GetElementGeometry());
     const Flags& r_constitutive_law_options = rValues.GetOptions();
 
@@ -101,7 +101,7 @@ void GenericSmallStrainKinematicPlasticity<TConstLawIntegratorType>::CalculateMa
         Vector back_stress_vector = this->GetBackStressVector();
         const Vector previous_stress_vector = this->GetPreviousStressVector();
 
-        array_1d<double, VoigtSize> predictive_stress_vector, kin_hard_stress_vector;
+        array_1d<double, VoigtSize> predictive_stress_vector;
         if (r_constitutive_law_options.Is(ConstitutiveLaw::U_P_LAW)) {
             predictive_stress_vector = rValues.GetStressVector();
         } else {
@@ -116,17 +116,17 @@ void GenericSmallStrainKinematicPlasticity<TConstLawIntegratorType>::CalculateMa
         array_1d<double, VoigtSize> plastic_strain_increment = ZeroVector(VoigtSize);
 
         // Kinematic back stress substracted
-        noalias(kin_hard_stress_vector) = predictive_stress_vector - back_stress_vector;
+        predictive_stress_vector -= back_stress_vector;
 
-		const double threshold_indicator = TConstLawIntegratorType::CalculatePlasticParameters(
-            kin_hard_stress_vector, r_strain_vector, uniaxial_stress,
+		const double threshold_indicator =TConstLawIntegratorType::CalculatePlasticParameters(
+            predictive_stress_vector, r_strain_vector, uniaxial_stress,
             threshold, plastic_denominator, f_flux, g_flux,
             plastic_dissipation, plastic_strain_increment,
             r_constitutive_matrix, rValues, characteristic_length,
             plastic_strain, back_stress_vector);
 
         if (threshold_indicator <= std::abs(1.0e-4 * threshold)) { // Elastic case
-            noalias(r_integrated_stress_vector) = predictive_stress_vector;
+            noalias(integrated_stress_vector) = predictive_stress_vector;
         } else { // Plastic case
             // while loop backward euler
             /* Inside "IntegrateStressVector" the predictive_stress_vector is updated to verify the yield criterion */
@@ -138,7 +138,7 @@ void GenericSmallStrainKinematicPlasticity<TConstLawIntegratorType>::CalculateMa
                 characteristic_length, back_stress_vector,
                 previous_stress_vector);
 
-            noalias(r_integrated_stress_vector) = predictive_stress_vector;
+            noalias(integrated_stress_vector) = predictive_stress_vector;
 
             if (r_constitutive_law_options.Is(ConstitutiveLaw::COMPUTE_CONSTITUTIVE_TENSOR)) {
                 this->CalculateTangentTensor(rValues); // this modifies the ConstitutiveMatrix
@@ -245,22 +245,27 @@ void GenericSmallStrainKinematicPlasticity<TConstLawIntegratorType>::FinalizeMat
 
     // We get the strain vector
     Vector& r_strain_vector = rValues.GetStrainVector();
-	Matrix& r_constitutive_matrix = rValues.GetConstitutiveMatrix();
-    this->CalculateValue(rValues, CONSTITUTIVE_MATRIX, r_constitutive_matrix);
+    Matrix& r_constitutive_matrix = rValues.GetConstitutiveMatrix();
 
     //NOTE: SINCE THE ELEMENT IS IN SMALL STRAINS WE CAN USE ANY STRAIN MEASURE. HERE EMPLOYING THE CAUCHY_GREEN
     if ( r_constitutive_law_options.IsNot(ConstitutiveLaw::USE_ELEMENT_PROVIDED_STRAIN)) {
         this->CalculateValue(rValues, STRAIN, r_strain_vector);
     }
 
+    // Elastic Matrix
+    if (r_constitutive_law_options.Is(ConstitutiveLaw::COMPUTE_CONSTITUTIVE_TENSOR)) {
+        Matrix& r_constitutive_matrix = rValues.GetConstitutiveMatrix();
+        this->CalculateValue(rValues, CONSTITUTIVE_MATRIX, r_constitutive_matrix);
+    }
+
     // We get some variables
     double threshold = this->GetThreshold();
     double plastic_dissipation = this->GetPlasticDissipation();
     Vector plastic_strain = this->GetPlasticStrain();
     Vector back_stress_vector = this->GetBackStressVector();
-    const Vector previous_stress_vector = this->GetPreviousStressVector();
+    const Vector& previous_stress_vector = this->GetPreviousStressVector();
 
-    array_1d<double, VoigtSize> predictive_stress_vector, kin_hard_stress_vector;
+    array_1d<double, VoigtSize> predictive_stress_vector;
     if (r_constitutive_law_options.Is(ConstitutiveLaw::U_P_LAW)) {
         predictive_stress_vector = rValues.GetStressVector();
     } else {
@@ -275,10 +280,10 @@ void GenericSmallStrainKinematicPlasticity<TConstLawIntegratorType>::FinalizeMat
     array_1d<double, VoigtSize> plastic_strain_increment = ZeroVector(VoigtSize);
 
     // Kinematic back stress substracted
-    noalias(kin_hard_stress_vector) = predictive_stress_vector - back_stress_vector;
+    predictive_stress_vector -= back_stress_vector;
 
     const double threshold_indicator = TConstLawIntegratorType::CalculatePlasticParameters(
-        kin_hard_stress_vector, r_strain_vector, uniaxial_stress,
+        predictive_stress_vector, r_strain_vector, uniaxial_stress,
         threshold, plastic_denominator, f_flux, g_flux,
         plastic_dissipation, plastic_strain_increment,
         r_constitutive_matrix, rValues, characteristic_length,
@@ -296,9 +301,8 @@ void GenericSmallStrainKinematicPlasticity<TConstLawIntegratorType>::FinalizeMat
             previous_stress_vector);
     }
 
-    TConstLawIntegratorType::YieldSurfaceType::CalculateEquivalentStress(predictive_stress_vector, r_strain_vector, uniaxial_stress, rValues);
-	mUniaxialStress = uniaxial_stress;
-	mPlasticDissipation = plastic_dissipation;
+    mUniaxialStress = uniaxial_stress;
+    mPlasticDissipation = plastic_dissipation;
     mThreshold = threshold;
     mPlasticStrain = plastic_strain;
     mBackStressVector = back_stress_vector;
@@ -329,8 +333,6 @@ bool GenericSmallStrainKinematicPlasticity<TConstLawIntegratorType>::Has(const V
 {
     if (rThisVariable == PLASTIC_STRAIN_VECTOR) {
         return true;
-    } else if (rThisVariable == BACK_STRESS_VECTOR) {
-        return true;
     } else {
         return BaseType::Has(rThisVariable);
     }
@@ -343,16 +345,7 @@ bool GenericSmallStrainKinematicPlasticity<TConstLawIntegratorType>::Has(const V
 template <class TConstLawIntegratorType>
 bool GenericSmallStrainKinematicPlasticity<TConstLawIntegratorType>::Has(const Variable<Matrix>& rThisVariable)
 {
-    if (rThisVariable == PLASTIC_STRAIN_TENSOR) {
-        return true;
-    } else if (rThisVariable == BACK_STRESS_TENSOR) {
-        return true;
-    } else if (rThisVariable == INTEGRATED_STRESS_TENSOR) {
-        return true;
-    } else {
-        return BaseType::Has(rThisVariable);
-    }
-    return false;
+    return BaseType::Has(rThisVariable);
 }
 
 /***********************************************************************************/
@@ -420,8 +413,6 @@ Vector& GenericSmallStrainKinematicPlasticity<TConstLawIntegratorType>::GetValue
 {
     if (rThisVariable == PLASTIC_STRAIN_VECTOR) {
         rValue = mPlasticStrain;
-    } else if (rThisVariable == BACK_STRESS_VECTOR) {
-        rValue = mBackStressVector;
     } else {
         return BaseType::GetValue(rThisVariable, rValue);
     }
@@ -439,10 +430,6 @@ Matrix& GenericSmallStrainKinematicPlasticity<TConstLawIntegratorType>::GetValue
 {
     if (rThisVariable == PLASTIC_STRAIN_TENSOR) {
         rValue = MathUtils<double>::StrainVectorToTensor(mPlasticStrain);
-    } else if (rThisVariable == BACK_STRESS_TENSOR) {
-        rValue = MathUtils<double>::StressVectorToTensor(mBackStressVector);
-    } else if (rThisVariable == INTEGRATED_STRESS_TENSOR) {
-        rValue = MathUtils<double>::StressVectorToTensor(mPreviousStressVector);
     } else {
         return BaseType::GetValue(rThisVariable, rValue);
     }
@@ -462,6 +449,7 @@ double& GenericSmallStrainKinematicPlasticity<TConstLawIntegratorType>::Calculat
     if (rThisVariable == EQUIVALENT_PLASTIC_STRAIN) {
         const Vector& r_stress_vector = rParameterValues.GetStressVector();
         TConstLawIntegratorType::CalculateEquivalentPlasticStrain(r_stress_vector, mUniaxialStress, mPlasticStrain, 0.0, rParameterValues, rValue);
+
         return rValue;
     } else {
         return this->GetValue(rThisVariable, rValue);
@@ -511,9 +499,13 @@ int GenericSmallStrainKinematicPlasticity<TConstLawIntegratorType>::Check(
     )
 {
     const int check_base = BaseType::Check(rMaterialProperties, rElementGeometry, rCurrentProcessInfo);
+
     const int check_integrator = TConstLawIntegratorType::Check(rMaterialProperties);
+
     KRATOS_ERROR_IF_NOT(VoigtSize == this->GetStrainSize()) << "You are combining not compatible constitutive laws" << std::endl;
+    
     if ((check_base + check_integrator) > 0) return 1;
+
     return 0;
 }
 
diff --git a/applications/StructuralMechanicsApplication/custom_constitutive/generic_small_strain_kinematic_plasticity.h b/applications/StructuralMechanicsApplication/custom_constitutive/generic_small_strain_kinematic_plasticity.h
index f2d01723fe..7ded213b80 100644
--- a/applications/StructuralMechanicsApplication/custom_constitutive/generic_small_strain_kinematic_plasticity.h
+++ b/applications/StructuralMechanicsApplication/custom_constitutive/generic_small_strain_kinematic_plasticity.h
@@ -106,9 +106,14 @@ public:
         mPlasticDissipation(rOther.mPlasticDissipation),
         mThreshold(rOther.mThreshold),
         mPlasticStrain(rOther.mPlasticStrain),
+        mNonConvPlasticDissipation(rOther.mNonConvPlasticDissipation),
+        mNonConvThreshold(rOther.mNonConvThreshold),
+        mNonConvPlasticStrain(rOther.mNonConvPlasticStrain),
         mUniaxialStress(rOther.mUniaxialStress),
         mPreviousStressVector(rOther.mPreviousStressVector),
-        mBackStressVector(rOther.mBackStressVector)
+        mBackStressVector(rOther.mBackStressVector),
+        mNonConvergedBackStressVector(rOther.mNonConvergedBackStressVector),
+        mNonConvergedPreviousStressVector(rOther.mNonConvergedPreviousStressVector)
     {
     }
 
@@ -367,15 +372,28 @@ protected:
     double& GetPlasticDissipation() { return mPlasticDissipation; }
     Vector& GetPlasticStrain() { return mPlasticStrain; }
 
+    double& GetNonConvThreshold() { return mNonConvThreshold; }
+    double& GetNonConvPlasticDissipation() { return mNonConvPlasticDissipation; }
+    Vector& GetNonConvPlasticStrain() { return mNonConvPlasticStrain; }
+
     void SetThreshold(const double Threshold) { mThreshold = Threshold; }
     void SetPlasticDissipation(const double PlasticDissipation) { mPlasticDissipation = PlasticDissipation; }
     void SetPlasticStrain(const array_1d<double, VoigtSize>& rPlasticStrain) { mPlasticStrain = rPlasticStrain; }
 
+    void SetNonConvThreshold(const double NonConvThreshold) { mNonConvThreshold = NonConvThreshold; }
+    void SetNonConvPlasticDissipation(const double NonConvPlasticDissipation) { mNonConvPlasticDissipation = NonConvPlasticDissipation; }
+    void SetNonConvPlasticStrain(const array_1d<double, VoigtSize>& rNonConvPlasticStrain) { mNonConvPlasticStrain = rNonConvPlasticStrain; }
+
     void SetBackStressVector (const Vector& toBS) {mBackStressVector = toBS; }
     Vector& GetBackStressVector() { return mBackStressVector; }
+    Vector& GetNonConvergedBackStressVector() { return mNonConvergedBackStressVector; }
+    void SetNonConvergedBackStressVector(const Vector& toBack) {mNonConvergedBackStressVector = toBack; }
+
 
     void SetPreviousStressVector (const Vector& toBS) {mPreviousStressVector = toBS; }
     Vector& GetPreviousStressVector() { return mPreviousStressVector;}
+    void SetNonConvergedPreviousStressVector (const Vector& toBS) {mNonConvergedPreviousStressVector = toBS; }
+    Vector GetNonConvergedPreviousStressVector() { return mNonConvergedPreviousStressVector;}
 
     ///@}
     ///@name Protected Operations
@@ -407,12 +425,19 @@ protected:
     double mThreshold = 0.0;
     Vector mPlasticStrain = ZeroVector(VoigtSize);
 
+    // Non Converged values
+    double mNonConvPlasticDissipation = 0.0;
+    double mNonConvThreshold = 0.0;
+    Vector mNonConvPlasticStrain = ZeroVector(VoigtSize);
+
     // Auxiliar to print (NOTE: Alejandro do we need this now?)
     double mUniaxialStress = 0.0;
 
     // Kinematic variables
     Vector mPreviousStressVector = ZeroVector(VoigtSize);
     Vector mBackStressVector = ZeroVector(VoigtSize);
+    Vector mNonConvergedBackStressVector = ZeroVector(VoigtSize);
+    Vector mNonConvergedPreviousStressVector = ZeroVector(VoigtSize);
 
     ///@}
     ///@name Private Operators
@@ -450,8 +475,13 @@ protected:
         rSerializer.save("PlasticDissipation", mPlasticDissipation);
         rSerializer.save("Threshold", mThreshold);
         rSerializer.save("PlasticStrain", mPlasticStrain);
+        rSerializer.save("NonConvPlasticDissipation", mNonConvPlasticDissipation);
+        rSerializer.save("NonConvThreshold", mNonConvThreshold);
+        rSerializer.save("NonConvPlasticStrain", mNonConvPlasticStrain);
         rSerializer.save("PreviousStressVector", mPreviousStressVector);
         rSerializer.save("BackStressVector", mBackStressVector);
+        rSerializer.save("NonConvergedBackStressVector", mNonConvergedBackStressVector);
+        rSerializer.save("NonConvergedPreviousStressVector", mNonConvergedPreviousStressVector);
     }
 
     void load(Serializer &rSerializer) override
@@ -460,8 +490,13 @@ protected:
         rSerializer.load("PlasticDissipation", mPlasticDissipation);
         rSerializer.load("Threshold", mThreshold);
         rSerializer.load("PlasticStrain", mPlasticStrain);
+        rSerializer.load("NonConvPlasticDissipation", mNonConvPlasticDissipation);
+        rSerializer.load("NonConvThreshold", mNonConvThreshold);
+        rSerializer.load("NonConvPlasticStrain", mNonConvPlasticStrain);
         rSerializer.load("PreviousStressVector", mPreviousStressVector);
         rSerializer.load("BackStressVector", mBackStressVector);
+        rSerializer.load("NonConvergedBackStressVector", mNonConvergedBackStressVector);
+        rSerializer.load("NonConvergedPreviousStressVector", mNonConvergedPreviousStressVector);
     }
 
     ///@}
diff --git a/applications/StructuralMechanicsApplication/custom_constitutive/hyper_elastic_isotropic_kirchhoff_3d.cpp b/applications/StructuralMechanicsApplication/custom_constitutive/hyper_elastic_isotropic_kirchhoff_3d.cpp
index ec2fffbd56..cdf84c972e 100644
--- a/applications/StructuralMechanicsApplication/custom_constitutive/hyper_elastic_isotropic_kirchhoff_3d.cpp
+++ b/applications/StructuralMechanicsApplication/custom_constitutive/hyper_elastic_isotropic_kirchhoff_3d.cpp
@@ -522,7 +522,7 @@ void HyperElasticIsotropicKirchhoff3D::CalculatePK2Stress(
       E_trace += E_tensor (i,i);
     }
     const SizeType dimension = WorkingSpaceDimension();
-    Matrix stress_matrix = lame_lambda*E_trace*IdentityMatrix(dimension) + 2.0 * lame_mu * E_tensor;
+    Matrix stress_matrix = lame_lambda*E_trace*IdentityMatrix(dimension, dimension) + 2.0 * lame_mu * E_tensor;
     rStressVector = MathUtils<double>::StressTensorToVector( stress_matrix, rStressVector.size() );
 
 //     // Other possibility
diff --git a/applications/StructuralMechanicsApplication/custom_constitutive/hyper_elastic_isotropic_neo_hookean_3d.cpp b/applications/StructuralMechanicsApplication/custom_constitutive/hyper_elastic_isotropic_neo_hookean_3d.cpp
index 6d43a6ff2c..f41d141550 100644
--- a/applications/StructuralMechanicsApplication/custom_constitutive/hyper_elastic_isotropic_neo_hookean_3d.cpp
+++ b/applications/StructuralMechanicsApplication/custom_constitutive/hyper_elastic_isotropic_neo_hookean_3d.cpp
@@ -547,7 +547,7 @@ void HyperElasticIsotropicNeoHookean3D::CalculatePK2Stress(
 
     const SizeType dimension = WorkingSpaceDimension();
 
-    stress_matrix = LameLambda * std::log(DeterminantF) * rInvCTensor + LameMu * ( IdentityMatrix(dimension) - rInvCTensor );
+    stress_matrix = LameLambda * std::log(DeterminantF) * rInvCTensor + LameMu * ( IdentityMatrix(dimension, dimension) - rInvCTensor );
 
     rStressVector = MathUtils<double>::StressTensorToVector( stress_matrix, GetStrainSize() );
 }
@@ -567,7 +567,7 @@ void HyperElasticIsotropicNeoHookean3D::CalculateKirchhoffStress(
 
     const SizeType dimension = WorkingSpaceDimension();
 
-    stress_matrix  = LameLambda * std::log(DeterminantF) * IdentityMatrix(dimension) + LameMu * ( rBTensor - IdentityMatrix(dimension) );
+    stress_matrix  = LameLambda * std::log(DeterminantF) * IdentityMatrix(dimension, dimension) + LameMu * ( rBTensor - IdentityMatrix(dimension, dimension) );
 
     rStressVector = MathUtils<double>::StressTensorToVector( stress_matrix, rStressVector.size() );
 }
diff --git a/applications/StructuralMechanicsApplication/custom_constitutive/small_strain_isotropic_damage_3d.cpp b/applications/StructuralMechanicsApplication/custom_constitutive/linear_isotropic_damage_3D_law.cpp
similarity index 86%
rename from applications/StructuralMechanicsApplication/custom_constitutive/small_strain_isotropic_damage_3d.cpp
rename to applications/StructuralMechanicsApplication/custom_constitutive/linear_isotropic_damage_3D_law.cpp
index 7e2435dda6..566efb7151 100644
--- a/applications/StructuralMechanicsApplication/custom_constitutive/small_strain_isotropic_damage_3d.cpp
+++ b/applications/StructuralMechanicsApplication/custom_constitutive/linear_isotropic_damage_3D_law.cpp
@@ -11,7 +11,7 @@
 //
 
 // Project includes
-#include "small_strain_isotropic_damage_3d.h"
+#include "linear_isotropic_damage_3D_law.h"
 #include "structural_mechanics_application_variables.h"
 #include "includes/checks.h"
 
@@ -20,7 +20,7 @@ namespace Kratos
 //******************************CONSTRUCTOR*******************************************
 //************************************************************************************
 
-SmallStrainIsotropicDamage3D::SmallStrainIsotropicDamage3D()
+LinearIsotropicDamage3D::LinearIsotropicDamage3D()
     : ConstitutiveLaw()
 {
 }
@@ -28,7 +28,7 @@ SmallStrainIsotropicDamage3D::SmallStrainIsotropicDamage3D()
 //********************************COPY CONSTRUCTOR************************************
 //************************************************************************************
 
-SmallStrainIsotropicDamage3D::SmallStrainIsotropicDamage3D(const SmallStrainIsotropicDamage3D &rOther)
+LinearIsotropicDamage3D::LinearIsotropicDamage3D(const LinearIsotropicDamage3D &rOther)
     : ConstitutiveLaw(rOther)
 {
 }
@@ -36,22 +36,22 @@ SmallStrainIsotropicDamage3D::SmallStrainIsotropicDamage3D(const SmallStrainIsot
 //********************************CLONE***********************************************
 //************************************************************************************
 
-ConstitutiveLaw::Pointer SmallStrainIsotropicDamage3D::Clone() const
+ConstitutiveLaw::Pointer LinearIsotropicDamage3D::Clone() const
 {
-    return Kratos::make_shared<SmallStrainIsotropicDamage3D>(SmallStrainIsotropicDamage3D(*this));
+    return Kratos::make_shared<LinearIsotropicDamage3D>(LinearIsotropicDamage3D(*this));
 }
 
 //********************************DESTRUCTOR******************************************
 //************************************************************************************
 
-SmallStrainIsotropicDamage3D::~SmallStrainIsotropicDamage3D()
+LinearIsotropicDamage3D::~LinearIsotropicDamage3D()
 {
 }
 
 //************************************************************************************
 //************************************************************************************
 
-bool SmallStrainIsotropicDamage3D::Has(const Variable<bool>& rThisVariable)
+bool LinearIsotropicDamage3D::Has(const Variable<bool>& rThisVariable)
 {
     if(rThisVariable == INELASTIC_FLAG){
         return true;
@@ -62,15 +62,18 @@ bool SmallStrainIsotropicDamage3D::Has(const Variable<bool>& rThisVariable)
 //************************************************************************************
 //************************************************************************************
 
-bool SmallStrainIsotropicDamage3D::Has(const Variable<double>& rThisVariable)
+bool LinearIsotropicDamage3D::Has(const Variable<double>& rThisVariable)
 {
+    if(rThisVariable == DAMAGE_VARIABLE){
+        return true;
+    }
     return false;
 }
 
 //************************************************************************************
 //************************************************************************************
 
-bool& SmallStrainIsotropicDamage3D::GetValue(
+bool& LinearIsotropicDamage3D::GetValue(
     const Variable<bool>& rThisVariable,
     bool& rValue
     )
@@ -85,7 +88,7 @@ bool& SmallStrainIsotropicDamage3D::GetValue(
 //************************************************************************************
 //************************************************************************************
 
-void SmallStrainIsotropicDamage3D::InitializeMaterial(
+void LinearIsotropicDamage3D::InitializeMaterial(
     const Properties& rMaterialProperties,
     const GeometryType& rElementGeometry,
     const Vector& rShapeFunctionsValues
@@ -99,14 +102,14 @@ void SmallStrainIsotropicDamage3D::InitializeMaterial(
 //************************************************************************************
 //************************************************************************************
 
-void SmallStrainIsotropicDamage3D::InitializeMaterialResponseCauchy(ConstitutiveLaw::Parameters& rValues)
+void LinearIsotropicDamage3D::InitializeMaterialResponseCauchy(ConstitutiveLaw::Parameters& rValues)
 {
 }
 
 //************************************************************************************
 //************************************************************************************
 
-void SmallStrainIsotropicDamage3D::InitializeMaterialResponsePK1(ConstitutiveLaw::Parameters& rValues)
+void LinearIsotropicDamage3D::InitializeMaterialResponsePK1(ConstitutiveLaw::Parameters& rValues)
 {
     // In small deformation is the same as compute Cauchy
     InitializeMaterialResponseCauchy(rValues);
@@ -115,7 +118,7 @@ void SmallStrainIsotropicDamage3D::InitializeMaterialResponsePK1(ConstitutiveLaw
 //************************************************************************************
 //************************************************************************************
 
-void SmallStrainIsotropicDamage3D::InitializeMaterialResponsePK2(ConstitutiveLaw::Parameters& rValues)
+void LinearIsotropicDamage3D::InitializeMaterialResponsePK2(ConstitutiveLaw::Parameters& rValues)
 {
     // In small deformation is the same as compute Cauchy
     InitializeMaterialResponseCauchy(rValues);
@@ -124,7 +127,7 @@ void SmallStrainIsotropicDamage3D::InitializeMaterialResponsePK2(ConstitutiveLaw
 //************************************************************************************
 //************************************************************************************
 
-void SmallStrainIsotropicDamage3D::InitializeMaterialResponseKirchhoff(ConstitutiveLaw::Parameters& rValues)
+void LinearIsotropicDamage3D::InitializeMaterialResponseKirchhoff(ConstitutiveLaw::Parameters& rValues)
 {
     // In small deformation is the same as compute Cauchy
     InitializeMaterialResponseCauchy(rValues);
@@ -133,7 +136,7 @@ void SmallStrainIsotropicDamage3D::InitializeMaterialResponseKirchhoff(Constitut
 //************************************************************************************
 //************************************************************************************
 
-void SmallStrainIsotropicDamage3D::FinalizeMaterialResponseCauchy(Parameters& rValues)
+void LinearIsotropicDamage3D::FinalizeMaterialResponseCauchy(Parameters& rValues)
 {
     double strain_variable;
     this->CalculateStressResponse(rValues, strain_variable);
@@ -143,7 +146,7 @@ void SmallStrainIsotropicDamage3D::FinalizeMaterialResponseCauchy(Parameters& rV
 //************************************************************************************
 //************************************************************************************
 
-void SmallStrainIsotropicDamage3D::FinalizeMaterialResponsePK1(Parameters& rValues)
+void LinearIsotropicDamage3D::FinalizeMaterialResponsePK1(Parameters& rValues)
 {
     // In small deformation is the same as compute Cauchy
     FinalizeMaterialResponseCauchy(rValues);
@@ -152,7 +155,7 @@ void SmallStrainIsotropicDamage3D::FinalizeMaterialResponsePK1(Parameters& rValu
 //************************************************************************************
 //************************************************************************************
 
-void SmallStrainIsotropicDamage3D::FinalizeMaterialResponsePK2(Parameters& rValues)
+void LinearIsotropicDamage3D::FinalizeMaterialResponsePK2(Parameters& rValues)
 {
     // In small deformation is the same as compute Cauchy
     FinalizeMaterialResponseCauchy(rValues);
@@ -161,7 +164,7 @@ void SmallStrainIsotropicDamage3D::FinalizeMaterialResponsePK2(Parameters& rValu
 //************************************************************************************
 //************************************************************************************
 
-void SmallStrainIsotropicDamage3D::FinalizeMaterialResponseKirchhoff(Parameters& rValues)
+void LinearIsotropicDamage3D::FinalizeMaterialResponseKirchhoff(Parameters& rValues)
 {
     // In small deformation is the same as compute Cauchy
     FinalizeMaterialResponseCauchy(rValues);
@@ -170,7 +173,7 @@ void SmallStrainIsotropicDamage3D::FinalizeMaterialResponseKirchhoff(Parameters&
 //************************************************************************************
 //************************************************************************************
 
-void SmallStrainIsotropicDamage3D::CalculateMaterialResponsePK1(Parameters& rValues)
+void LinearIsotropicDamage3D::CalculateMaterialResponsePK1(Parameters& rValues)
 {
     CalculateMaterialResponseCauchy(rValues);
 }
@@ -178,7 +181,7 @@ void SmallStrainIsotropicDamage3D::CalculateMaterialResponsePK1(Parameters& rVal
 //************************************************************************************
 //************************************************************************************
 
-void SmallStrainIsotropicDamage3D::CalculateMaterialResponsePK2(Parameters& rValues)
+void LinearIsotropicDamage3D::CalculateMaterialResponsePK2(Parameters& rValues)
 {
     CalculateMaterialResponseCauchy(rValues);
 }
@@ -186,7 +189,7 @@ void SmallStrainIsotropicDamage3D::CalculateMaterialResponsePK2(Parameters& rVal
 //************************************************************************************
 //************************************************************************************
 
-void SmallStrainIsotropicDamage3D::CalculateMaterialResponseKirchhoff(Parameters& rValues)
+void LinearIsotropicDamage3D::CalculateMaterialResponseKirchhoff(Parameters& rValues)
 {
     CalculateMaterialResponseCauchy(rValues);
 }
@@ -194,7 +197,7 @@ void SmallStrainIsotropicDamage3D::CalculateMaterialResponseKirchhoff(Parameters
 //************************************************************************************
 //************************************************************************************
 
-void SmallStrainIsotropicDamage3D::CalculateMaterialResponseCauchy(Parameters& rValues)
+void LinearIsotropicDamage3D::CalculateMaterialResponseCauchy(Parameters& rValues)
 {
     double strain_variable;
     this->CalculateStressResponse(rValues, strain_variable);
@@ -203,7 +206,7 @@ void SmallStrainIsotropicDamage3D::CalculateMaterialResponseCauchy(Parameters& r
 //************************************************************************************
 //************************************************************************************
 
-void SmallStrainIsotropicDamage3D::CalculateStressResponse(
+void LinearIsotropicDamage3D::CalculateStressResponse(
     Parameters& rValues,
     double& rStrainVariable)
 {
@@ -257,7 +260,7 @@ void SmallStrainIsotropicDamage3D::CalculateStressResponse(
 //************************************************************************************
 //************************************************************************************
 
-double& SmallStrainIsotropicDamage3D::CalculateValue(
+double& LinearIsotropicDamage3D::CalculateValue(
     Parameters& rValues,
     const Variable<double>& rThisVariable,
     double& rValue
@@ -291,7 +294,7 @@ double& SmallStrainIsotropicDamage3D::CalculateValue(
 //************************************************************************************
 //************************************************************************************
 
-double SmallStrainIsotropicDamage3D::EvaluateHardeningLaw(
+double LinearIsotropicDamage3D::EvaluateHardeningLaw(
         double StrainVariable,
         const Properties &rMaterialProperties)
 {
@@ -305,7 +308,7 @@ double SmallStrainIsotropicDamage3D::EvaluateHardeningLaw(
     const double tolerance = std::numeric_limits<double>::epsilon();
 
     if (StrainVariable < strain_variable_init)
-        return strain_variable_init;
+        return StrainVariable;
     stress_variable = strain_variable_init + hardening_modulus * (StrainVariable - strain_variable_init);
     if ((hardening_modulus > tolerance && stress_variable > stress_variable_inf) ||
         (hardening_modulus < tolerance && stress_variable < stress_variable_inf))
@@ -316,7 +319,7 @@ double SmallStrainIsotropicDamage3D::EvaluateHardeningLaw(
 //************************************************************************************
 //************************************************************************************
 
-void SmallStrainIsotropicDamage3D::CalculateElasticMatrix(
+void LinearIsotropicDamage3D::CalculateElasticMatrix(
     const Properties &rMaterialProperties, Matrix &rElasticMatrix)
 {
     const double E = rMaterialProperties[YOUNG_MODULUS];
@@ -343,7 +346,7 @@ void SmallStrainIsotropicDamage3D::CalculateElasticMatrix(
 //************************************************************************************
 //************************************************************************************
 
-void SmallStrainIsotropicDamage3D::GetLawFeatures(Features& rFeatures)
+void LinearIsotropicDamage3D::GetLawFeatures(Features& rFeatures)
 {
     rFeatures.mOptions.Set(THREE_DIMENSIONAL_LAW);
     rFeatures.mOptions.Set(INFINITESIMAL_STRAINS);
@@ -356,7 +359,7 @@ void SmallStrainIsotropicDamage3D::GetLawFeatures(Features& rFeatures)
 //************************************************************************************
 //************************************************************************************
 
-int SmallStrainIsotropicDamage3D::Check(
+int LinearIsotropicDamage3D::Check(
     const Properties& rMaterialProperties,
     const GeometryType& rElementGeometry,
     const ProcessInfo& rCurrentProcessInfo
@@ -390,7 +393,7 @@ int SmallStrainIsotropicDamage3D::Check(
 //************************************************************************************
 //************************************************************************************
 
-void SmallStrainIsotropicDamage3D::save(Serializer& rSerializer) const
+void LinearIsotropicDamage3D::save(Serializer& rSerializer) const
 {
     KRATOS_SERIALIZE_SAVE_BASE_CLASS(rSerializer, ConstitutiveLaw);
     rSerializer.save("mInelasticFlag", mInelasticFlag);
@@ -400,7 +403,7 @@ void SmallStrainIsotropicDamage3D::save(Serializer& rSerializer) const
 //************************************************************************************
 //************************************************************************************
 
-void SmallStrainIsotropicDamage3D::load(Serializer& rSerializer)
+void LinearIsotropicDamage3D::load(Serializer& rSerializer)
 {
     KRATOS_SERIALIZE_LOAD_BASE_CLASS(rSerializer, ConstitutiveLaw);
     rSerializer.load("mInelasticFlag", mInelasticFlag);
diff --git a/applications/StructuralMechanicsApplication/custom_constitutive/small_strain_isotropic_damage_3d.h b/applications/StructuralMechanicsApplication/custom_constitutive/linear_isotropic_damage_3D_law.h
similarity index 97%
rename from applications/StructuralMechanicsApplication/custom_constitutive/small_strain_isotropic_damage_3d.h
rename to applications/StructuralMechanicsApplication/custom_constitutive/linear_isotropic_damage_3D_law.h
index e4548f88e0..993c93b60c 100644
--- a/applications/StructuralMechanicsApplication/custom_constitutive/small_strain_isotropic_damage_3d.h
+++ b/applications/StructuralMechanicsApplication/custom_constitutive/linear_isotropic_damage_3D_law.h
@@ -54,7 +54,7 @@ namespace Kratos
  * @note
  * @author Marcelo Raschi
  */
-class KRATOS_API(STRUCTURAL_MECHANICS_APPLICATION) SmallStrainIsotropicDamage3D
+class KRATOS_API(STRUCTURAL_MECHANICS_APPLICATION) LinearIsotropicDamage3D
     : public ConstitutiveLaw
 
 {
@@ -67,7 +67,7 @@ public:
     typedef std::size_t SizeType;
 
     // Counted pointer of LinearIsotropicDamage3DLaw
-    KRATOS_CLASS_POINTER_DEFINITION(SmallStrainIsotropicDamage3D);
+    KRATOS_CLASS_POINTER_DEFINITION(LinearIsotropicDamage3D);
 
     ///@}
     ///@name Lyfe Cycle
@@ -76,17 +76,17 @@ public:
     /**
      * @brief Default constructor.
      */
-    SmallStrainIsotropicDamage3D();
+    LinearIsotropicDamage3D();
 
     /**
      * @brief Default constructor.
      */
-    SmallStrainIsotropicDamage3D(const SmallStrainIsotropicDamage3D& rOther);
+    LinearIsotropicDamage3D(const LinearIsotropicDamage3D& rOther);
 
     /**
      * @brief Default constructor.
      */
-    ~SmallStrainIsotropicDamage3D() override;
+    ~LinearIsotropicDamage3D() override;
 
     /**
      * @brief Clone function
diff --git a/applications/StructuralMechanicsApplication/custom_constitutive/small_strain_isotropic_damage_plane_strain_2d.cpp b/applications/StructuralMechanicsApplication/custom_constitutive/linear_isotropic_damage_plane_strain_2d.cpp
similarity index 72%
rename from applications/StructuralMechanicsApplication/custom_constitutive/small_strain_isotropic_damage_plane_strain_2d.cpp
rename to applications/StructuralMechanicsApplication/custom_constitutive/linear_isotropic_damage_plane_strain_2d.cpp
index 69cf5a7b21..6bef62afba 100644
--- a/applications/StructuralMechanicsApplication/custom_constitutive/small_strain_isotropic_damage_plane_strain_2d.cpp
+++ b/applications/StructuralMechanicsApplication/custom_constitutive/linear_isotropic_damage_plane_strain_2d.cpp
@@ -1,100 +1,100 @@
-// KRATOS  ___|  |                   |                   |
-//       \___ \  __|  __| |   |  __| __| |   |  __| _` | |
-//             | |   |    |   | (    |   |   | |   (   | |
-//       _____/ \__|_|   \__,_|\___|\__|\__,_|_|  \__,_|_| MECHANICS
-//
-//  License:		 BSD License
-//					 license: structural_mechanics_application/license.txt
-//
-//  Main authors:    Marcelo Raschi
-
-#include "small_strain_isotropic_damage_plane_strain_2d.h"
-#include "structural_mechanics_application_variables.h"
-
-namespace Kratos
-{
-//******************************CONSTRUCTOR*******************************************
-//************************************************************************************
-
-SmallStrainIsotropicDamagePlaneStrain2D::SmallStrainIsotropicDamagePlaneStrain2D()
-    : SmallStrainIsotropicDamage3D()
-{
-}
-
-//********************************COPY CONSTRUCTOR************************************
-//************************************************************************************
-
-SmallStrainIsotropicDamagePlaneStrain2D::SmallStrainIsotropicDamagePlaneStrain2D(
-    const SmallStrainIsotropicDamagePlaneStrain2D &rOther) = default;
-
-//********************************CLONE***********************************************
-//************************************************************************************
-
-ConstitutiveLaw::Pointer SmallStrainIsotropicDamagePlaneStrain2D::Clone() const
-{
-    return Kratos::make_shared<SmallStrainIsotropicDamagePlaneStrain2D>(SmallStrainIsotropicDamagePlaneStrain2D(*this));
-}
-
-//********************************DESTRUCTOR******************************************
-//************************************************************************************
-
-SmallStrainIsotropicDamagePlaneStrain2D::~SmallStrainIsotropicDamagePlaneStrain2D() = default;
-
-//************************************************************************************
-//************************************************************************************
-
-void SmallStrainIsotropicDamagePlaneStrain2D::CalculateElasticMatrix(
-    const Properties &rMaterialProperties, Matrix &rElasticMatrix)
-{
-    const double E = rMaterialProperties[YOUNG_MODULUS];
-    const double nu = rMaterialProperties[POISSON_RATIO];
-    const double Ebar = E / (1. - nu * nu);
-    const double nubar = nu / (1. - nu);
-
-    if (rElasticMatrix.size1() != 3 || rElasticMatrix.size2() != 3)
-        rElasticMatrix.resize(3, 3, false);
-    rElasticMatrix.clear();
-
-    rElasticMatrix(0, 0) = 1;
-    rElasticMatrix(0, 1) = nubar;
-    rElasticMatrix(0, 2) = 0;
-    rElasticMatrix(1, 0) = nubar;
-    rElasticMatrix(1, 1) = 1;
-    rElasticMatrix(1, 2) = 0;
-    rElasticMatrix(2, 0) = 0;
-    rElasticMatrix(2, 1) = 0;
-    rElasticMatrix(2, 2) = 0.5 * (1 - nubar);
-
-    rElasticMatrix *= Ebar / (1. - nubar * nubar);
-}
-
-//************************************************************************************
-//************************************************************************************
-
-void SmallStrainIsotropicDamagePlaneStrain2D::GetLawFeatures(Features& rFeatures)
-{
-    rFeatures.mOptions.Set(PLANE_STRAIN_LAW);
-    rFeatures.mOptions.Set(INFINITESIMAL_STRAINS);
-    rFeatures.mOptions.Set(ISOTROPIC);
-    rFeatures.mStrainMeasures.push_back(StrainMeasure_Infinitesimal);
-    rFeatures.mStrainSize = this->WorkingSpaceDimension();
-    rFeatures.mSpaceDimension = this->GetStrainSize();
-}
-
-//************************************************************************************
-//************************************************************************************
-
-void SmallStrainIsotropicDamagePlaneStrain2D::save(Serializer& rSerializer) const
-{
-    KRATOS_SERIALIZE_SAVE_BASE_CLASS(rSerializer, SmallStrainIsotropicDamage3D);
-}
-
-//************************************************************************************
-//************************************************************************************
-
-void SmallStrainIsotropicDamagePlaneStrain2D::load(Serializer& rSerializer)
-{
-    KRATOS_SERIALIZE_LOAD_BASE_CLASS(rSerializer, SmallStrainIsotropicDamage3D);
-}
-
-} /* namespace Kratos.*/
+// KRATOS  ___|  |                   |                   |
+//       \___ \  __|  __| |   |  __| __| |   |  __| _` | |
+//             | |   |    |   | (    |   |   | |   (   | |
+//       _____/ \__|_|   \__,_|\___|\__|\__,_|_|  \__,_|_| MECHANICS
+//
+//  License:		 BSD License
+//					 license: structural_mechanics_application/license.txt
+//
+//  Main authors:    Marcelo Raschi
+
+#include "linear_isotropic_damage_plane_strain_2d.h"
+#include "structural_mechanics_application_variables.h"
+
+namespace Kratos
+{
+//******************************CONSTRUCTOR*******************************************
+//************************************************************************************
+
+LinearIsotropicDamagePlaneStrain2D::LinearIsotropicDamagePlaneStrain2D()
+    : LinearIsotropicDamage3D()
+{
+}
+
+//********************************COPY CONSTRUCTOR************************************
+//************************************************************************************
+
+LinearIsotropicDamagePlaneStrain2D::LinearIsotropicDamagePlaneStrain2D(
+    const LinearIsotropicDamagePlaneStrain2D &rOther) = default;
+
+//********************************CLONE***********************************************
+//************************************************************************************
+
+ConstitutiveLaw::Pointer LinearIsotropicDamagePlaneStrain2D::Clone() const
+{
+    return Kratos::make_shared<LinearIsotropicDamagePlaneStrain2D>(LinearIsotropicDamagePlaneStrain2D(*this));
+}
+
+//********************************DESTRUCTOR******************************************
+//************************************************************************************
+
+LinearIsotropicDamagePlaneStrain2D::~LinearIsotropicDamagePlaneStrain2D() = default;
+
+//************************************************************************************
+//************************************************************************************
+
+void LinearIsotropicDamagePlaneStrain2D::CalculateElasticMatrix(
+    const Properties &rMaterialProperties, Matrix &rElasticMatrix)
+{
+    const double E = rMaterialProperties[YOUNG_MODULUS];
+    const double nu = rMaterialProperties[POISSON_RATIO];
+    const double Ebar = E / (1. - nu * nu);
+    const double nubar = nu / (1. - nu);
+
+    if (rElasticMatrix.size1() != 3 || rElasticMatrix.size2() != 3)
+        rElasticMatrix.resize(3, 3, false);
+    rElasticMatrix.clear();
+
+    rElasticMatrix(0, 0) = 1;
+    rElasticMatrix(0, 1) = nubar;
+    rElasticMatrix(0, 2) = 0;
+    rElasticMatrix(1, 0) = nubar;
+    rElasticMatrix(1, 1) = 1;
+    rElasticMatrix(1, 2) = 0;
+    rElasticMatrix(2, 0) = 0;
+    rElasticMatrix(2, 1) = 0;
+    rElasticMatrix(2, 2) = 0.5 * (1 - nubar);
+
+    rElasticMatrix *= Ebar / (1. - nubar * nubar);
+}
+
+//************************************************************************************
+//************************************************************************************
+
+void LinearIsotropicDamagePlaneStrain2D::GetLawFeatures(Features& rFeatures)
+{
+    rFeatures.mOptions.Set(PLANE_STRAIN_LAW);
+    rFeatures.mOptions.Set(INFINITESIMAL_STRAINS);
+    rFeatures.mOptions.Set(ISOTROPIC);
+    rFeatures.mStrainMeasures.push_back(StrainMeasure_Infinitesimal);
+    rFeatures.mStrainSize = this->WorkingSpaceDimension();
+    rFeatures.mSpaceDimension = this->GetStrainSize();
+}
+
+//************************************************************************************
+//************************************************************************************
+
+void LinearIsotropicDamagePlaneStrain2D::save(Serializer& rSerializer) const
+{
+    KRATOS_SERIALIZE_SAVE_BASE_CLASS(rSerializer, LinearIsotropicDamage3D);
+}
+
+//************************************************************************************
+//************************************************************************************
+
+void LinearIsotropicDamagePlaneStrain2D::load(Serializer& rSerializer)
+{
+    KRATOS_SERIALIZE_LOAD_BASE_CLASS(rSerializer, LinearIsotropicDamage3D);
+}
+
+} /* namespace Kratos.*/
diff --git a/applications/StructuralMechanicsApplication/custom_constitutive/small_strain_isotropic_damage_plane_strain_2d.h b/applications/StructuralMechanicsApplication/custom_constitutive/linear_isotropic_damage_plane_strain_2d.h
similarity index 83%
rename from applications/StructuralMechanicsApplication/custom_constitutive/small_strain_isotropic_damage_plane_strain_2d.h
rename to applications/StructuralMechanicsApplication/custom_constitutive/linear_isotropic_damage_plane_strain_2d.h
index 9d3f0d9d09..2b816c6754 100644
--- a/applications/StructuralMechanicsApplication/custom_constitutive/small_strain_isotropic_damage_plane_strain_2d.h
+++ b/applications/StructuralMechanicsApplication/custom_constitutive/linear_isotropic_damage_plane_strain_2d.h
@@ -1,173 +1,173 @@
-// KRATOS  ___|  |                   |                   |
-//       \___ \  __|  __| |   |  __| __| |   |  __| _` | |
-//             | |   |    |   | (    |   |   | |   (   | |
-//       _____/ \__|_|   \__,_|\___|\__|\__,_|_|  \__,_|_| MECHANICS
-//
-//  License:		 BSD License
-//					 license: structural_mechanics_application/license.txt
-//
-//  Main authors:    Marcelo Raschi
-
-#if !defined(KRATOS_LINEAR_ISOTROPIC_DAMAGE_PLANE_STRAIN_2D_H_INCLUDED)
-#define KRATOS_LINEAR_ISOTROPIC_DAMAGE_PLANE_STRAIN_2D_H_INCLUDED
-
-// System includes
-
-// External includes
-
-// Project includes
-#include "small_strain_isotropic_damage_3d.h"
-
-namespace Kratos
-{
-///@name Kratos Globals
-///@{
-
-///@}
-///@name Type Definitions
-///@{
-
-///@}
-///@name  Enum's
-///@{
-
-///@}
-///@name  Functions
-///@{
-
-///@}
-///@name Kratos Classes
-///@{
-
-/**
- * @class LinearIsotropicDamagePlaneStrain2D
- * @ingroup StructuralMechanicsApplication
- * @brief Defines a damage with hardening/softening constitutive law in 2D (Plane Strain)
- * @details This material law is defined by the parameters:
- * - YOUNG_MODULUS
- * - POISSON_RATIO
- * - YIELD_STRESS
- * - INFINITY_YIELD_STRESS
- * - ISOTROPIC_HARDENING_MODULUS
- * @warning Valid for small strains
- * @note
- * @author Marcelo Raschi
- */
-class KRATOS_API(STRUCTURAL_MECHANICS_APPLICATION) SmallStrainIsotropicDamagePlaneStrain2D
-    : public SmallStrainIsotropicDamage3D
-
-{
-public:
-
-    ///@name Type Definitions
-    ///@{
-
-    typedef ProcessInfo ProcessInfoType;
-    typedef SmallStrainIsotropicDamage3D BaseType;
-    typedef std::size_t SizeType;
-
-    // Counted pointer of LinearIsotropicDamagePlaneStrain2DLaw
-    KRATOS_CLASS_POINTER_DEFINITION(SmallStrainIsotropicDamagePlaneStrain2D);
-
-    /**
-     * @brief Default constructor.
-     */
-    SmallStrainIsotropicDamagePlaneStrain2D();
-
-    /**
-     * @brief Copy constructor.
-     */
-    SmallStrainIsotropicDamagePlaneStrain2D(const SmallStrainIsotropicDamagePlaneStrain2D& rOther);
-
-    /**
-     * @brief Destructor.
-     */
-    ~SmallStrainIsotropicDamagePlaneStrain2D() override;
-
-    /**
-    * @brief Clone function
-    * @return a pointer to a new instance of this constitutive law
-    */
-    ConstitutiveLaw::Pointer Clone() const override;
-
-    /**
-     * @brief This function is designed to be called once to check compatibility with element
-     * @param rFeatures The Features of the law
-     */
-    void GetLawFeatures(Features& rFeatures) override;
-
-    /**
-     * @brief Dimension of the law:
-     */
-    SizeType WorkingSpaceDimension() override
-    {
-        return 2;
-    };
-
-    /**
-     * @brief Voigt tensor size:
-     */
-    SizeType GetStrainSize() override
-    {
-        return 3;
-    };
-
-    /// Print object's data.
-    void PrintData(std::ostream& rOStream) const override {
-        rOStream << "Linear Isotropic Damage Plane Strain 2D constitutive law\n";
-    };
-
-protected:
-    ///@name Protected static Member Variables
-    ///@{
-    ///@}
-
-    ///@name Protected member Variables
-    ///@{
-    ///@}
-
-    ///@name Protected Operators
-    ///@{
-    void CalculateElasticMatrix(const Properties &rMaterialProperties, Matrix &rElasticMatrix) override;
-    ///@}
-
-    ///@name Protected Operations
-    ///@{
-
-    ///@}
-
-private:
-    ///@name Static Member Variables
-    ///@{
-    ///@}
-
-    ///@name Member Variables
-    ///@{
-    ///@}
-
-    ///@name Private Operators
-    ///@{
-    ///@}
-
-    ///@name Private Operations
-    ///@{
-    ///@}
-
-    ///@name Private  Access
-    ///@{
-    ///@}
-
-    ///@name Serialization
-    ///@{
-
-    friend class Serializer;
-
-    void save(Serializer& rSerializer) const override;
-
-    void load(Serializer& rSerializer) override;
-
-    ///@}
-
-}; // class LinearIsotropicDamagePlaneStrain2DLaw
-} // namespace Kratos
-#endif
+// KRATOS  ___|  |                   |                   |
+//       \___ \  __|  __| |   |  __| __| |   |  __| _` | |
+//             | |   |    |   | (    |   |   | |   (   | |
+//       _____/ \__|_|   \__,_|\___|\__|\__,_|_|  \__,_|_| MECHANICS
+//
+//  License:		 BSD License
+//					 license: structural_mechanics_application/license.txt
+//
+//  Main authors:    Marcelo Raschi
+
+#if !defined(KRATOS_LINEAR_ISOTROPIC_DAMAGE_PLANE_STRAIN_2D_H_INCLUDED)
+#define KRATOS_LINEAR_ISOTROPIC_DAMAGE_PLANE_STRAIN_2D_H_INCLUDED
+
+// System includes
+
+// External includes
+
+// Project includes
+#include "linear_isotropic_damage_3D_law.h"
+
+namespace Kratos
+{
+///@name Kratos Globals
+///@{
+
+///@}
+///@name Type Definitions
+///@{
+
+///@}
+///@name  Enum's
+///@{
+
+///@}
+///@name  Functions
+///@{
+
+///@}
+///@name Kratos Classes
+///@{
+
+/**
+ * @class LinearIsotropicDamagePlaneStrain2D
+ * @ingroup StructuralMechanicsApplication
+ * @brief Defines a damage with hardening/softening constitutive law in 2D (Plane Strain)
+ * @details This material law is defined by the parameters:
+ * - YOUNG_MODULUS
+ * - POISSON_RATIO
+ * - YIELD_STRESS
+ * - INFINITY_YIELD_STRESS
+ * - ISOTROPIC_HARDENING_MODULUS
+ * @warning Valid for small strains
+ * @note
+ * @author Marcelo Raschi
+ */
+class KRATOS_API(STRUCTURAL_MECHANICS_APPLICATION) LinearIsotropicDamagePlaneStrain2D
+    : public LinearIsotropicDamage3D
+
+{
+public:
+
+    ///@name Type Definitions
+    ///@{
+
+    typedef ProcessInfo ProcessInfoType;
+    typedef LinearIsotropicDamage3D BaseType;
+    typedef std::size_t SizeType;
+
+    // Counted pointer of LinearIsotropicDamagePlaneStrain2DLaw
+    KRATOS_CLASS_POINTER_DEFINITION(LinearIsotropicDamagePlaneStrain2D);
+
+    /**
+     * @brief Default constructor.
+     */
+    LinearIsotropicDamagePlaneStrain2D();
+
+    /**
+     * @brief Copy constructor.
+     */
+    LinearIsotropicDamagePlaneStrain2D(const LinearIsotropicDamagePlaneStrain2D& rOther);
+
+    /**
+     * @brief Destructor.
+     */
+    ~LinearIsotropicDamagePlaneStrain2D() override;
+
+    /**
+    * @brief Clone function
+    * @return a pointer to a new instance of this constitutive law
+    */
+    ConstitutiveLaw::Pointer Clone() const override;
+
+    /**
+     * @brief This function is designed to be called once to check compatibility with element
+     * @param rFeatures The Features of the law
+     */
+    void GetLawFeatures(Features& rFeatures) override;
+
+    /**
+     * @brief Dimension of the law:
+     */
+    SizeType WorkingSpaceDimension() override
+    {
+        return 2;
+    };
+
+    /**
+     * @brief Voigt tensor size:
+     */
+    SizeType GetStrainSize() override
+    {
+        return 3;
+    };
+
+    /// Print object's data.
+    void PrintData(std::ostream& rOStream) const override {
+        rOStream << "Linear Isotropic Damage Plane Strain 2D constitutive law\n";
+    };
+
+protected:
+    ///@name Protected static Member Variables
+    ///@{
+    ///@}
+
+    ///@name Protected member Variables
+    ///@{
+    ///@}
+
+    ///@name Protected Operators
+    ///@{
+    void CalculateElasticMatrix(const Properties &rMaterialProperties, Matrix &rElasticMatrix) override;
+    ///@}
+
+    ///@name Protected Operations
+    ///@{
+
+    ///@}
+
+private:
+    ///@name Static Member Variables
+    ///@{
+    ///@}
+
+    ///@name Member Variables
+    ///@{
+    ///@}
+
+    ///@name Private Operators
+    ///@{
+    ///@}
+
+    ///@name Private Operations
+    ///@{
+    ///@}
+
+    ///@name Private  Access
+    ///@{
+    ///@}
+
+    ///@name Serialization
+    ///@{
+
+    friend class Serializer;
+
+    void save(Serializer& rSerializer) const override;
+
+    void load(Serializer& rSerializer) override;
+
+    ///@}
+
+}; // class LinearIsotropicDamagePlaneStrain2DLaw
+} // namespace Kratos
+#endif
diff --git a/applications/StructuralMechanicsApplication/custom_constitutive/linear_plane_stress.h b/applications/StructuralMechanicsApplication/custom_constitutive/linear_plane_stress.h
index 6116fc0568..57890a9c7a 100644
--- a/applications/StructuralMechanicsApplication/custom_constitutive/linear_plane_stress.h
+++ b/applications/StructuralMechanicsApplication/custom_constitutive/linear_plane_stress.h
@@ -61,10 +61,6 @@ public:
     
     /// The base class ElasticIsotropic3D type definition
     typedef ElasticIsotropic3D      BaseType;
-
-    // Adding the respective using to avoid overload conflicts
-    using BaseType::Has;
-    using BaseType::GetValue;
     
     /// The size type definition
     typedef std::size_t             SizeType;
diff --git a/applications/StructuralMechanicsApplication/custom_constitutive/plane_stress_d_plus_d_minus_damage_masonry_2d.cpp b/applications/StructuralMechanicsApplication/custom_constitutive/plane_stress_d_plus_d_minus_damage_masonry_2d.cpp
deleted file mode 100644
index 4cfe5dc4ca..0000000000
--- a/applications/StructuralMechanicsApplication/custom_constitutive/plane_stress_d_plus_d_minus_damage_masonry_2d.cpp
+++ /dev/null
@@ -1,724 +0,0 @@
-// KRATOS  ___|  |                   |                   |
-//       \___ \  __|  __| |   |  __| __| |   |  __| _` | |
-//             | |   |    |   | (    |   |   | |   (   | |
-//       _____/ \__|_|   \__,_|\___|\__|\__,_|_|  \__,_|_| MECHANICS
-//
-//  License:         BSD License
-//                   license: structural_mechanics_application/license.txt
-//
-//  Main authors:    Philip Kalkbrenner
-//                   Alejandro Cornejo 
-//  
-//
-
-// System includes
-
-// External includes
-
-// Project includes
-
-#include "includes/checks.h"
-#include "custom_utilities/tangent_operator_calculator_utility.h"
-#include "custom_utilities/constitutive_law_utilities.h"
-#include "structural_mechanics_application_variables.h"
-#include "custom_constitutive/plane_stress_d_plus_d_minus_damage_masonry_2d.h"
-
-namespace Kratos
-{
-
-DamageDPlusDMinusMasonry2DLaw::DamageDPlusDMinusMasonry2DLaw() {
-    
-}
-/***********************************************************************************/
-/***********************************************************************************/
-void DamageDPlusDMinusMasonry2DLaw::CalculateMaterialResponsePK2(ConstitutiveLaw::Parameters& rValues)
-{
-	this->CalculateMaterialResponseCauchy(rValues);
-}
-/***********************************************************************************/
-/***********************************************************************************/
-void DamageDPlusDMinusMasonry2DLaw::CalculateMaterialResponseKirchhoff(ConstitutiveLaw::Parameters& rValues)
-{
-	this->CalculateMaterialResponseCauchy(rValues);
-}
-/***********************************************************************************/
-/***********************************************************************************/
-void DamageDPlusDMinusMasonry2DLaw::CalculateMaterialResponsePK1(ConstitutiveLaw::Parameters& rValues)
-{
-	this->CalculateMaterialResponseCauchy(rValues);
-}
-/***********************************************************************************/
-/***********************************************************************************/
-void DamageDPlusDMinusMasonry2DLaw::CalculateMaterialResponseCauchy(ConstitutiveLaw::Parameters& rValues)
-{
-	KRATOS_TRY
-	
-	// Integrate Stress Damage
-    Vector& integrated_stress_vector = rValues.GetStressVector();
-    array_1d<double, VoigtSize> auxiliar_integrated_stress_vector = integrated_stress_vector;
-    Matrix& r_tangent_tensor = rValues.GetConstitutiveMatrix(); // todo modify after integration
-    const Flags& r_constitutive_law_options = rValues.GetOptions();
-	
-	// We get the strain vector
-    Vector& r_strain_vector = rValues.GetStrainVector();
-	
-	//NOTE: SINCE THE ELEMENT IS IN SMALL STRAINS WE CAN USE ANY STRAIN MEASURE. HERE EMPLOYING THE CAUCHY_GREEN
-    if( r_constitutive_law_options.IsNot( ConstitutiveLaw::USE_ELEMENT_PROVIDED_STRAIN )) {
-        this->CalculateValue(rValues, STRAIN, r_strain_vector);
-    }
-	
-	// Elastic Matrix
-    if( r_constitutive_law_options.Is( ConstitutiveLaw::COMPUTE_CONSTITUTIVE_TENSOR ) ) {
-        Matrix& r_constitutive_matrix = rValues.GetConstitutiveMatrix();
-        this->CalculateValue(rValues, CONSTITUTIVE_MATRIX, r_constitutive_matrix);
-    }
-
-    // We compute the stress
-    if (r_constitutive_law_options.Is(ConstitutiveLaw::COMPUTE_STRESS)) {
-        // Elastic Matrix
-        Matrix& r_constitutive_matrix = rValues.GetConstitutiveMatrix();
-        this->CalculateValue(rValues, CONSTITUTIVE_MATRIX, r_constitutive_matrix);
-
-        DamageParameters damage_parameters;
-        damage_parameters.ThresholdTension = this->GetTensionThreshold();
-        damage_parameters.DamageTension    = this->GetTensionDamage();
-        damage_parameters.ThresholdCompression = this->GetCompressionThreshold();
-        damage_parameters.DamageCompression    = this->GetCompressionDamage();
-
-        // S0 = C0:E
-        array_1d<double, VoigtSize> predictive_stress_vector = prod(r_constitutive_matrix, r_strain_vector);
-		
-		// Perform the separation of the Stress in tension and compression
-        array_1d<double, VoigtSize> predictive_stress_vector_tension, predictive_stress_vector_compression;
-	    ConstitutiveLawUtilities<VoigtSize>::SpectralDecomposition(predictive_stress_vector, predictive_stress_vector_tension, predictive_stress_vector_compression);
-		damage_parameters.TensionStressVector     = predictive_stress_vector_tension;
-        damage_parameters.CompressionStressVector = predictive_stress_vector_compression;
-		
-		// Compute the equivalent uniaxial Stress in tension and compression
-		this->CalculateEquivalentStressTension(predictive_stress_vector, damage_parameters.UniaxialTensionStress, rValues);	
-		this->CalculateEquivalentStressCompression(predictive_stress_vector, damage_parameters.UniaxialCompressionStress, rValues);
-		
-		const double F_tension = damage_parameters.UniaxialTensionStress - damage_parameters.ThresholdTension;
-        const double F_compression = damage_parameters.UniaxialCompressionStress - damage_parameters.ThresholdCompression;
-        const bool is_damaging_tension = this->IntegrateStressTensionIfNecessary(F_tension, damage_parameters, predictive_stress_vector_tension, predictive_stress_vector, rValues);
-		const bool is_damaging_compression = this->IntegrateStressCompressionIfNecessary(F_compression, damage_parameters, predictive_stress_vector_compression, predictive_stress_vector, rValues);
-		if (r_constitutive_law_options.Is(ConstitutiveLaw::COMPUTE_CONSTITUTIVE_TENSOR)) {
-            if (is_damaging_tension || is_damaging_compression) { // Perturbations
-                this->CalculateTangentTensor(rValues);
-            } else { // Secant matrix
-                this->CalculateSecantTensor(rValues, r_tangent_tensor);
-            }
-        }
-		this->CalculateIntegratedStressVector(integrated_stress_vector, damage_parameters, rValues);
-	}
-	KRATOS_CATCH("")
-}
-/***********************************************************************************/
-/***********************************************************************************/
-bool DamageDPlusDMinusMasonry2DLaw::IntegrateStressTensionIfNecessary(
-	const double F_tension,
-	DamageParameters& rParameters,
-	array_1d<double,3>& rIntegratedStressVectorTension,
-    array_1d<double,3> effective_stress_vector,
-	ConstitutiveLaw::Parameters& rValues)
-{
-	bool is_damaging = false;
-	const Flags& r_constitutive_law_options = rValues.GetOptions();
-	if (F_tension <= tolerance) { //Elastic Case
-		if (r_constitutive_law_options.Is( ConstitutiveLaw::COMPUTE_CONSTITUTIVE_TENSOR ) ) {
-            this->SetNonConvTensionDamage(rParameters.DamageTension);
-            this->SetNonConvTensionThreshold(rParameters.ThresholdTension);
-        }
-		rIntegratedStressVectorTension *= (1.0 - rParameters.DamageTension);
-	} else { // Increasing damage...
-        const double characteristic_length = ConstitutiveLawUtilities<3>::CalculateCharacteristicLengthOnReferenceConfiguration(rValues.GetElementGeometry());
-        // This routine updates the IntegratedStressVectorTension to verify the yield surf
-        this->IntegrateStressVectorTension(
-            rIntegratedStressVectorTension, 
-            rParameters.UniaxialTensionStress, 
-            rParameters.DamageTension, 
-            rParameters.ThresholdTension, 
-            rValues, characteristic_length);
-        if (r_constitutive_law_options.Is( ConstitutiveLaw::COMPUTE_CONSTITUTIVE_TENSOR)) {
-            this->SetNonConvTensionDamage(rParameters.DamageTension);
-            this->SetNonConvTensionThreshold(rParameters.UniaxialTensionStress);
-        }
-        is_damaging = true;
-    }
-    // Just for Plotting
-
-    double uniaxial_stress_tension = 0.0;
-    this->CalculateEquivalentStressTension(effective_stress_vector, uniaxial_stress_tension, rValues);
-    this->SetTensionStress(uniaxial_stress_tension);
-
-    return is_damaging;	
-}
-/***********************************************************************************/
-/***********************************************************************************/
-bool DamageDPlusDMinusMasonry2DLaw::IntegrateStressCompressionIfNecessary(
-	const double F_compression,
-	DamageParameters& rParameters,
-	array_1d<double,3>& rIntegratedStressVectorCompression,
-    array_1d<double,3> effective_stress_vector,
-	ConstitutiveLaw::Parameters& rValues)
-{
-	bool is_damaging = false;
-	const Flags& r_constitutive_law_options = rValues.GetOptions();
-    if (F_compression <= tolerance) { // Elastic case
-        if (r_constitutive_law_options.Is(ConstitutiveLaw::COMPUTE_CONSTITUTIVE_TENSOR)) {
-            this->SetNonConvCompressionDamage(rParameters.DamageCompression);
-            this->SetNonConvCompressionThreshold(rParameters.ThresholdCompression);
-        }
-        rIntegratedStressVectorCompression *= (1.0 - rParameters.DamageCompression);
-    } else { // Increasing damage...
-	    const double characteristic_length = ConstitutiveLawUtilities<3>::CalculateCharacteristicLengthOnReferenceConfiguration(rValues.GetElementGeometry());
-
-        // This routine updates the IntegratedStressVectorCompression to verify the yield surf
-        this->IntegrateStressVectorCompression(
-            rIntegratedStressVectorCompression, 
-            rParameters.UniaxialCompressionStress, 
-            rParameters.DamageCompression, 
-            rParameters.ThresholdCompression, 
-            rValues, characteristic_length);
-        if (r_constitutive_law_options.Is( ConstitutiveLaw::COMPUTE_CONSTITUTIVE_TENSOR ) ) {
-            this->SetNonConvCompressionDamage(rParameters.DamageCompression);
-            this->SetNonConvCompressionThreshold(rParameters.UniaxialCompressionStress);
-        }
-        is_damaging =  true;
-	}
-    // Just for Plotting
-    double uniaxial_stress_compression = 0.0;
-    this->CalculateEquivalentStressCompression(effective_stress_vector, uniaxial_stress_compression, rValues);
-    this->SetCompressionStress(uniaxial_stress_compression);
-    return is_damaging;
-}
-/***********************************************************************************/
-/***********************************************************************************/
-void DamageDPlusDMinusMasonry2DLaw::CalculateIntegratedStressVector(
-	Vector& rIntegratedStressVector,
-    const DamageParameters& rParameters,
-    ConstitutiveLaw::Parameters& rValues)
-{
-    rIntegratedStressVector = (1.0 - rParameters.DamageTension) * rParameters.TensionStressVector +
-                              (1.0 - rParameters.DamageCompression) * rParameters.CompressionStressVector;
-}
-/***********************************************************************************/
-/***********************************************************************************/
-void DamageDPlusDMinusMasonry2DLaw::CalculateTangentTensor(ConstitutiveLaw::Parameters& rValues)
-{
-    const Properties& r_material_properties = rValues.GetMaterialProperties();
-
-    const bool consider_perturbation_threshold = r_material_properties.Has(CONSIDER_PERTURBATION_THRESHOLD) ? r_material_properties[CONSIDER_PERTURBATION_THRESHOLD] : true;
-    const TangentOperatorEstimation tangent_operator_estimation = r_material_properties.Has(TANGENT_OPERATOR_ESTIMATION) ? static_cast<TangentOperatorEstimation>(r_material_properties[TANGENT_OPERATOR_ESTIMATION]) : TangentOperatorEstimation::SecondOrderPerturbation;
-
-    if (tangent_operator_estimation == TangentOperatorEstimation::Analytic) {
-        KRATOS_ERROR << "Analytic solution not available" << std::endl;
-    } else if (tangent_operator_estimation == TangentOperatorEstimation::FirstOrderPerturbation) {
-        // Calculates the Tangent Constitutive Tensor by perturbation (first order)
-        TangentOperatorCalculatorUtility::CalculateTangentTensor(rValues, this, ConstitutiveLaw::StressMeasure_Cauchy, consider_perturbation_threshold, 1);
-    } else if (tangent_operator_estimation == TangentOperatorEstimation::SecondOrderPerturbation) {
-        // Calculates the Tangent Constitutive Tensor by perturbation (second order)
-        TangentOperatorCalculatorUtility::CalculateTangentTensor(rValues, this, ConstitutiveLaw::StressMeasure_Cauchy, consider_perturbation_threshold, 2);
-    }
-}
-/***********************************************************************************/
-/***********************************************************************************/
-void DamageDPlusDMinusMasonry2DLaw::CalculateSecantTensor(ConstitutiveLaw::Parameters& rValues, Matrix& rSecantTensor)
-{
-    this->CalculateValue(rValues, CONSTITUTIVE_MATRIX, rSecantTensor);
-}
-/***********************************************************************************/
-/***********************************************************************************/
-void DamageDPlusDMinusMasonry2DLaw::InitializeMaterial(
-        const Properties& rMaterialProperties,
-        const GeometryType& rElementGeometry,
-        const Vector& rShapeFunctionsValues)
-{
-    // We construct the CL parameters
-    double initial_threshold_tension = rMaterialProperties[YIELD_STRESS_TENSION];
-	double initial_threshold_compression = rMaterialProperties[DAMAGE_ONSET_STRESS_COMPRESSION];
-	
-    this->SetTensionThreshold(initial_threshold_tension);
-    this->SetCompressionThreshold(initial_threshold_compression);
-}
-/***********************************************************************************/
-/***********************************************************************************/
-void DamageDPlusDMinusMasonry2DLaw::FinalizeSolutionStep(
-    const Properties& rMaterialProperties,
-    const GeometryType &rElementGeometry,
-    const Vector& rShapeFunctionsValues,
-    const ProcessInfo& rCurrentProcessInfo
-    )
-{
-    this->SetTensionDamage(this->GetNonConvTensionDamage());
-    this->SetTensionThreshold(this->GetNonConvTensionThreshold());
-
-    this->SetCompressionDamage(this->GetNonConvCompressionDamage());
-    this->SetCompressionThreshold(this->GetNonConvCompressionThreshold());
-}
-/***********************************************************************************/
-/***********************************************************************************/
-void DamageDPlusDMinusMasonry2DLaw::FinalizeMaterialResponsePK1(ConstitutiveLaw::Parameters& rValues)
-{
-}
-/***********************************************************************************/
-/***********************************************************************************/
-void DamageDPlusDMinusMasonry2DLaw::FinalizeMaterialResponsePK2(ConstitutiveLaw::Parameters& rValues)
-{
-}
-/***********************************************************************************/
-/***********************************************************************************/
-void DamageDPlusDMinusMasonry2DLaw::FinalizeMaterialResponseKirchhoff(ConstitutiveLaw::Parameters& rValues)
-{
-}
-
-/***********************************************************************************/
-/***********************************************************************************/
-void DamageDPlusDMinusMasonry2DLaw::FinalizeMaterialResponseCauchy(ConstitutiveLaw::Parameters& rValues)
-{
-}
-/***********************************************************************************/
-/***********************************************************************************/
-bool DamageDPlusDMinusMasonry2DLaw::Has(const Variable<double>& rThisVariable)
-{
-    if (rThisVariable == DAMAGE_TENSION) {
-        return true;
-    } else if (rThisVariable == THRESHOLD_TENSION) {
-        return true;
-    } else if (rThisVariable == DAMAGE_COMPRESSION) {
-		return true;
-    } else if (rThisVariable == THRESHOLD_COMPRESSION) {
-		return true;
-    } else if (rThisVariable == UNIAXIAL_STRESS_COMPRESSION) {
-		return true; 
-    } else if (rThisVariable == UNIAXIAL_STRESS_TENSION) {
-		return true; 
-    } else {
-        return BaseType::Has(rThisVariable);
-    }
-    return false;
-}
-/***********************************************************************************/
-/***********************************************************************************/
-bool DamageDPlusDMinusMasonry2DLaw::Has(const Variable<Vector>& rThisVariable)
-{
-    return BaseType::Has(rThisVariable);
-}
-/***********************************************************************************/
-/***********************************************************************************/
-bool DamageDPlusDMinusMasonry2DLaw::Has(const Variable<Matrix>& rThisVariable)
-{
-    return BaseType::Has(rThisVariable);
-}
-/***********************************************************************************/
-/***********************************************************************************/
-void DamageDPlusDMinusMasonry2DLaw::SetValue(
-    const Variable<double>& rThisVariable,
-    const double& rValue,
-    const ProcessInfo& rCurrentProcessInfo
-    )
-{
-    if (rThisVariable == DAMAGE_TENSION) {
-       mTensionDamage = rValue;
-    } else if (rThisVariable == THRESHOLD_TENSION) {
-       mTensionThreshold = rValue;
-    } else if (rThisVariable == DAMAGE_COMPRESSION) {
-       mCompressionDamage = rValue;
-    } else if (rThisVariable == THRESHOLD_COMPRESSION) {
-       mCompressionThreshold = rValue;
-    } else if (rThisVariable == UNIAXIAL_STRESS_COMPRESSION) {
-       mCompressionUniaxialStress = rValue; 
-    } else if (rThisVariable == UNIAXIAL_STRESS_TENSION) {
-       mTensionUniaxialStress = rValue; 
-    } else {
-       return BaseType::SetValue(rThisVariable, rValue, rCurrentProcessInfo);
-    }
-}
-/***********************************************************************************/
-/***********************************************************************************/
-double& DamageDPlusDMinusMasonry2DLaw::GetValue(
-    const Variable<double>& rThisVariable,
-    double& rValue
-    )
-{
-    if (rThisVariable == DAMAGE_TENSION) {
-       rValue = mTensionDamage;
-    } else if (rThisVariable == THRESHOLD_TENSION) {
-       rValue = mTensionThreshold;
-    } else if (rThisVariable == DAMAGE_COMPRESSION) {
-       rValue = mCompressionDamage;
-    } else if (rThisVariable == THRESHOLD_COMPRESSION) {
-       rValue = mCompressionThreshold;
-    } else if (rThisVariable == UNIAXIAL_STRESS_COMPRESSION) {
-       rValue = mCompressionUniaxialStress;
-    } else if (rThisVariable == UNIAXIAL_STRESS_TENSION) {
-       rValue = mTensionUniaxialStress;
-    } else {
-       return BaseType::GetValue(rThisVariable, rValue);
-    }
-    return rValue;
-}
-/***********************************************************************************/
-/***********************************************************************************/
-Vector& DamageDPlusDMinusMasonry2DLaw::GetValue(
-    const Variable<Vector>& rThisVariable,
-    Vector& rValue
-    )
-{
-    return BaseType::GetValue(rThisVariable, rValue);
-}
-/***********************************************************************************/
-/***********************************************************************************/
-Matrix& DamageDPlusDMinusMasonry2DLaw::GetValue(
-    const Variable<Matrix>& rThisVariable,
-    Matrix& rValue
-    )
-{
-    return BaseType::GetValue(rThisVariable, rValue);
-}
-/***********************************************************************************/
-/***********************************************************************************/
-double& DamageDPlusDMinusMasonry2DLaw::CalculateValue(
-    ConstitutiveLaw::Parameters& rParameterValues,
-    const Variable<double>& rThisVariable,
-    double& rValue
-    )
-{
-    return this->GetValue(rThisVariable, rValue);
-}
-/***********************************************************************************/
-/***********************************************************************************/
-Vector& DamageDPlusDMinusMasonry2DLaw::CalculateValue(
-    ConstitutiveLaw::Parameters& rParameterValues,
-    const Variable<Vector>& rThisVariable,
-    Vector& rValue
-    )
-{
-    return BaseType::CalculateValue(rParameterValues, rThisVariable, rValue);
-}
-/***********************************************************************************/
-/***********************************************************************************/
-Matrix& DamageDPlusDMinusMasonry2DLaw::CalculateValue(
-    ConstitutiveLaw::Parameters& rParameterValues,
-    const Variable<Matrix>& rThisVariable,
-    Matrix& rValue
-    )
-{
-    if (rThisVariable == INTEGRATED_STRESS_TENSOR) {
-        //1.-Compute total deformation gradient
-        const Matrix& deformation_gradient_F = rParameterValues.GetDeformationGradientF();
-        //2.-Right Cauchy-Green tensor C
-        Matrix right_cauchy_green = prod(trans(deformation_gradient_F), deformation_gradient_F);
-        Vector strain_vector = ZeroVector(6);
-
-        //E= 0.5*(FT*F-1) or E = 0.5*(C-1)
-        strain_vector[0] = 0.5 * (right_cauchy_green(0, 0) - 1.00);
-        strain_vector[1] = 0.5 * (right_cauchy_green(1, 1) - 1.00);
-        strain_vector[2] = 0.5 * (right_cauchy_green(2, 2) - 1.00);
-        strain_vector[3] = right_cauchy_green(0, 1); // xy
-        strain_vector[4] = right_cauchy_green(1, 2); // yz
-        strain_vector[5] = right_cauchy_green(0, 2); // xz
-
-        Matrix constitutive_matrix;
-        this->CalculateElasticMatrix(constitutive_matrix, rParameterValues);
-
-        Vector stress = prod(constitutive_matrix, strain_vector);
-        //stress *= (1.0 - mDamage);
-        rValue =  MathUtils<double>::StressVectorToTensor(stress);
-        return rValue;
-    } else if (this->Has(rThisVariable)) {
-        return this->GetValue(rThisVariable, rValue);
-    } else {
-        return BaseType::CalculateValue(rParameterValues, rThisVariable, rValue);
-    }
-    return rValue;
-}
-/***********************************************************************************/
-/***********************************************************************************/
-int DamageDPlusDMinusMasonry2DLaw::Check(
-    const Properties& rMaterialProperties,
-    const GeometryType& rElementGeometry,
-    const ProcessInfo& rCurrentProcessInfo
-    )
-{
-    const int check_base = BaseType::Check(rMaterialProperties, rElementGeometry, rCurrentProcessInfo);
-	
-	KRATOS_CHECK_VARIABLE_KEY(YOUNG_MODULUS);
-	KRATOS_CHECK_VARIABLE_KEY(POISSON_RATIO);
-	KRATOS_CHECK_VARIABLE_KEY(YIELD_STRESS_TENSION);
-	KRATOS_CHECK_VARIABLE_KEY(FRACTURE_ENERGY_TENSION);
-	KRATOS_CHECK_VARIABLE_KEY(DAMAGE_ONSET_STRESS_COMPRESSION);
-	KRATOS_CHECK_VARIABLE_KEY(YIELD_STRESS_COMPRESSION);
-	KRATOS_CHECK_VARIABLE_KEY(YIELD_STRAIN_COMPRESSION);
-	KRATOS_CHECK_VARIABLE_KEY(RESIDUAL_STRESS_COMPRESSION);
-	KRATOS_CHECK_VARIABLE_KEY(FRACTURE_ENERGY_COMPRESSION);
-	KRATOS_CHECK_VARIABLE_KEY(BIAXIAL_COMPRESSION_MULTIPLIER);
-	KRATOS_CHECK_VARIABLE_KEY(BEZIER_CONTROLLER_C1);
-	KRATOS_CHECK_VARIABLE_KEY(BEZIER_CONTROLLER_C2);
-	KRATOS_CHECK_VARIABLE_KEY(BEZIER_CONTROLLER_C3);
-
-    if (check_base > 0) return 1;
-    return 0;
-}
-/***********************************************************************************/
-/***********************************************************************************/
-
-
-/***********************************************************************************/
-/***********************************************************************************/
-void DamageDPlusDMinusMasonry2DLaw::CalculateEquivalentStressTension(
-	array_1d<double, 3>& rPredictiveStressVector, 
-	double& rEquivalentStress,
-	ConstitutiveLaw::Parameters& rValues
-	)
-{
-	const Properties& r_material_properties = rValues.GetMaterialProperties();
-	
-	const double yield_tension = r_material_properties[YIELD_STRESS_TENSION];
-	const double yield_compression = r_material_properties[YIELD_STRESS_COMPRESSION];
-	const double biaxial_compression_multiplier = r_material_properties[BIAXIAL_COMPRESSION_MULTIPLIER];
-	const double alpha = (biaxial_compression_multiplier - 1.0)/(2 * biaxial_compression_multiplier - 1.0);
-	const double alpha_factor = 1.0 / (1.0 - alpha);
-	const double beta = (yield_compression / yield_tension) * (1.0 - alpha) - (1.0 + alpha);
-	
-	double I1,J2;
-	ConstitutiveLawUtilities<3>::CalculateI1Invariant(rPredictiveStressVector, I1);
-	array_1d<double, 3> deviator = ZeroVector(3);
-	ConstitutiveLawUtilities<3>::CalculateJ2Invariant(rPredictiveStressVector, I1, deviator, J2);
-	
-	array_1d<double, 2> rPrincipalStressVector;
-	ConstitutiveLawUtilities<3>::CalculatePrincipalStresses(rPrincipalStressVector, rPredictiveStressVector);
-	const double principal_stress_1 = rPrincipalStressVector[0];
-	
-	if (principal_stress_1 > 0.0){
-		rEquivalentStress = alpha_factor * (alpha*I1 + std::sqrt(3.0 * J2) + beta * principal_stress_1) * (yield_tension / yield_compression);
-	}	
-}
-/***********************************************************************************/
-/***********************************************************************************/
-void DamageDPlusDMinusMasonry2DLaw::CalculateEquivalentStressCompression(
-	array_1d<double, 3>& rPredictiveStressVector, 
-	double& rEquivalentStress,
-	ConstitutiveLaw::Parameters& rValues
-	)
-{
-	const Properties& r_material_properties = rValues.GetMaterialProperties();
-	
-	const double yield_tension = r_material_properties[YIELD_STRESS_TENSION];
-	const double yield_compression = r_material_properties[YIELD_STRESS_COMPRESSION];
-	const double biaxial_compression_multiplier = r_material_properties[BIAXIAL_COMPRESSION_MULTIPLIER];
-	const double shear_compression_reductor = r_material_properties[SHEAR_COMPRESSION_REDUCTOR];
-	
-    KRATOS_ERROR_IF(shear_compression_reductor < 0.0)<< "The SHEAR_COMPRESSION_REDUCTOR is supposed to be a value between 0.0 and 1.0" << std::endl;
-	KRATOS_ERROR_IF(shear_compression_reductor > 1.0)<< "The SHEAR_COMPRESSION_REDUCTOR is supposed to be a value between 0.0 and 1.0" << std::endl;
-	
-	const double alpha = (biaxial_compression_multiplier - 1.0)/(2.0* biaxial_compression_multiplier - 1.0);
-	const double alpha_factor = 1.0 / (1.0 - alpha);
-	const double beta = (yield_compression / yield_tension) * (1.0 - alpha) - (1.0 + alpha);
-	
-	double I1,J2;
-	ConstitutiveLawUtilities<3>::CalculateI1Invariant(rPredictiveStressVector, I1);
-	array_1d<double, 3> deviator = ZeroVector(VoigtSize);
-	ConstitutiveLawUtilities<3>::CalculateJ2Invariant(rPredictiveStressVector, I1, deviator, J2);
-	
-	array_1d<double, 2> rPrincipalStressVector;
-	ConstitutiveLawUtilities<3>::CalculatePrincipalStresses(rPrincipalStressVector, rPredictiveStressVector);
-	const double principal_stress_1 = rPrincipalStressVector[0];
-	const double principal_stress_2 = rPrincipalStressVector[1];
-	const double smax_macaulay = std::max(principal_stress_1, 0.0);
-	if (principal_stress_2 < 0.0){
-		rEquivalentStress = alpha_factor * (alpha*I1 + std::sqrt(3.0 * J2) + beta * shear_compression_reductor * smax_macaulay);
-	}
-}
-/***********************************************************************************/
-/***********************************************************************************/
-void DamageDPlusDMinusMasonry2DLaw::IntegrateStressVectorTension(
-	array_1d<double,3>& rPredictiveStressVector,
-    const double UniaxialStress,
-    double& rDamage,
-    double& rThreshold,
-    ConstitutiveLaw::Parameters& rValues,
-    const double CharacteristicLength)
-{
-	double damage_parameter;
-	this->CalculateDamageParameterTension(rValues, damage_parameter, CharacteristicLength);
-	this->CalculateExponentialDamageTension(UniaxialStress, rThreshold, damage_parameter, CharacteristicLength, rValues, rDamage);
-	
-	rPredictiveStressVector *= (1.0 - rDamage);
-}
-/***********************************************************************************/
-/***********************************************************************************/		
-void DamageDPlusDMinusMasonry2DLaw::CalculateDamageParameterTension(
-	ConstitutiveLaw::Parameters& rValues,
-    double& rAParameter,
-    const double CharacteristicLength)
-{
-	const Properties& r_material_properties = rValues.GetMaterialProperties();
-	
-	const double Gf = r_material_properties[FRACTURE_ENERGY_TENSION];
-	const double E = r_material_properties[YOUNG_MODULUS];
-	const double yield_tension = r_material_properties[YIELD_STRESS_TENSION];
-	const double l_mat = 2.0 * E * Gf / (std::pow(yield_tension, 2));
-	rAParameter = 2.0 * (CharacteristicLength / (l_mat - CharacteristicLength));
-	KRATOS_ERROR_IF(CharacteristicLength >= l_mat) << "FRACTURE_ENERGY_TENSION is too low:  2*E*Gt/(ft*ft) = " << l_mat
-					<< ",   Characteristic Length = " << CharacteristicLength << std::endl;
-}
-/***********************************************************************************/
-/***********************************************************************************/
-void DamageDPlusDMinusMasonry2DLaw::CalculateExponentialDamageTension(
-	const double UniaxialStress,
-	const double Threshold,
-	const double DamageParameter,
-	const double CharacteristicLength,
-	ConstitutiveLaw::Parameters& rValues,
-	double& rDamage)
-{
-	const Properties& r_material_properties = rValues.GetMaterialProperties();
-	const double initial_threshold = r_material_properties[YIELD_STRESS_TENSION];
-	rDamage = 1.0 - (initial_threshold / UniaxialStress) * std::exp(DamageParameter * (1.0 - (UniaxialStress / initial_threshold)));
-}
-
-/***********************************************************************************/
-/***********************************************************************************/
-void DamageDPlusDMinusMasonry2DLaw::IntegrateStressVectorCompression(
-	array_1d<double,3>& rPredictiveStressVector,
-	const double UniaxialStress,
-    double& rDamage,
-    double& rThreshold,
-    ConstitutiveLaw::Parameters& rValues,
-    const double CharacteristicLength)
-{
-	this->CalculateBezier3DamageCompression(UniaxialStress, rDamage, rThreshold, CharacteristicLength, rValues);
-	rPredictiveStressVector *= (1.0 - rDamage);
-}
-/***********************************************************************************/
-/***********************************************************************************/
-
-/***********************************************************************************/
-/***********************************************************************************/
-void DamageDPlusDMinusMasonry2DLaw::CalculateBezier3DamageCompression(
-	const double UniaxialStress,
-	double& rDamage,
-	double& rThreshold,
-	const double CharacteristicLength,
-	ConstitutiveLaw::Parameters& rValues)
-{
-	// Call the Material Properties 
-	const Properties& r_material_properties = rValues.GetMaterialProperties();
-	const double young_modulus = r_material_properties[YOUNG_MODULUS]; 
-	const double stress_damage_onset = r_material_properties[DAMAGE_ONSET_STRESS_COMPRESSION];
-	const double yield_stress_compression = r_material_properties[YIELD_STRESS_COMPRESSION];
-	const double yield_strain_compression = r_material_properties[YIELD_STRAIN_COMPRESSION];
-	const double residual_stress_compression = r_material_properties[RESIDUAL_STRESS_COMPRESSION];
-	const double bezier_controller_c1 = r_material_properties[BEZIER_CONTROLLER_C1];
-	const double bezier_controller_c2 = r_material_properties[BEZIER_CONTROLLER_C2];
-	const double bezier_controller_c3 = r_material_properties[BEZIER_CONTROLLER_C3];
-	const double fracture_energy_compression = r_material_properties[FRACTURE_ENERGY_COMPRESSION];
-	
-	// Calculate missing Bezier Determinators
-	const double bezier_control_alpha = 2.0 * (yield_strain_compression - (yield_stress_compression / young_modulus));
-	const double strain_damage_onset = stress_damage_onset / young_modulus;
-	const double bezier_control_strain_i = yield_stress_compression / young_modulus;
-	const double bezier_control_stress_k = residual_stress_compression + 
-                 (yield_stress_compression - residual_stress_compression) * bezier_controller_c1;
-	double bezier_control_strain_j = yield_strain_compression + bezier_control_alpha * bezier_controller_c2;
-	
-	double bezier_control_strain_k = 3.0 * yield_strain_compression - 2.0 * yield_stress_compression / young_modulus;
-	double bezier_control_strain_r = ( (bezier_control_strain_k - bezier_control_strain_j) * 
-           (yield_stress_compression - residual_stress_compression)/(yield_stress_compression - bezier_control_stress_k) ) 
-           + bezier_control_strain_j;
-	double bezier_control_strain_u = bezier_control_strain_r * bezier_controller_c3;
-	const double specific_fracture_energy_compression = fracture_energy_compression / CharacteristicLength;
-	
-	// Perform the Energy Regularization of the Bezier Determinators
-	//double gc_bezier; 
-	this->RegulateBezierDeterminators(
-        specific_fracture_energy_compression, 
-        yield_stress_compression, bezier_control_stress_k, residual_stress_compression, yield_strain_compression, 
-        bezier_control_strain_j, bezier_control_strain_k, bezier_control_strain_r, bezier_control_strain_u);
-	
-	// Compute rDamage
-	const double strain_like_counterpart = UniaxialStress / young_modulus;
-	double damage_variable_bezier = UniaxialStress;
-	
-	if (strain_like_counterpart <= yield_strain_compression) {
-		damage_variable_bezier = this->EvaluateBezierCurve(
-            strain_like_counterpart, 
-            strain_damage_onset, bezier_control_strain_i, yield_strain_compression, 
-            stress_damage_onset, yield_stress_compression, yield_stress_compression);
-	} else if (strain_like_counterpart <= bezier_control_strain_k) {
-		damage_variable_bezier = this->EvaluateBezierCurve(
-            strain_like_counterpart, 
-            yield_strain_compression, bezier_control_strain_j, bezier_control_strain_k, 
-            yield_stress_compression, yield_stress_compression, bezier_control_stress_k);
-	} else if (strain_like_counterpart <= bezier_control_strain_u) {
-		damage_variable_bezier = this->EvaluateBezierCurve(
-            strain_like_counterpart, 
-            bezier_control_strain_k, bezier_control_strain_r, bezier_control_strain_u, 
-            bezier_control_stress_k, residual_stress_compression, residual_stress_compression);
-	} else {
-		damage_variable_bezier = residual_stress_compression;
-	}
-		   
-	rDamage = 1.0 - damage_variable_bezier / UniaxialStress;
-}
-/***********************************************************************************/
-/***********************************************************************************/
-void DamageDPlusDMinusMasonry2DLaw::RegulateBezierDeterminators(
-	const double specific_dissipated_fracture_energy,
-	const double sp, const double sk, const double sr, const double ep,
-	double& ej, double& ek, double& er, double& eu)
-{	
-	const double bezier_energy_1 = sp * ep / 2.0;
-	double bezier_energy_2;
-	double bezier_energy_3;
-	this->ComputeBezierEnergy(bezier_energy_2, ep, ej, ek, sp, sp, sk);
-	this->ComputeBezierEnergy(bezier_energy_3, ek, er, eu, sk, sr, sr);
-	const double BezierEnergy = bezier_energy_1 + bezier_energy_2 + bezier_energy_3;
-	
-	const double bezier_stretcher = ((specific_dissipated_fracture_energy - bezier_energy_1) / 
-								   (BezierEnergy - bezier_energy_1)) - 1.0;
-
-	KRATOS_ERROR_IF(bezier_stretcher <= -1.0) << "Error in Compression Damage: FRACTURE_ENERGY_COMPRESSION is too low, increase it to avoid constitutive snap-back!" << std::endl;
-								   
-    // Update Strain values
-	ej += bezier_stretcher * (ej - ep);
-	ek += bezier_stretcher * (ek - ep);
-	er += bezier_stretcher * (er - ep);
-	eu += bezier_stretcher * (eu - ep);
-}
-/***********************************************************************************/
-/***********************************************************************************/
-void DamageDPlusDMinusMasonry2DLaw::ComputeBezierEnergy(
-	double& rBezier_energy,
-	const double x1, const double x2, const double x3,
-	const double y1, const double y2, const double y3)
-{  
-	rBezier_energy = (x2*y1/3.0) + (x3*y1/6.0) - (x2*y3/3) + (x3*y2/3) + (x3*y3/2.0) - x1*((y1/2.0) + (y2/3.0) + (y3/6.0));
-}
-/***********************************************************************************/
-/***********************************************************************************/
-double DamageDPlusDMinusMasonry2DLaw::EvaluateBezierCurve(
-    const double Xi, 
-    const double x1, double x2, const double x3, 
-    const double y1, const double y2, const double y3)
-{
-    double A = x1 - 2.0 * x2 + x3;
-    double B = 2.0 * (x2 - x1);
-    double C = x1 - Xi;
-    if (std::abs(A) < 1.0e-12) {
-        x2 = x2 + 1.0E-6 * (x3-x1);
-        A =  x1 - 2.0 * x2 + x3;
-        B = 2.0 * (x2 - x1);
-        C = x1 - Xi;
-    }
-    const double D = B * B - 4.0 * A * C;
-    const double t = (-B + std::sqrt(D)) / (2.0 * A);
-    const double bezier_damage_parameter =  (y1 - 2.0 * y2 + y3) * t * t + (y2 - y1) * 2.0 * t + y1;
-    return bezier_damage_parameter;
-}
-
-/***********************************************************************************/
-/***********************************************************************************/
-
-}// namespace Kratos
\ No newline at end of file
diff --git a/applications/StructuralMechanicsApplication/custom_constitutive/plane_stress_d_plus_d_minus_damage_masonry_2d.h b/applications/StructuralMechanicsApplication/custom_constitutive/plane_stress_d_plus_d_minus_damage_masonry_2d.h
deleted file mode 100644
index 5da45bbc89..0000000000
--- a/applications/StructuralMechanicsApplication/custom_constitutive/plane_stress_d_plus_d_minus_damage_masonry_2d.h
+++ /dev/null
@@ -1,720 +0,0 @@
-// KRATOS  ___|  |                   |                   |
-//       \___ \  __|  __| |   |  __| __| |   |  __| _` | |
-//             | |   |    |   | (    |   |   | |   (   | |
-//       _____/ \__|_|   \__,_|\___|\__|\__,_|_|  \__,_|_| MECHANICS
-//
-//  License:         BSD License
-//                   license: structural_mechanics_application/license.txt
-//
-//  Main authors:    Philip Kalkbrenner
-//                   Alejandro Cornejo 
-//  
-//
-#if !defined(KRATOS_PLANE_STRESS_D_PLUS_D_MINUS_DAMAGE_MASONRY_2D_H_INCLUDED)
-#define KRATOS_PLANE_STRESS_D_PLUS_D_MINUS_DAMAGE_MASONRY_2D_H_INCLUDED
-
-// System includes
-
-// External includes
-
-// Project includes
-#include "custom_constitutive/linear_plane_stress.h"
-
-namespace Kratos
-{
-///@name Kratos Globals
-///@{
-
-///@}
-///@name Type Definitions
-///@{
-
-    // The size type definition
-    typedef std::size_t SizeType;
-
-    
-///@}
-///@name  Enum's
-///@{
-
-///@}
-///@name  Functions
-///@{
-
-///@}
-///@name Kratos Classes
-///@{
-/**
- * @class DamageDPlusDMinusMasonry2DLaw 
- * @ingroup StructuralMechanicsApplication
- */
- class KRATOS_API(STRUCTURAL_MECHANICS_APPLICATION) DamageDPlusDMinusMasonry2DLaw 
-    : public LinearPlaneStress
-{
-public:
-    ///@name Type Definitions
-    ///@{
-
-
-    /// The define the working dimension size, already defined in the integrator
-    static constexpr SizeType Dimension = 2;
-
-    /// The define the Voigt size, already defined in the  integrator
-    static constexpr SizeType VoigtSize = 3;
-    
-    /// Definition of the base class
-    typedef LinearPlaneStress BaseType;
-
-    // Adding the respective using to avoid overload conflicts
-    using BaseType::Has;
-    using BaseType::GetValue;
-
-    /// Counted pointer of GenericYieldSurface
-    KRATOS_CLASS_POINTER_DEFINITION(DamageDPlusDMinusMasonry2DLaw);
-
-    /// The node definition
-    typedef Node<3> NodeType;
-
-    /// The geometry definition
-    typedef Geometry<NodeType> GeometryType;
-	
-    /// Definition of the machine precision tolerance
-    static constexpr double tolerance = std::numeric_limits<double>::epsilon();
-
-	struct DamageParameters {
-		double DamageTension = 0.0;
-		double DamageCompression = 0.0;
-		double ThresholdTension = 0.0;
-		double ThresholdCompression = 0.0;
-		array_1d<double, VoigtSize> TensionStressVector;
-		array_1d<double, VoigtSize> CompressionStressVector;
-        double UniaxialTensionStress = 0.0;
-        double UniaxialCompressionStress = 0.0;
-	};
-    ///@}
-    ///@name Life Cycle
-    ///@{
-	
-	/**
-    * Default constructor.
-    */
-    DamageDPlusDMinusMasonry2DLaw();
-	
-
-    /**
-    * Clone.
-    */
-    ConstitutiveLaw::Pointer Clone() const override
-	{
-        return Kratos::make_shared<DamageDPlusDMinusMasonry2DLaw>(*this);
-    }
-    /**
-     * @brief Dimension of the law:
-     */
-    SizeType WorkingSpaceDimension() override 
-    {
-        return Dimension;
-    };
-
-    /**
-     * @brief Voigt tensor size:
-     */
-    SizeType GetStrainSize() override 
-    {
-        return VoigtSize;
-    };
-	
-    /**
-    * Copy constructor.
-    */
-    DamageDPlusDMinusMasonry2DLaw(const DamageDPlusDMinusMasonry2DLaw &rOther)
-        : BaseType(rOther),
-          mTensionDamage(rOther.mTensionDamage),
-          mTensionThreshold(rOther.mTensionThreshold),
-          mNonConvTensionDamage(rOther.mNonConvTensionDamage),
-          mNonConvTensionThreshold(rOther.mNonConvTensionThreshold),
-          mCompressionDamage(rOther.mCompressionDamage),
-          mCompressionThreshold(rOther.mCompressionThreshold),
-          mNonConvCompressionDamage(rOther.mNonConvCompressionDamage),
-          mNonConvCompressionThreshold(rOther.mNonConvCompressionThreshold)
-    {
-    }
-	
-    /**
-    * Destructor.
-    */
-    ~DamageDPlusDMinusMasonry2DLaw() override
-    {
-    }
-
-   /**
-     * @brief Computes the material response in terms of 1st Piola-Kirchhoff stresses and constitutive tensor
-     * @see Parameters
-     */
-    void CalculateMaterialResponsePK1(ConstitutiveLaw::Parameters &rValues) override;
-
-    /**
-     * @brief Computes the material response in terms of 2nd Piola-Kirchhoff stresses and constitutive tensor
-     * @see Parameters
-     */
-    void CalculateMaterialResponsePK2(ConstitutiveLaw::Parameters &rValues) override;
-
-    /**
-     * @brief Computes the material response in terms of Kirchhoff stresses and constitutive tensor
-     * @see Parameters
-     */
-    void CalculateMaterialResponseKirchhoff(ConstitutiveLaw::Parameters &rValues) override;
-
-    /**
-     * @brief Computes the material response in terms of Cauchy stresses and constitutive tensor
-     * @see Parameters
-     */
-    void CalculateMaterialResponseCauchy(ConstitutiveLaw::Parameters &rValues) override;
-
-    /**
-     * @brief Integrates the predictive tension stress vector if necessary
-     * @param F_compression = uniaxial_stress_tension - threshold
-     */
-    bool IntegrateStressTensionIfNecessary(
-        const double F_tension, 
-        DamageParameters& Parameters, 
-        array_1d<double, VoigtSize>& IntegratedStressVectorTension,
-        const array_1d<double,3> rIntegratedStressVector,
-        ConstitutiveLaw::Parameters& rValues
-        );
-
-    /**
-     * @brief Integrates the predictive tension stress vector if necessary
-     * @param F_compression = uniaxial_stress_compression - threshold
-     */
-    bool IntegrateStressCompressionIfNecessary(
-        const double F_compression, 
-        DamageParameters& Parameters,
-        array_1d<double, VoigtSize>& IntegratedStressVectorCompression,
-        array_1d<double, VoigtSize> rIntegratedStressVector,
-        ConstitutiveLaw::Parameters& rValues
-        );
-
-    /**
-     * @brief Computes the inetgarted stress vector S = A:D0:A:E
-     */
-    void CalculateIntegratedStressVector(
-        Vector& IntegratedStressVectorTension,
-        const DamageParameters& Parameters,
-        ConstitutiveLaw::Parameters& rValues
-        );
-
-    /**
-     * @brief This is to be called at the very beginning of the calculation
-     * @details (e.g. from InitializeElement) in order to initialize all relevant attributes of the constitutive law
-     * @param rMaterialProperties the Properties instance of the current element
-     * @param rElementGeometry the geometry of the current element
-     * @param rShapeFunctionsValues the shape functions values in the current integration point
-     */
-    void InitializeMaterial(
-        const Properties& rMaterialProperties,
-        const GeometryType& rElementGeometry,
-        const Vector& rShapeFunctionsValues
-        ) override;
-
-    /**
-     * @brief To be called at the end of each solution step
-     * @details (e.g. from Element::FinalizeSolutionStep)
-     * @param rMaterialProperties the Properties instance of the current element
-     * @param rElementGeometry the geometry of the current element
-     * @param rShapeFunctionsValues the shape functions values in the current integration point
-     * @param rCurrentProcessInfo the current ProcessInfo instance
-     */
-    void FinalizeSolutionStep(
-        const Properties &rMaterialProperties,
-        const GeometryType &rElementGeometry,
-        const Vector& rShapeFunctionsValues,
-        const ProcessInfo& rCurrentProcessInfo
-        ) override;
-
-    /**
-     * @brief Finalize the material response in terms of 1st Piola-Kirchhoff stresses
-     * @see Parameters
-     */
-    void FinalizeMaterialResponsePK1(ConstitutiveLaw::Parameters &rValues) override;
-
-    /**
-     * @brief Finalize the material response in terms of 2nd Piola-Kirchhoff stresses
-     * @see Parameters
-     */
-    void FinalizeMaterialResponsePK2(ConstitutiveLaw::Parameters &rValues) override;
-
-    /**
-     * @brief Finalize the material response in terms of Kirchhoff stresses
-     * @see Parameters
-     */
-    void FinalizeMaterialResponseKirchhoff(ConstitutiveLaw::Parameters &rValues) override;
-    /**
-     * Finalize the material response in terms of Cauchy stresses
-     * @see Parameters
-     */
-    void FinalizeMaterialResponseCauchy(ConstitutiveLaw::Parameters &rValues) override;
-
-    /**
-     * @brief Returns whether this constitutive Law has specified variable (double)
-     * @param rThisVariable the variable to be checked for
-     * @return true if the variable is defined in the constitutive law
-     */
-    bool Has(const Variable<double> &rThisVariable) override;
-
-    /**
-     * @brief Returns whether this constitutive Law has specified variable (Vector)
-     * @param rThisVariable the variable to be checked for
-     * @return true if the variable is defined in the constitutive law
-     */
-    bool Has(const Variable<Vector> &rThisVariable) override;
-    
-    /**
-     * @brief Returns whether this constitutive Law has specified variable (Matrix)
-     * @param rThisVariable the variable to be checked for
-     * @return true if the variable is defined in the constitutive law
-     */
-    bool Has(const Variable<Matrix> &rThisVariable) override;
-
-    /**
-     * @brief Sets the value of a specified variable (double)
-     * @param rVariable the variable to be returned
-     * @param rValue new value of the specified variable
-     * @param rCurrentProcessInfo the process info
-     */
-    void SetValue(
-        const Variable<double> &rThisVariable,
-        const double& rValue,
-        const ProcessInfo& rCurrentProcessInfo
-        ) override;
-
-    /**
-     * @brief Returns the value of a specified variable (double)
-     * @param rThisVariable the variable to be returned
-     * @param rValue a reference to the returned value
-     * @return rValue output: the value of the specified variable
-     */
-    double& GetValue(
-        const Variable<double> &rThisVariable,
-        double& rValue
-        ) override;
-
-    /**
-     * @brief Returns the value of a specified variable (Vector)
-     * @param rThisVariable the variable to be returned
-     * @param rValue a reference to the returned value
-     * @return rValue output: the value of the specified variable
-     */
-    Vector& GetValue(
-        const Variable<Vector> &rThisVariable,
-        Vector& rValue
-        ) override;
-
-    /**
-     * @brief Returns the value of a specified variable (matrix)
-     * @param rThisVariable the variable to be returned
-     * @param rValue a reference to the returned value
-     * @return rValue output: the value of the specified variable
-     */
-    Matrix& GetValue(
-        const Variable<Matrix>& rThisVariable,
-        Matrix& rValue
-        ) override;
-
-    /**
-     * @brief Returns the value of a specified variable (double)
-     * @param rParameterValues the needed parameters for the CL calculation
-     * @param rThisVariable the variable to be returned
-     * @param rValue a reference to the returned value
-     * @param rValue output: the value of the specified variable
-     */
-    double& CalculateValue(
-        ConstitutiveLaw::Parameters& rParameterValues,
-        const Variable<double>& rThisVariable,
-        double& rValue) override;
-
-    /**
-     * @brief Returns the value of a specified variable (vector)
-     * @param rParameterValues the needed parameters for the CL calculation
-     * @param rThisVariable the variable to be returned
-     * @param rValue a reference to the returned value
-     * @param rValue output: the value of the specified variable
-     */
-    Vector& CalculateValue(
-        ConstitutiveLaw::Parameters& rParameterValues,
-        const Variable<Vector>& rThisVariable,
-        Vector& rValue
-        ) override;
-        
-    /**
-     * @brief Returns the value of a specified variable (matrix)
-     * @param rParameterValues the needed parameters for the CL calculation
-     * @param rThisVariable the variable to be returned
-     * @param rValue a reference to the returned value
-     * @param rValue output: the value of the specified variable
-     */
-    Matrix& CalculateValue(
-        ConstitutiveLaw::Parameters& rParameterValues,
-        const Variable<Matrix>& rThisVariable,
-        Matrix& rValue
-        ) override;
-
-    /**
-     * @brief This function provides the place to perform checks on the completeness of the input.
-     * @details It is designed to be called only once (or anyway, not often) typically at the beginning
-     * of the calculations, so to verify that nothing is missing from the input or that no common error is found.
-     * @param rMaterialProperties The properties of the material
-     * @param rElementGeometry The geometry of the element
-     * @param rCurrentProcessInfo The current process info instance
-     * @return 0 if OK, 1 otherwise
-     */
-    int Check(
-        const Properties& rMaterialProperties,
-        const GeometryType& rElementGeometry,
-        const ProcessInfo& rCurrentProcessInfo
-        ) override;
-
-    ///@}
-    ///@name Access
-    ///@{
-
-    ///@}
-    ///@name Inquiry
-    ///@{
-
-    ///@}
-    ///@name Input and output
-    ///@{
-
-    ///@}
-    ///@name Friends
-    ///@{
-
-    ///@}
-
-protected:
-    ///@name Protected static Member Variables
-    ///@{
-
-    ///@}
-    ///@name Protected member Variables
-    ///@{
-
-    ///@}
-    ///@name Protected Operators
-    ///@{
-
-    ///@}
-    ///@name Protected Operations
-    ///@{
-    // Tension values
-    double& GetTensionThreshold() { return mTensionThreshold; }
-    double& GetTensionDamage() { return mTensionDamage; }
-    double& GetNonConvTensionThreshold() { return mNonConvTensionThreshold; }
-    double& GetNonConvTensionDamage() { return mNonConvTensionDamage; }
-
-    void SetTensionThreshold(const double toThreshold) { mTensionThreshold = toThreshold; }
-    void SetTensionDamage(const double toDamage) { mTensionDamage = toDamage; }
-    void SetNonConvTensionThreshold(const double toThreshold) { mNonConvTensionThreshold = toThreshold; }
-    void SetNonConvTensionDamage(const double toDamage) { mNonConvTensionDamage = toDamage; }
-
-    // Compression values
-    double& GetCompressionThreshold() { return mCompressionThreshold; }
-    double& GetCompressionDamage() { return mCompressionDamage; }
-    double& GetNonConvCompressionThreshold() { return mNonConvCompressionThreshold; }
-    double& GetNonConvCompressionDamage() { return mNonConvCompressionDamage; }
-
-    void SetCompressionThreshold(const double toThreshold) { mCompressionThreshold = toThreshold; }
-    void SetCompressionDamage(const double toDamage) { mCompressionDamage = toDamage; }
-    void SetNonConvCompressionThreshold(const double toThreshold) { mNonConvCompressionThreshold = toThreshold; }
-    void SetNonConvCompressionDamage(const double toDamage) { mNonConvCompressionDamage = toDamage; }
-
-    void SetTensionStress(const double toS){mTensionUniaxialStress = toS;}
-    void SetCompressionStress(const double toS){mCompressionUniaxialStress = toS;}
-
-    ///@}
-    ///@name Protected  Access
-    ///@{
-
-    ///@}
-    ///@name Protected Inquiry
-    ///@{
-
-    ///@}
-    ///@name Protected LifeCycle
-    ///@{
-
-    ///@}
-
-private:
-   ///@name Static Member Variables
-    ///@{
-
-    ///@}
-    ///@name Member Variables
-    ///@{
-
-    // Converged values
-    double mTensionDamage = 0.0;
-    double mTensionThreshold = 0.0;
-
-    // Non Converged values
-    double mNonConvTensionDamage = 0.0;
-    double mNonConvTensionThreshold = 0.0;
-
-    double mCompressionDamage = 0.0;
-    double mCompressionThreshold = 0.0;
-
-    // Non Converged values
-    double mNonConvCompressionDamage = 0.0;
-    double mNonConvCompressionThreshold = 0.0;
-
-    double mTensionUniaxialStress = 0.0;
-    double mCompressionUniaxialStress = 0.0;
-    ///@}
-    ///@name Private Operators
-    ///@{
-
-    ///@}
-    ///@name Private Operations
-    ///@{
-
-    /**
-     * @brief This method computes the tangent tensor
-     * @param rValues The constitutive law parameters and flags
-     */
-    void CalculateTangentTensor(ConstitutiveLaw::Parameters &rValues);
-
-    /**
-     * @brief This method computes the secant tensor
-     * @param rValues The constitutive law parameters and flags
-     */
-    void CalculateSecantTensor(ConstitutiveLaw::Parameters& rValues, Matrix& rSecantTensor);
-	
-
-	// Serialization
-
-    friend class Serializer;
-
-    void save(Serializer &rSerializer) const override
-    {
-        KRATOS_SERIALIZE_SAVE_BASE_CLASS(rSerializer, ConstitutiveLaw)
-        rSerializer.save("TensionDamage", mTensionDamage);
-        rSerializer.save("TensionThreshold", mTensionThreshold);
-        rSerializer.save("NonConvTensionDamage", mNonConvTensionDamage);
-        rSerializer.save("NonConvTensionThreshold", mNonConvTensionThreshold);
-        rSerializer.save("CompressionDamage", mCompressionDamage);
-        rSerializer.save("CompressionThreshold", mCompressionThreshold);
-        rSerializer.save("NonConvCompressionnDamage", mNonConvCompressionDamage);
-        rSerializer.save("NonConvCompressionThreshold", mNonConvCompressionThreshold);
-    }
-
-    void load(Serializer &rSerializer) override
-    {
-        KRATOS_SERIALIZE_LOAD_BASE_CLASS(rSerializer, ConstitutiveLaw)
-        rSerializer.load("TensionDamage", mTensionDamage);
-        rSerializer.load("TensionThreshold", mTensionThreshold);
-        rSerializer.load("NonConvTensionDamage", mNonConvTensionDamage);
-        rSerializer.load("NonConvTensionThreshold", mNonConvTensionThreshold);
-        rSerializer.load("CompressionDamage", mCompressionDamage);
-        rSerializer.load("CompressionThreshold", mCompressionThreshold);
-        rSerializer.load("NonConvCompressionnDamage", mNonConvCompressionDamage);
-        rSerializer.load("NonConvCompressionThreshold", mNonConvCompressionThreshold);
-    }
-
-	/**
-	 * @brief This method computes the equivalent stress in Tension
-	 * @param rValues The constitutive law parameters and flags
-	 * 		  rPredictiveStressVector Predictive or effective Stress Vector
-	 *        rEquivalentStress The equivalent Stress to be filled by method
-	 */
-	void CalculateEquivalentStressTension(
-	array_1d<double, 3>& rPredictiveStressVector, 
-	double& rEquivalentStress,
-	ConstitutiveLaw::Parameters& rValues);
-	
-	/**
-	 * @brief This method computes the equivalent stress in Compression
-	 * @param rValues The constitutive law parameters and flags
-	 * 		  rPredictiveStressVector Predictive or effective Stress Vector
-	 *        rEquivalentStress The equivalent Stress to be filled by method
-	 */
-	void CalculateEquivalentStressCompression(
-	array_1d<double, 3>& rPredictiveStressVector, 
-	double& rEquivalentStress,
-	ConstitutiveLaw::Parameters& rValues);
-
-	/**
-	 * @brief This method computes the final stress vector in Tension
-	 * @param rValues The constitutive law parameters and flags
-	 * 		  rPredictiveStressVector Tension Part of the predictive or effective stress vector
-	 *        UniaxialStress The equivalent uniaxial stress in Tension
-	 *        rDamage The damage variable in Tension
-	 *		  rThreshold The Damage Threshold in Tension
-	 *		  CharacteristicLength The finite element charecteristic length
-	 */
-	void IntegrateStressVectorTension(
-	array_1d<double,3>& rPredictiveStressVector,
-    const double UniaxialStress,
-    double& rDamage,
-    double& rThreshold,
-    ConstitutiveLaw::Parameters& rValues,
-    const double CharacteristicLength);
-
-	/** 
-	 *  @brief This method computes the damage parameter for the exponential softening behavior in tension
-	 *  @params rValues The constitutive law parameters and flags
-	 *          rAParameter The damage parameter filled by method
-	 *          CharacteristicLength The finite element charecteristic length
-	 */
-	void CalculateDamageParameterTension(
-	ConstitutiveLaw::Parameters& rValues,
-    double& rAParameter,
-    const double CharacteristicLength);
-
-	/**
-	 * @brief This method computes the tension damage variable for the exponential softening law in tension
-	 * @params rValues The constitutive law parameters and flags
-	 * 		   UniaxialStress The equivalent uniaxial stress in Tension
-	 *         Threshold The damage threshold in Tension
-	 *         DamageParameter The damage parameter for the exponential softening law
-	 *         CharacteristicLength The finite element charecteristic length
-	 *         rDamage The tension damage variable filled by the method
-	 */
-
-	void CalculateExponentialDamageTension(
-	const double UniaxialStress,
-	const double Threshold,
-	const double DamageParameter,
-	const double CharacteristicLength,
-	ConstitutiveLaw::Parameters& rValues,
-	double& rDamage);
-	
-	/**
-	 * @brief This method computes the final stress vector in Tension
-	 * @param rValues The constitutive law parameters and flags
-	 * 		  rPredictiveStressVector Compression Part of the predictive or effective stress vector
-	 *        UniaxialStress The equivalent uniaxial stress in Compression
-	 *        rDamage The damage variable in Compression
-	 *		  rThreshold The Damage Threshold in Compression
-	 *		  CharacteristicLength The finite element charecteristic length
-	 */
-	void IntegrateStressVectorCompression(
-	array_1d<double,3>& rPredictiveStressVector,
-	const double UniaxialStress,
-    double& rDamage,
-    double& rThreshold,
-    ConstitutiveLaw::Parameters& rValues,
-    const double CharacteristicLength);
-	
-	
-    /**
-     *  BRIEF DOCUMENTATION OF THE USED UNIAXIAL SOFTENING BEHAVIOR IN COMPRESSION 
-     *  Entire documentation can be found in the the Phd Thesis of Massimo Petracca
-     *  << Computational Multiscale Analysis of Masonry Structures>>
-     *
-     *  UNIAXIAL BEZIER COMPRESSION DAMAGE
-     *  {I}   Linear Elastic 
-     *  {II}  Hardening Quadratic Bezier Curve 
-     *          Control nodes:  0=(e_0,s_0); I=(e_i,s_p); P=(e_p,s_p) 
-     *  {III} Softening Quadratic Bezier Curve 
-     *          Control nodes:  P=(e_p,s_p); J=(e_j,s_j); K=(e_k,s_k)
-     *  {IV}  Softening Quadratic Bezier Curve 
-     *          Control nodes:  K=(e_k,s_k); R=(e_r,s_r); U=(e_u,s_u)
-     *  {V}   Residual Strength
-     *
-     *    STRESS                 
-     *       ^
-     *      /|\
-     *       |                     (P)
-     * s_p = |------------(I)+----#####--+(J) 
-     * s_i = |               ' ###  ' ####
-     * s_j   |              ###     '    ####
-     *       |            ###'      '    ' ###
-     * s_k   |-----------##--+------+----+--## (K)
-     * s_0   |---------##(0) '      '    '   ### 
-     *       |        ## '   '      '    '    '##
-     *       |       ##  '   '      '    '    '   ####
-     *       |      ##   '   '      '    '    '      #####
-     *       |     ##    '   '      '    '    '          #####
-     *       |    ##     '   '      '    '    '    (R)       ######## (U)
-     * s_r = |---##------+---+------'----+----+-----+-----------------######################
-     * s_u   |  ##       '   '      '    '    '     '                 '                                    
-     *       |_##________+___+______+____+____+_____+_________________+______________________________\
-     *                  e_0 e_i    e_p  e_j  e_k   e_r               e_u                             / STRAIN
-     *        '          '          '         '                       '
-     *        '   {I}    '   {II}   '  {III}  '        {IV}           '          {V}         
-     *        '          '          '         '                       '
-     *
-     */
-
-    /**
-	 * @brief This method computes the Damage Variable in Compression by considering three Bezier curves (hardening + softening + softening + residual)
-	 * @param rValues The constitutive law parameters and flags
-	 *        UniaxialStress The equivalent uniaxial stress in Compression
-	 *        rDamage The damage variable in Compression
-	 *		  rThreshold The Damage Threshold in Compression
-	 *        CharacteristicLength The finite element charecteristic length
-	 */
-
-	void CalculateBezier3DamageCompression(
-	const double UniaxialStress,
-	double& rDamage,
-	double& rThreshold,
-	const double CharacteristicLength,
-	ConstitutiveLaw::Parameters& rValues);
-	
-	/**
-	 * @brief This method regulates the four bezier control strains to avoid a constitutive snap-back (fracture energy considerations)
-	 * @param specific_dissipated_fracture_energy FRACTURE_ENERGY_CMOPRESSION devided by CharacteristicLength
-	 *        sp, sk, sr stress Values to control the bezier curves
-	 *        ep strain pproperty to control the bezier curve
-     *        ej, ek, er, eu strain properties to be regulated in method
-	 */
-	void RegulateBezierDeterminators(
-	const double specific_dissipated_fracture_energy,
-	const double sp, const double sk, const double sr, const double ep,
-	double& ej, double& ek, double& er, double& eu);
-	
-	/**
-	 * @brief This method computes the area beneath the parts of the bezier curves, respectively
-     * @param BezierG Area beneath the curve, to be filled by method
-	 *        x1, x2, x3, y1, y2, y3 coordinates of the control points of the bezier
-	 */
-	void ComputeBezierEnergy(
-	double& BezierG,
-	const double x1, const double x2, const double x3,
-	const double y1, const double y2, const double y3);
-
-    /**
-     * @brief This method returns the bezier damage parameter  
-     * @param Xi Strain-like counterpart of the uniaxial compression stress
-     *        x1, x2, x3 Necesarry Stress values to define the uniaxial compression damage bezier curve
-     *        y1, y2, y3 Necesarry Strain vlaues to define the uniaxial compression damage bezier curve
-     */
-    double EvaluateBezierCurve(
-    const double Xi, 
-    const double x1, double x2, const double x3, 
-    const double y1, const double y2, const double y3);
-
-
-    ///@}
-    ///@name Private  Access
-    ///@{
-
-    ///@}
-    ///@name Private Inquiry
-    ///@{
-
-    ///@}
-    ///@name Un accessible methods
-    ///@{
-
-    
-
-    ///@}
-
-}; // Class DamageDPlusDMinusMasonry2DLaw  
-}// namespace Kratos
-#endif
-
diff --git a/applications/StructuralMechanicsApplication/custom_constitutive/truss_constitutive_law.cpp b/applications/StructuralMechanicsApplication/custom_constitutive/truss_constitutive_law.cpp
index e3edb3272b..70e8e22284 100644
--- a/applications/StructuralMechanicsApplication/custom_constitutive/truss_constitutive_law.cpp
+++ b/applications/StructuralMechanicsApplication/custom_constitutive/truss_constitutive_law.cpp
@@ -141,7 +141,7 @@ void TrussConstitutiveLaw::CalculateMaterialResponse(
     const double axial_strain = rStrainVector[0];
     const double youngs_modulus = rMaterialProperties[YOUNG_MODULUS];
 
-    if (rStressVector.size() != 1) rStressVector.resize(1, false);
+    if (rStressVector.size() != 1) rStressVector.resize(1);
     rStressVector[0] = youngs_modulus*axial_strain;
 }
 
diff --git a/applications/StructuralMechanicsApplication/custom_constitutive/truss_plasticity_constitutive_law.cpp b/applications/StructuralMechanicsApplication/custom_constitutive/truss_plasticity_constitutive_law.cpp
index eca80e968c..ea1a588850 100644
--- a/applications/StructuralMechanicsApplication/custom_constitutive/truss_plasticity_constitutive_law.cpp
+++ b/applications/StructuralMechanicsApplication/custom_constitutive/truss_plasticity_constitutive_law.cpp
@@ -72,7 +72,7 @@ bool& TrussPlasticityConstitutiveLaw::GetValue(
     bool& rValue
     )
 {
-    if(rThisVariable == INELASTIC_FLAG) rValue = this->mCurrentInElasticFlag;
+    if(rThisVariable == INELASTIC_FLAG) rValue = this->mInElasticFlagVector[0];
     else KRATOS_ERROR << "Can't get the specified value" << std::endl;
     return rValue;
 }
@@ -123,7 +123,7 @@ void TrussPlasticityConstitutiveLaw::SetValue(const Variable<bool>& rThisVariabl
                           const bool& rValue,
                           const ProcessInfo& rCurrentProcessInfo)
 {
-    if(rThisVariable == INELASTIC_FLAG) this->mCurrentInElasticFlag = rValue;
+    if(rThisVariable == INELASTIC_FLAG) this->mInElasticFlagVector[0] = rValue;
     else KRATOS_ERROR << "Can't set the specified value" << std::endl;
 }
 
@@ -143,7 +143,7 @@ double& TrussPlasticityConstitutiveLaw::CalculateValue(
         const Properties& r_material_properties = rParameterValues.GetMaterialProperties();
         const double hardening_modulus = r_material_properties[HARDENING_MODULUS_1D];
         const double youngs_modulus = r_material_properties[YOUNG_MODULUS];
-        if (this->mCurrentInElasticFlag)
+        if (this->mInElasticFlagVector[0])
         {
             KRATOS_DEBUG_ERROR_IF((hardening_modulus+youngs_modulus)<numerical_limit)
              << "Dividing by 0 when calculating the plastic tangent modulus" << std::endl;
@@ -172,7 +172,7 @@ Vector& TrussPlasticityConstitutiveLaw::CalculateValue(
         double current_stress = this->mStressState;
 
 
-        if (this->mCurrentInElasticFlag)
+        if (this->mInElasticFlagVector[0])
         {
             const double hardening_modulus = r_material_properties[HARDENING_MODULUS_1D];
             const double youngs_modulus = r_material_properties[YOUNG_MODULUS];
@@ -235,13 +235,13 @@ void TrussPlasticityConstitutiveLaw::CalculateMaterialResponse(
     const double elastic_trial_strain = axial_strain-current_plastic_strain;
     const double youngs_modulus = rMaterialProperties[YOUNG_MODULUS];
 
-    if (rStressVector.size() != 1) rStressVector.resize(1, false);
+    if (rStressVector.size() != 1) rStressVector.resize(1);
     rStressVector[0] = youngs_modulus*elastic_trial_strain;
 
     if (SaveInternalVariables)
     {
         this->mStressState = rStressVector[0];
-        this->mCurrentInElasticFlag = this->CheckIfIsPlasticRegime(rMaterialProperties,rStressVector[0]);
+        this->mInElasticFlagVector[0] = this->CheckIfIsPlasticRegime(rMaterialProperties,rStressVector[0]);
 
         if (this->CheckPlasticIterationHistory())
         {
@@ -320,7 +320,7 @@ void TrussPlasticityConstitutiveLaw::FinalizeNonLinearIteration(const Properties
                     const Vector& rShapeFunctionsValues,
                     const ProcessInfo& rCurrentProcessInfo)
 {
-    this->mPreviousInElasticFlag = this->mCurrentInElasticFlag;
+    this->mInElasticFlagVector[1] = this->mInElasticFlagVector[0];
 }
 
 void TrussPlasticityConstitutiveLaw::FinalizeSolutionStep(const Properties& rMaterialProperties,
@@ -330,8 +330,8 @@ void TrussPlasticityConstitutiveLaw::FinalizeSolutionStep(const Properties& rMat
 {
     this->mAccumulatedPlasticStrainVector[1] = this->mAccumulatedPlasticStrainVector[0];
     this->mPlasticAlphaVector[1] = this->mPlasticAlphaVector[0];
-    this->mCurrentInElasticFlag = false;
-    this->mPreviousInElasticFlag = false;
+    this->mInElasticFlagVector[0] = false;
+    this->mInElasticFlagVector[1] = false;
 }
 
 } // Namespace Kratos
diff --git a/applications/StructuralMechanicsApplication/custom_constitutive/truss_plasticity_constitutive_law.h b/applications/StructuralMechanicsApplication/custom_constitutive/truss_plasticity_constitutive_law.h
index fa91c634d0..b0ac0c8ada 100644
--- a/applications/StructuralMechanicsApplication/custom_constitutive/truss_plasticity_constitutive_law.h
+++ b/applications/StructuralMechanicsApplication/custom_constitutive/truss_plasticity_constitutive_law.h
@@ -157,7 +157,7 @@ public:
     bool CheckPlasticIterationHistory() const
     {
         bool check_flag = false;
-        if(this->mPreviousInElasticFlag && !this->mCurrentInElasticFlag)
+        if(this->mInElasticFlagVector[1] && !this->mInElasticFlagVector[0])
         {
             check_flag = true;
         }
@@ -215,13 +215,10 @@ private:
     ///@{
     double mStressState = 0.0; // The current stress state
 
-    //the following members are
-    //mCurrentInElasticFlag is the current non_linear iteration step
-    //mPreviousInElasticFlag is the previous non_linear iteration step
-    bool mPreviousInElasticFlag = false;/// This flags tells if we are in a elastic or ineslastic regime
-    bool mCurrentInElasticFlag = false;/// This flags tells if we are in a elastic or ineslastic regime
-
-
+    //the following members are vectors where
+    //[0] is the current non_linear iteration step
+    //[1] is the previous non_linear iteration step
+    std::vector<bool> mInElasticFlagVector = {false, false}; /// This flags tells if we are in a elastic or ineslastic regime
     BoundedVector<double, 2> mPlasticAlphaVector = ZeroVector(2); /// The current plastic increment
     BoundedVector<double, 2> mAccumulatedPlasticStrainVector = ZeroVector(2); /// The current accumulated plastic strain
 
@@ -252,8 +249,7 @@ private:
         rSerializer.save("StressState", this->mStressState);
         rSerializer.save("PlasticAlpha", this->mPlasticAlphaVector);
         rSerializer.save("AccumulatedPlasticStrain", this->mAccumulatedPlasticStrainVector);
-        rSerializer.save("PreviousInelasticFlag", this->mPreviousInElasticFlag);
-        rSerializer.save("CurrentInElasticFlag", this->mCurrentInElasticFlag);
+        rSerializer.save("InelasticFlag", this->mInElasticFlagVector);
     }
 
     void load(Serializer& rSerializer) override
@@ -262,8 +258,7 @@ private:
         rSerializer.load("StressState", this->mStressState);
         rSerializer.load("PlasticAlpha", this->mPlasticAlphaVector);
         rSerializer.load("AccumulatedPlasticStrain", this->mAccumulatedPlasticStrainVector);
-        rSerializer.load("PreviousInelasticFlag", this->mPreviousInElasticFlag);
-        rSerializer.load("CurrentInElasticFlag", this->mCurrentInElasticFlag);
+        rSerializer.load("InelasticFlag", this->mInElasticFlagVector);
     }
 
 
diff --git a/applications/StructuralMechanicsApplication/custom_constitutive/yield_surfaces/mohr_coulomb_yield_surface.h b/applications/StructuralMechanicsApplication/custom_constitutive/yield_surfaces/mohr_coulomb_yield_surface.h
index 8825765e59..5936b195f4 100644
--- a/applications/StructuralMechanicsApplication/custom_constitutive/yield_surfaces/mohr_coulomb_yield_surface.h
+++ b/applications/StructuralMechanicsApplication/custom_constitutive/yield_surfaces/mohr_coulomb_yield_surface.h
@@ -166,15 +166,16 @@ public:
         )
     {
         const Properties& r_material_properties = rValues.GetMaterialProperties();
+
         const double fracture_energy = r_material_properties[FRACTURE_ENERGY];
         const double young_modulus = r_material_properties[YOUNG_MODULUS];
-        double equivalent_yield;
-        GetInitialUniaxialThreshold(rValues, equivalent_yield);
+        const double yield_compression = r_material_properties.Has(YIELD_STRESS) ? r_material_properties[YIELD_STRESS] : r_material_properties[YIELD_STRESS_COMPRESSION];
+
         if (r_material_properties[SOFTENING_TYPE] == static_cast<int>(SofteningType::Exponential)) {
-            rAParameter = 1.00 / (fracture_energy * young_modulus / (CharacteristicLength * std::pow(equivalent_yield, 2)) - 0.5);
+            rAParameter = 1.00 / (fracture_energy * young_modulus / (CharacteristicLength * std::pow(yield_compression, 2)) - 0.5);
             KRATOS_ERROR_IF(rAParameter < 0.0) << "Fracture Energy is too low, increase FRACTURE_ENERGY..." << std::endl;
         } else { // linear
-            rAParameter = -std::pow(equivalent_yield, 2) / (2.0 * young_modulus * fracture_energy / CharacteristicLength);
+            rAParameter = -std::pow(yield_compression, 2) / (2.0 * young_modulus * fracture_energy / CharacteristicLength);
         }
     }
 
diff --git a/applications/StructuralMechanicsApplication/custom_elements/base_solid_element.cpp b/applications/StructuralMechanicsApplication/custom_elements/base_solid_element.cpp
index 44e09fb1ff..3e5a0f4b2b 100644
--- a/applications/StructuralMechanicsApplication/custom_elements/base_solid_element.cpp
+++ b/applications/StructuralMechanicsApplication/custom_elements/base_solid_element.cpp
@@ -1599,7 +1599,7 @@ Matrix& BaseSolidElement::CalculateDeltaDisplacement(Matrix& DeltaDisplacement)
     const SizeType number_of_nodes = GetGeometry().PointsNumber();
     const SizeType dimension = GetGeometry().WorkingSpaceDimension();
 
-    DeltaDisplacement.resize(number_of_nodes , dimension, false);
+    DeltaDisplacement.resize(number_of_nodes , dimension);
 
     for ( IndexType i_node = 0; i_node < number_of_nodes; i_node++ ) {
         const array_1d<double, 3 >& current_displacement  = GetGeometry()[i_node].FastGetSolutionStepValue(DISPLACEMENT);
diff --git a/applications/StructuralMechanicsApplication/custom_elements/cable_element_3D2N.cpp b/applications/StructuralMechanicsApplication/custom_elements/cable_element_3D2N.cpp
index 6640b07275..5bcd955aba 100644
--- a/applications/StructuralMechanicsApplication/custom_elements/cable_element_3D2N.cpp
+++ b/applications/StructuralMechanicsApplication/custom_elements/cable_element_3D2N.cpp
@@ -75,16 +75,54 @@ CableElement3D2N::CreateElementStiffnessMatrix(
   KRATOS_CATCH("")
 }
 
+void CableElement3D2N::CalculateLocalSystem(MatrixType &rLeftHandSideMatrix,
+                                            VectorType &rRightHandSideVector,
+                                            ProcessInfo &rCurrentProcessInfo) {
+
+  KRATOS_TRY
+  // calculate internal forces
+  BoundedVector<double, msLocalSize> internal_forces = ZeroVector(msLocalSize);
+  this->UpdateInternalForces(internal_forces);
+  // resizing the matrices + create memory for LHS
+
+  rLeftHandSideMatrix = ZeroMatrix(msLocalSize, msLocalSize);
+  // creating LHS
+  noalias(rLeftHandSideMatrix) =
+      this->CreateElementStiffnessMatrix(rCurrentProcessInfo);
+
+
+  if (this->mIsCompressed) {
+    rRightHandSideVector = ZeroVector(msLocalSize);
+  } else {
+    // create+compute RHS
+    rRightHandSideVector = ZeroVector(msLocalSize);
+    // update Residual
+    noalias(rRightHandSideVector) -= internal_forces;
+  }
+
+  // add bodyforces
+  if (this->HasSelfWeight()) noalias(rRightHandSideVector) += this->CalculateBodyForces();
+  KRATOS_CATCH("")
+}
+
 void CableElement3D2N::CalculateRightHandSide(
     VectorType &rRightHandSideVector, ProcessInfo &rCurrentProcessInfo) {
 
   KRATOS_TRY
   rRightHandSideVector = ZeroVector(msLocalSize);
 
-  BoundedVector<double, msLocalSize> internal_forces = ZeroVector(msLocalSize);
-  this->UpdateInternalForces(internal_forces);
+  if (!this->mIsCompressed) {
+    BoundedVector<double,msLocalSize> internal_forces =
+      this->GetConstitutiveLawTrialResponse(rCurrentProcessInfo,false);
+
+    BoundedMatrix<double, msLocalSize, msLocalSize> transformation_matrix =
+        ZeroMatrix(msLocalSize, msLocalSize);
+    this->CreateTransformationMatrix(transformation_matrix);
+
+
+    noalias(rRightHandSideVector) -= prod(transformation_matrix, internal_forces);
+  }
 
-  if (!this->mIsCompressed) noalias(rRightHandSideVector) -= internal_forces;
   // add bodyforces
   if (this->HasSelfWeight()) noalias(rRightHandSideVector) += this->CalculateBodyForces();
   KRATOS_CATCH("")
@@ -118,6 +156,7 @@ void CableElement3D2N::UpdateInternalForces(
   this->mpConstitutiveLaw->CalculateValue(Values,NORMAL_STRESS,temp_internal_stresses);
 
 
+
   const double normal_force =
       ((temp_internal_stresses[3] + prestress) * l * A) / L0;
 
@@ -134,6 +173,49 @@ void CableElement3D2N::UpdateInternalForces(
   KRATOS_CATCH("");
 }
 
+
+BoundedVector<double,TrussElement3D2N::msLocalSize>
+  CableElement3D2N::GetConstitutiveLawTrialResponse(
+   const ProcessInfo& rCurrentProcessInfo, const bool rSaveInternalVariables)
+{
+    KRATOS_TRY;
+    const double numerical_limit = std::numeric_limits<double>::epsilon();
+    Vector strain_vector = ZeroVector(this->mpConstitutiveLaw->GetStrainSize());
+    Vector stress_vector = ZeroVector(this->mpConstitutiveLaw->GetStrainSize());
+    strain_vector[0] = this->CalculateGreenLagrangeStrain();
+
+    Matrix temp_matrix;
+    Vector temp_vector;
+
+    this->mpConstitutiveLaw->CalculateMaterialResponse(strain_vector,
+    temp_matrix,stress_vector,temp_matrix,rCurrentProcessInfo,this->GetProperties(),
+    this->GetGeometry(),temp_vector,true,true,rSaveInternalVariables);
+
+    BoundedVector<double,msLocalSize> internal_forces = ZeroVector(msLocalSize);
+    const double l = StructuralMechanicsElementUtilities::CalculateCurrentLength3D2N(*this);
+    const double L0 = StructuralMechanicsElementUtilities::CalculateReferenceLength3D2N(*this);
+    const double A = this->GetProperties()[CROSS_AREA];
+    double prestress = 0.00;
+    if (this->GetProperties().Has(TRUSS_PRESTRESS_PK2)) {
+      prestress = this->GetProperties()[TRUSS_PRESTRESS_PK2];
+    }
+
+    const double normal_force =
+        ((stress_vector[0] + prestress) * l * A) / L0;
+
+    this->mIsCompressed = false;
+    if ((normal_force < 0.00)&&(std::abs(l-L0)>numerical_limit)) this->mIsCompressed = true;
+
+    internal_forces[0] = -1.0 * normal_force;
+    internal_forces[3] = +1.0 * normal_force;
+
+    return internal_forces;
+    KRATOS_CATCH("");
+}
+
+
+
+
 void CableElement3D2N::save(Serializer &rSerializer) const {
   KRATOS_SERIALIZE_SAVE_BASE_CLASS(rSerializer, TrussElement3D2N);
   rSerializer.save("mIscompressed", this->mIsCompressed);
diff --git a/applications/StructuralMechanicsApplication/custom_elements/cable_element_3D2N.hpp b/applications/StructuralMechanicsApplication/custom_elements/cable_element_3D2N.hpp
index e013bfdc75..f4d4ad0886 100644
--- a/applications/StructuralMechanicsApplication/custom_elements/cable_element_3D2N.hpp
+++ b/applications/StructuralMechanicsApplication/custom_elements/cable_element_3D2N.hpp
@@ -76,6 +76,11 @@ namespace Kratos
             PropertiesType::Pointer pProperties
             ) const override;
 
+        void CalculateLocalSystem(
+            MatrixType& rLeftHandSideMatrix,
+            VectorType& rRightHandSideVector,
+            ProcessInfo& rCurrentProcessInfo) override;
+
         BoundedMatrix<double,msLocalSize,msLocalSize>
          CreateElementStiffnessMatrix(ProcessInfo& rCurrentProcessInfo) override;
 
@@ -89,6 +94,16 @@ namespace Kratos
          */
         void UpdateInternalForces(BoundedVector<double,msLocalSize>& rinternalForces) override;
 
+        /**
+         * @brief This function calls the constitutive law to get stresses
+         * @param rCurrentProcessInfo Current process info
+         * @param rSaveInternalVariables Boolean to save internal constit. law variables
+         */
+
+        BoundedVector<double,msLocalSize> GetConstitutiveLawTrialResponse(
+            const ProcessInfo& rCurrentProcessInfo,
+            const bool rSaveInternalVariables) override;
+
     private:
         // boolean for the cable --> does not resist to compression
         bool mIsCompressed;
diff --git a/applications/StructuralMechanicsApplication/custom_elements/cr_beam_element_2D2N.cpp b/applications/StructuralMechanicsApplication/custom_elements/cr_beam_element_2D2N.cpp
index c31f6e2740..60b266ca07 100644
--- a/applications/StructuralMechanicsApplication/custom_elements/cr_beam_element_2D2N.cpp
+++ b/applications/StructuralMechanicsApplication/custom_elements/cr_beam_element_2D2N.cpp
@@ -889,77 +889,79 @@ void CrBeamElement2D2N::AddExplicitContribution(
   KRATOS_CATCH("")
 }
 
-int CrBeamElement2D2N::Check(const ProcessInfo &rCurrentProcessInfo)
-{
+int CrBeamElement2D2N::Check(const ProcessInfo &rCurrentProcessInfo) {
   KRATOS_TRY
-    const double numerical_limit = std::numeric_limits<double>::epsilon();
-
-    KRATOS_ERROR_IF(GetGeometry().WorkingSpaceDimension() != 2 || GetGeometry().size() != 2)
-        << "The beam element works only in 2D and with 2 noded elements" << std::endl;
-
-    // verify that the variables are correctly initialized
-    if (VELOCITY.Key() == 0) {
-        KRATOS_ERROR << "VELOCITY has Key zero! (check if the application is "
-                        "correctly registered"
-                    << "" << std::endl;
-    }
-    if (DISPLACEMENT.Key() == 0) {
-        KRATOS_ERROR << "DISPLACEMENT has Key zero! (check if the application is "
-                        "correctly registered"
-                    << "" << std::endl;
-    }
-    if (ACCELERATION.Key() == 0) {
-        KRATOS_ERROR << "ACCELERATION has Key zero! (check if the application is "
-                        "correctly registered"
-                    << "" << std::endl;
-    }
-    if (DENSITY.Key() == 0) {
-        KRATOS_ERROR << "DENSITY has Key zero! (check if the application is "
-                        "correctly registered"
-                    << "" << std::endl;
-    }
-    if (CROSS_AREA.Key() == 0) {
-        KRATOS_ERROR << "CROSS_AREA has Key zero! (check if the application is "
-                        "correctly registered"
-                    << "" << std::endl;
+  const double numerical_limit = std::numeric_limits<double>::epsilon();
+  if (GetGeometry().WorkingSpaceDimension() != 2 || GetGeometry().size() != 2) {
+    KRATOS_ERROR
+        << "The beam element works only in 2D and with 2 noded elements"
+        << "" << std::endl;
+  }
+  // verify that the variables are correctly initialized
+  if (VELOCITY.Key() == 0) {
+    KRATOS_ERROR << "VELOCITY has Key zero! (check if the application is "
+                    "correctly registered"
+                 << "" << std::endl;
+  }
+  if (DISPLACEMENT.Key() == 0) {
+    KRATOS_ERROR << "DISPLACEMENT has Key zero! (check if the application is "
+                    "correctly registered"
+                 << "" << std::endl;
+  }
+  if (ACCELERATION.Key() == 0) {
+    KRATOS_ERROR << "ACCELERATION has Key zero! (check if the application is "
+                    "correctly registered"
+                 << "" << std::endl;
+  }
+  if (DENSITY.Key() == 0) {
+    KRATOS_ERROR << "DENSITY has Key zero! (check if the application is "
+                    "correctly registered"
+                 << "" << std::endl;
+  }
+  if (CROSS_AREA.Key() == 0) {
+    KRATOS_ERROR << "CROSS_AREA has Key zero! (check if the application is "
+                    "correctly registered"
+                 << "" << std::endl;
+  }
+  // verify that the dofs exist
+  for (unsigned int i = 0; i < this->GetGeometry().size(); ++i) {
+    if (this->GetGeometry()[i].SolutionStepsDataHas(DISPLACEMENT) == false) {
+      KRATOS_ERROR << "missing variable DISPLACEMENT on node "
+                   << this->GetGeometry()[i].Id() << std::endl;
     }
-
-    // verify that the dofs exist
-    for (unsigned int i = 0; i < this->GetGeometry().size(); ++i) {
-        if (this->GetGeometry()[i].SolutionStepsDataHas(DISPLACEMENT) == false) {
-        KRATOS_ERROR << "missing variable DISPLACEMENT on node "
-                    << this->GetGeometry()[i].Id() << std::endl;
-        }
-        if (this->GetGeometry()[i].HasDofFor(DISPLACEMENT_X) == false ||
-            this->GetGeometry()[i].HasDofFor(DISPLACEMENT_Y) == false) {
-        KRATOS_ERROR
-            << "missing one of the dofs for the variable DISPLACEMENT on node "
-            << GetGeometry()[i].Id() << std::endl;
-        }
+    if (this->GetGeometry()[i].HasDofFor(DISPLACEMENT_X) == false ||
+        this->GetGeometry()[i].HasDofFor(DISPLACEMENT_Y) == false) {
+      KRATOS_ERROR
+          << "missing one of the dofs for the variable DISPLACEMENT on node "
+          << GetGeometry()[i].Id() << std::endl;
     }
+  }
 
-    KRATOS_ERROR_IF(!this->GetProperties().Has(CROSS_AREA) ||
-                    this->GetProperties()[CROSS_AREA] <= numerical_limit)
-        << "Please provide a reasonable value for \"CROSS_AREA\" for element #"
-        << this->Id() << std::endl;
-
-    KRATOS_ERROR_IF(!this->GetProperties().Has(YOUNG_MODULUS) ||
-                    this->GetProperties()[YOUNG_MODULUS] <= numerical_limit)
-        << "Please provide a reasonable value for \"YOUNG_MODULUS\" for element #"
-        << this->Id() << std::endl;
+  if (this->GetProperties().Has(CROSS_AREA) == false ||
+      this->GetProperties()[CROSS_AREA] <= numerical_limit) {
+    KRATOS_ERROR << "CROSS_AREA not provided for this element" << this->Id()
+                 << std::endl;
+  }
 
-    KRATOS_ERROR_IF(!this->GetProperties().Has(DENSITY) ||
-                    this->GetProperties()[DENSITY] <= numerical_limit)
-        << "Please provide a reasonable value for \"DENSITY\" for element #"
-        << this->Id() << std::endl;
+  if (this->GetProperties().Has(YOUNG_MODULUS) == false ||
+      this->GetProperties()[YOUNG_MODULUS] <= numerical_limit) {
+    KRATOS_ERROR << "YOUNG_MODULUS not provided for this element" << this->Id()
+                 << std::endl;
+  }
+  if (this->GetProperties().Has(DENSITY) == false) {
+    KRATOS_ERROR << "DENSITY not provided for this element" << this->Id()
+                 << std::endl;
+  }
 
-    KRATOS_ERROR_IF(!this->GetProperties().Has(I33) ||
-                    this->GetProperties()[I33] <= numerical_limit)
-        << "Please provide a reasonable value for \"I33\" for element #"
-        << this->Id() << std::endl;
+  if (this->GetProperties().Has(POISSON_RATIO) == false) {
+    KRATOS_ERROR << "POISSON_RATIO not provided for this element" << this->Id()
+                 << std::endl;
+  }
 
-    KRATOS_ERROR_IF(!this->GetProperties().Has(POISSON_RATIO))
-        << "\"POISSON_RATIO\" not provided for element #" << this->Id() << std::endl;
+  if (this->GetProperties().Has(I33) == false) {
+    KRATOS_ERROR << "I33 not provided for this element" << this->Id()
+                 << std::endl;
+  }
 
     KRATOS_ERROR_IF(StructuralMechanicsElementUtilities::CalculateReferenceLength2D2N(*this)
          < std::numeric_limits<double>::epsilon())
diff --git a/applications/StructuralMechanicsApplication/custom_elements/cr_beam_element_3D2N.cpp b/applications/StructuralMechanicsApplication/custom_elements/cr_beam_element_3D2N.cpp
index 1a15c34250..751995e681 100644
--- a/applications/StructuralMechanicsApplication/custom_elements/cr_beam_element_3D2N.cpp
+++ b/applications/StructuralMechanicsApplication/custom_elements/cr_beam_element_3D2N.cpp
@@ -995,6 +995,7 @@ void CrBeamElement3D2N::CalculateRightHandSide(
       ZeroVector(msElementSize);
   nodal_forces_global_q = prod(transformation_matrix, this->mNodalForces);
 
+  this->mNodalForces = nodal_forces_global_q;
   // create+compute RHS
   // update Residual
   rRightHandSideVector = ZeroVector(msElementSize);
@@ -1146,33 +1147,36 @@ void CrBeamElement3D2N::CalculateOnIntegrationPoints(
     this->AssembleSmallInBigMatrix(this->mLocalRotationMatrix,
                                    transformation_matrix);
 
+  Vector stress = this->mNodalForces;
+  stress = prod(trans(transformation_matrix), stress);
+
   // rOutput[GP 1,2,3][x,y,z]
 
   if (rVariable == MOMENT) {
-    rOutput[0][0] = -1.0 * this->mNodalForces[3] * 0.75 + this->mNodalForces[9] * 0.25;
-    rOutput[1][0] = -1.0 * this->mNodalForces[3] * 0.50 + this->mNodalForces[9] * 0.50;
-    rOutput[2][0] = -1.0 * this->mNodalForces[3] * 0.25 + this->mNodalForces[9] * 0.75;
+    rOutput[0][0] = -1.0 * stress[3] * 0.75 + stress[9] * 0.25;
+    rOutput[1][0] = -1.0 * stress[3] * 0.50 + stress[9] * 0.50;
+    rOutput[2][0] = -1.0 * stress[3] * 0.25 + stress[9] * 0.75;
 
-    rOutput[0][1] = -1.0 * this->mNodalForces[4] * 0.75 + this->mNodalForces[10] * 0.25;
-    rOutput[1][1] = -1.0 * this->mNodalForces[4] * 0.50 + this->mNodalForces[10] * 0.50;
-    rOutput[2][1] = -1.0 * this->mNodalForces[4] * 0.25 + this->mNodalForces[10] * 0.75;
+    rOutput[0][1] = -1.0 * stress[4] * 0.75 + stress[10] * 0.25;
+    rOutput[1][1] = -1.0 * stress[4] * 0.50 + stress[10] * 0.50;
+    rOutput[2][1] = -1.0 * stress[4] * 0.25 + stress[10] * 0.75;
 
-    rOutput[0][2] = 1.0 * this->mNodalForces[5] * 0.75 - this->mNodalForces[11] * 0.25;
-    rOutput[1][2] = 1.0 * this->mNodalForces[5] * 0.50 - this->mNodalForces[11] * 0.50;
-    rOutput[2][2] = 1.0 * this->mNodalForces[5] * 0.25 - this->mNodalForces[11] * 0.75;
+    rOutput[0][2] = 1.0 * stress[5] * 0.75 - stress[11] * 0.25;
+    rOutput[1][2] = 1.0 * stress[5] * 0.50 - stress[11] * 0.50;
+    rOutput[2][2] = 1.0 * stress[5] * 0.25 - stress[11] * 0.75;
   }
   else if (rVariable == FORCE) {
-    rOutput[0][0] = -1.0 * this->mNodalForces[0] * 0.75 + this->mNodalForces[6] * 0.25;
-    rOutput[1][0] = -1.0 * this->mNodalForces[0] * 0.50 + this->mNodalForces[6] * 0.50;
-    rOutput[2][0] = -1.0 * this->mNodalForces[0] * 0.25 + this->mNodalForces[6] * 0.75;
+    rOutput[0][0] = -1.0 * stress[0] * 0.75 + stress[6] * 0.25;
+    rOutput[1][0] = -1.0 * stress[0] * 0.50 + stress[6] * 0.50;
+    rOutput[2][0] = -1.0 * stress[0] * 0.25 + stress[6] * 0.75;
 
-    rOutput[0][1] = -1.0 * this->mNodalForces[1] * 0.75 + this->mNodalForces[7] * 0.25;
-    rOutput[1][1] = -1.0 * this->mNodalForces[1] * 0.50 + this->mNodalForces[7] * 0.50;
-    rOutput[2][1] = -1.0 * this->mNodalForces[1] * 0.25 + this->mNodalForces[7] * 0.75;
+    rOutput[0][1] = -1.0 * stress[1] * 0.75 + stress[7] * 0.25;
+    rOutput[1][1] = -1.0 * stress[1] * 0.50 + stress[7] * 0.50;
+    rOutput[2][1] = -1.0 * stress[1] * 0.25 + stress[7] * 0.75;
 
-    rOutput[0][2] = -1.0 * this->mNodalForces[2] * 0.75 + this->mNodalForces[8] * 0.25;
-    rOutput[1][2] = -1.0 * this->mNodalForces[2] * 0.50 + this->mNodalForces[8] * 0.50;
-    rOutput[2][2] = -1.0 * this->mNodalForces[2] * 0.25 + this->mNodalForces[8] * 0.75;
+    rOutput[0][2] = -1.0 * stress[2] * 0.75 + stress[8] * 0.25;
+    rOutput[1][2] = -1.0 * stress[2] * 0.50 + stress[8] * 0.50;
+    rOutput[2][2] = -1.0 * stress[2] * 0.25 + stress[8] * 0.75;
   }
 
 
@@ -1532,125 +1536,127 @@ double CrBeamElement3D2N::CalculateShearModulus() const {
   KRATOS_CATCH("")
 }
 
-int CrBeamElement3D2N::Check(const ProcessInfo &rCurrentProcessInfo)
-{
-    KRATOS_TRY
-    const double numerical_limit = std::numeric_limits<double>::epsilon();
-
-    KRATOS_ERROR_IF(GetGeometry().WorkingSpaceDimension() != 3 || GetGeometry().size() != 2)
-        << "The beam element works only in 3D and with 2 noded elements" << std::endl;
-
-    // verify that the variables are correctly initialized
-    if (VELOCITY.Key() == 0) {
-        KRATOS_ERROR << "VELOCITY has Key zero! (check if the application is "
-                        "correctly registered"
-                    << "" << std::endl;
-    }
-    if (DISPLACEMENT.Key() == 0) {
-        KRATOS_ERROR << "DISPLACEMENT has Key zero! (check if the application is "
-                        "correctly registered"
-                    << "" << std::endl;
-    }
-    if (ACCELERATION.Key() == 0) {
-        KRATOS_ERROR << "ACCELERATION has Key zero! (check if the application is "
-                        "correctly registered"
-                    << "" << std::endl;
-    }
-    if (DENSITY.Key() == 0) {
-        KRATOS_ERROR << "DENSITY has Key zero! (check if the application is "
-                        "correctly registered"
-                    << "" << std::endl;
-    }
-    if (CROSS_AREA.Key() == 0) {
-        KRATOS_ERROR << "CROSS_AREA has Key zero! (check if the application is "
-                        "correctly registered"
-                    << "" << std::endl;
+int CrBeamElement3D2N::Check(const ProcessInfo &rCurrentProcessInfo) {
+  KRATOS_TRY
+  const double numerical_limit = std::numeric_limits<double>::epsilon();
+  if (GetGeometry().WorkingSpaceDimension() != 3 || GetGeometry().size() != 2) {
+    KRATOS_ERROR
+        << "The beam element works only in 3D and with 2 noded elements"
+        << "" << std::endl;
+  }
+  // verify that the variables are correctly initialized
+  if (VELOCITY.Key() == 0) {
+    KRATOS_ERROR << "VELOCITY has Key zero! (check if the application is "
+                    "correctly registered"
+                 << "" << std::endl;
+  }
+  if (DISPLACEMENT.Key() == 0) {
+    KRATOS_ERROR << "DISPLACEMENT has Key zero! (check if the application is "
+                    "correctly registered"
+                 << "" << std::endl;
+  }
+  if (ACCELERATION.Key() == 0) {
+    KRATOS_ERROR << "ACCELERATION has Key zero! (check if the application is "
+                    "correctly registered"
+                 << "" << std::endl;
+  }
+  if (DENSITY.Key() == 0) {
+    KRATOS_ERROR << "DENSITY has Key zero! (check if the application is "
+                    "correctly registered"
+                 << "" << std::endl;
+  }
+  if (CROSS_AREA.Key() == 0) {
+    KRATOS_ERROR << "CROSS_AREA has Key zero! (check if the application is "
+                    "correctly registered"
+                 << "" << std::endl;
+  }
+  // verify that the dofs exist
+  for (unsigned int i = 0; i < this->GetGeometry().size(); ++i) {
+    if (this->GetGeometry()[i].SolutionStepsDataHas(DISPLACEMENT) == false) {
+      KRATOS_ERROR << "missing variable DISPLACEMENT on node "
+                   << this->GetGeometry()[i].Id() << std::endl;
     }
-    // verify that the dofs exist
-    for (unsigned int i = 0; i < this->GetGeometry().size(); ++i) {
-        if (this->GetGeometry()[i].SolutionStepsDataHas(DISPLACEMENT) == false) {
-        KRATOS_ERROR << "missing variable DISPLACEMENT on node "
-                    << this->GetGeometry()[i].Id() << std::endl;
-        }
-        if (this->GetGeometry()[i].HasDofFor(DISPLACEMENT_X) == false ||
-            this->GetGeometry()[i].HasDofFor(DISPLACEMENT_Y) == false ||
-            this->GetGeometry()[i].HasDofFor(DISPLACEMENT_Z) == false) {
-        KRATOS_ERROR
-            << "missing one of the dofs for the variable DISPLACEMENT on node "
-            << GetGeometry()[i].Id() << std::endl;
-        }
+    if (this->GetGeometry()[i].HasDofFor(DISPLACEMENT_X) == false ||
+        this->GetGeometry()[i].HasDofFor(DISPLACEMENT_Y) == false ||
+        this->GetGeometry()[i].HasDofFor(DISPLACEMENT_Z) == false) {
+      KRATOS_ERROR
+          << "missing one of the dofs for the variable DISPLACEMENT on node "
+          << GetGeometry()[i].Id() << std::endl;
     }
+  }
 
-    KRATOS_ERROR_IF(!this->GetProperties().Has(CROSS_AREA) ||
-                    this->GetProperties()[CROSS_AREA] <= numerical_limit)
-        << "Please provide a reasonable value for \"CROSS_AREA\" for element #"
-        << this->Id() << std::endl;
-
-    KRATOS_ERROR_IF(!this->GetProperties().Has(YOUNG_MODULUS) ||
-                    this->GetProperties()[YOUNG_MODULUS] <= numerical_limit)
-        << "Please provide a reasonable value for \"YOUNG_MODULUS\" for element #"
-        << this->Id() << std::endl;
-
-    KRATOS_ERROR_IF(!this->GetProperties().Has(DENSITY) ||
-                    this->GetProperties()[DENSITY] <= numerical_limit)
-        << "Please provide a reasonable value for \"DENSITY\" for element #"
-        << this->Id() << std::endl;
-
-    KRATOS_ERROR_IF(!this->GetProperties().Has(I22) ||
-                    this->GetProperties()[I22] <= numerical_limit)
-        << "Please provide a reasonable value for \"I22\" for element #"
-        << this->Id() << std::endl;
-
-    KRATOS_ERROR_IF(!this->GetProperties().Has(I33) ||
-                    this->GetProperties()[I33] <= numerical_limit)
-        << "Please provide a reasonable value for \"I33\" for element #"
-        << this->Id() << std::endl;
-
-    KRATOS_ERROR_IF(!this->GetProperties().Has(TORSIONAL_INERTIA) ||
-                    this->GetProperties()[TORSIONAL_INERTIA] <= numerical_limit)
-        << "Please provide a reasonable value for \"TORSIONAL_INERTIA\" for element #"
-        << this->Id() << std::endl;
-
-    KRATOS_ERROR_IF(!this->GetProperties().Has(POISSON_RATIO))
-        << "\"POISSON_RATIO\" not provided for element #" << this->Id() << std::endl;
-
-    if (this->Has(LOCAL_AXIS_2)) {
-        array_1d<double, msDimension> direction_vector_x = ZeroVector(msDimension);
-        array_1d<double, msDimension> direction_vector_y = ZeroVector(msDimension);
-        array_1d<double, msLocalSize> reference_coordinates = ZeroVector(msLocalSize);
-
-        reference_coordinates[0] = this->GetGeometry()[0].X0();
-        reference_coordinates[1] = this->GetGeometry()[0].Y0();
-        reference_coordinates[2] = this->GetGeometry()[0].Z0();
-        reference_coordinates[3] = this->GetGeometry()[1].X0();
-        reference_coordinates[4] = this->GetGeometry()[1].Y0();
-        reference_coordinates[5] = this->GetGeometry()[1].Z0();
-
-        for (unsigned int i = 0; i < msDimension; ++i) {
-            direction_vector_x[i] = (reference_coordinates[i + msDimension] - reference_coordinates[i]);
-        }
+  if (this->GetProperties().Has(CROSS_AREA) == false ||
+      this->GetProperties()[CROSS_AREA] <= numerical_limit) {
+    KRATOS_ERROR << "CROSS_AREA not provided for this element" << this->Id()
+                 << std::endl;
+  }
 
-        const double vector_norm = MathUtils<double>::Norm(direction_vector_x);
-        if (vector_norm > numerical_limit)
-        direction_vector_x /= vector_norm;
+  if (this->GetProperties().Has(YOUNG_MODULUS) == false ||
+      this->GetProperties()[YOUNG_MODULUS] <= numerical_limit) {
+    KRATOS_ERROR << "YOUNG_MODULUS not provided for this element" << this->Id()
+                 << std::endl;
+  }
+  if (this->GetProperties().Has(DENSITY) == false) {
+    KRATOS_ERROR << "DENSITY not provided for this element" << this->Id()
+                 << std::endl;
+  }
 
-        direction_vector_y = this->GetValue(LOCAL_AXIS_2);
+  if (this->GetProperties().Has(POISSON_RATIO) == false) {
+    KRATOS_ERROR << "POISSON_RATIO not provided for this element" << this->Id()
+                 << std::endl;
+  }
 
-        KRATOS_ERROR_IF(MathUtils<double>::Norm(direction_vector_y)<numerical_limit)
-            << "Given LOCAL_AXIS_2 has length 0 for element " << this->Id() << std::endl;
+  if (this->GetProperties().Has(TORSIONAL_INERTIA) == false) {
+    KRATOS_ERROR << "TORSIONAL_INERTIA not provided for this element"
+                 << this->Id() << std::endl;
+  }
+  if (this->GetProperties().Has(I22) == false) {
+    KRATOS_ERROR << "I22 not provided for this element" << this->Id()
+                 << std::endl;
+  }
+  if (this->GetProperties().Has(I33) == false) {
+    KRATOS_ERROR << "I33 not provided for this element" << this->Id()
+                 << std::endl;
+  }
 
-        // a tollerance of 1e-3 allows for a rough deviation of 0.06 degrees from 90.0 degrees
-        KRATOS_ERROR_IF(std::abs(MathUtils<double>::Dot(direction_vector_x,direction_vector_y))>1e-3)
-            << "LOCAL_AXIS_1 is not perpendicular to LOCAL_AXIS_2 for element " << this->Id() << std::endl;
+  if (this->Has(LOCAL_AXIS_2)) {
+    array_1d<double, msDimension> direction_vector_x = ZeroVector(msDimension);
+    array_1d<double, msDimension> direction_vector_y = ZeroVector(msDimension);
+    array_1d<double, msLocalSize> reference_coordinates = ZeroVector(msLocalSize);
+
+    reference_coordinates[0] = this->GetGeometry()[0].X0();
+    reference_coordinates[1] = this->GetGeometry()[0].Y0();
+    reference_coordinates[2] = this->GetGeometry()[0].Z0();
+    reference_coordinates[3] = this->GetGeometry()[1].X0();
+    reference_coordinates[4] = this->GetGeometry()[1].Y0();
+    reference_coordinates[5] = this->GetGeometry()[1].Z0();
+
+    for (unsigned int i = 0; i < msDimension; ++i) {
+    direction_vector_x[i] =
+        (reference_coordinates[i + msDimension] - reference_coordinates[i]);
     }
 
+    const double vector_norm = MathUtils<double>::Norm(direction_vector_x);
+    if (vector_norm > numerical_limit)
+      direction_vector_x /= vector_norm;
+
+    direction_vector_y = this->GetValue(LOCAL_AXIS_2);
+
+    KRATOS_ERROR_IF(MathUtils<double>::Norm(direction_vector_y)<numerical_limit)
+      << "Given LOCAL_AXIS_2 has length 0 for element " << this->Id() << std::endl;
+
+    // a tollerance of 1e-3 allows for a rough deviation of 0.06 degrees from 90.0 degrees
+    KRATOS_ERROR_IF(std::abs(MathUtils<double>::Dot(direction_vector_x,direction_vector_y))>1e-3)
+      << "LOCAL_AXIS_1 is not perpendicular to LOCAL_AXIS_2 for element " << this->Id() << std::endl;
+  }
+
     KRATOS_ERROR_IF(StructuralMechanicsElementUtilities::CalculateReferenceLength3D2N(*this)
-        < std::numeric_limits<double>::epsilon())
+         < std::numeric_limits<double>::epsilon())
         << "Element #" << this->Id() << " has a length of zero!" << std::endl;
 
-    return 0;
+  return 0;
 
-    KRATOS_CATCH("")
+  KRATOS_CATCH("")
 }
 
 void CrBeamElement3D2N::save(Serializer &rSerializer) const {
diff --git a/applications/StructuralMechanicsApplication/custom_elements/isotropic_shell_element.cpp b/applications/StructuralMechanicsApplication/custom_elements/isotropic_shell_element.cpp
index 228960081e..577444d965 100644
--- a/applications/StructuralMechanicsApplication/custom_elements/isotropic_shell_element.cpp
+++ b/applications/StructuralMechanicsApplication/custom_elements/isotropic_shell_element.cpp
@@ -1548,7 +1548,7 @@ void IsotropicShellElement::CalculateProjectionOperator(
     rho(14,0) = 1.0/y31;
 
     //completing the calculation of the projections
-    noalias(rProjOperator) = IdentityMatrix(18);
+    noalias(rProjOperator) = IdentityMatrix(18,18);
     //noalias(rProjOperator) -= prod(trans(psi),rho);
     noalias(rProjOperator) -= prod(psi,trans(rho));
 
@@ -1620,7 +1620,7 @@ void IsotropicShellElement::UpdateNodalReferenceSystem(
 
         double temp = 1.0/(1.0 + 0.25*omega_scalar_2);
 
-        noalias(Ttilde) = IdentityMatrix(3);
+        noalias(Ttilde) = IdentityMatrix(3,3);
         noalias(Ttilde) += temp * Omega;
         noalias(Ttilde) += 0.5*temp * prod( Omega, Omega);
 
@@ -1655,9 +1655,9 @@ void IsotropicShellElement::SaveOriginalReference(
     }
 
     //initializing nodal triad matrices
-    noalias(mTs[0]) = IdentityMatrix(3);
-    noalias(mTs[1]) = IdentityMatrix(3);
-    noalias(mTs[2]) = IdentityMatrix(3);
+    noalias(mTs[0]) = IdentityMatrix(3,3);
+    noalias(mTs[1]) = IdentityMatrix(3,3);
+    noalias(mTs[2]) = IdentityMatrix(3,3);
 
 
     KRATOS_CATCH( "" )
@@ -1697,11 +1697,11 @@ void IsotropicShellElement::CalculatePureDisplacement(
         noalias(Ttilde) = prod(trans(TE),temp);
 
         //calculate Omega = 2.0*(T-I)*(T+I)^-1
-        noalias(aux) = IdentityMatrix(3);
+        noalias(aux) = IdentityMatrix(3,3);
         noalias(aux) += Ttilde;
         InvertMatrix(aux,temp,aaa); //now temp contains the inverse
         noalias(aux) = Ttilde;
-        noalias(aux) -= IdentityMatrix(3);
+        noalias(aux) -= IdentityMatrix(3,3);
         noalias(Omega) = 2.0 * prod(aux,temp);
 
         //extract pure rotations from Omega
@@ -1764,11 +1764,11 @@ void IsotropicShellElement::CalculatePureMembraneDisplacement(
         noalias(Ttilde) = prod(trans(TE),temp);
 
         //calculate Omega = 2.0*(T-I)*(T+I)^-1
-        noalias(aux) = IdentityMatrix(3);
+        noalias(aux) = IdentityMatrix(3,3);
         noalias(aux) += Ttilde;
         InvertMatrix(aux,temp,aaa); //now temp contains the inverse
         noalias(aux) = Ttilde;
-        noalias(aux) -= IdentityMatrix(3);
+        noalias(aux) -= IdentityMatrix(3,3);
         noalias(Omega) = 2.0 * prod(aux,temp);
 
         //node pos in the current config
@@ -1827,11 +1827,11 @@ void IsotropicShellElement::CalculatePureBendingDisplacement(
         noalias(Ttilde) = prod(trans(TE),temp);
 
         //calculate Omega = 2.0*(T-I)*(T+I)^-1
-        noalias(aux) = IdentityMatrix(3);
+        noalias(aux) = IdentityMatrix(3,3);
         noalias(aux) += Ttilde;
         InvertMatrix(aux,temp,aaa); //now temp contains the inverse
         noalias(aux) = Ttilde;
-        noalias(aux) -= IdentityMatrix(3);
+        noalias(aux) -= IdentityMatrix(3,3);
         noalias(Omega) = 2.0 * prod(aux,temp);
 
         //node pos in the current config
@@ -1864,7 +1864,7 @@ void IsotropicShellElement::InvertMatrix(const BoundedMatrix<double,3,3>& InputM
 {
     KRATOS_TRY
     if(InvertedMatrix.size1() != 3 || InvertedMatrix.size2() != 3)
-        InvertedMatrix.resize(3,3, false);
+        InvertedMatrix.resize(3,3);
 
     //filling the inverted matrix with the algebraic complements
     //first column
diff --git a/applications/StructuralMechanicsApplication/custom_elements/prestress_membrane_element.cpp b/applications/StructuralMechanicsApplication/custom_elements/prestress_membrane_element.cpp
index 65cad2540d..28c4cbd52d 100644
--- a/applications/StructuralMechanicsApplication/custom_elements/prestress_membrane_element.cpp
+++ b/applications/StructuralMechanicsApplication/custom_elements/prestress_membrane_element.cpp
@@ -261,7 +261,7 @@ void PrestressMembraneElement::CalculateMassMatrix(
     unsigned int mat_size = number_of_nodes * 3;
 
     if (rMassMatrix.size1() != mat_size) {
-        rMassMatrix.resize(mat_size, mat_size, false);
+        rMassMatrix.resize(mat_size, mat_size);
     }
 
     noalias(rMassMatrix) = ZeroMatrix(mat_size, mat_size);
@@ -316,7 +316,7 @@ void PrestressMembraneElement::GetValuesVector(
     const unsigned int mat_size = number_of_nodes * 3;
 
     if (rValues.size() != mat_size)
-        rValues.resize(mat_size, false);
+        rValues.resize(mat_size);
 
     for (unsigned int i = 0; i < number_of_nodes; i++)
     {
@@ -340,7 +340,7 @@ void PrestressMembraneElement::GetFirstDerivativesVector(
     const unsigned int mat_size = number_of_nodes * 3;
 
     if (rValues.size() != mat_size)
-        rValues.resize(mat_size, false);
+        rValues.resize(mat_size);
 
     for (unsigned int i = 0; i < number_of_nodes; i++)
     {
@@ -365,7 +365,7 @@ void PrestressMembraneElement::GetSecondDerivativesVector(
     const unsigned int mat_size = number_of_nodes * 3;
 
     if (rValues.size() != mat_size)
-        rValues.resize(mat_size, false);
+        rValues.resize(mat_size);
 
     for (unsigned int i = 0; i < number_of_nodes; i++)
     {
@@ -631,7 +631,7 @@ void PrestressMembraneElement::CalculateAll(
     {
         if (rLeftHandSideMatrix.size1() != mat_size)
         {
-            rLeftHandSideMatrix.resize(mat_size, mat_size, false);
+            rLeftHandSideMatrix.resize(mat_size, mat_size);
         }
 
         noalias(rLeftHandSideMatrix) = ZeroMatrix(mat_size, mat_size); //resetting LHS
@@ -642,7 +642,7 @@ void PrestressMembraneElement::CalculateAll(
     {
         if (rRightHandSideVector.size() != mat_size)
         {
-            rRightHandSideVector.resize(mat_size, false);
+            rRightHandSideVector.resize(mat_size);
         }
 
         rRightHandSideVector = ZeroVector(mat_size); //resetting RHS
@@ -1361,8 +1361,8 @@ void PrestressMembraneElement::ComputeBaseVectors(const GeometryType::Integratio
 
     Matrix& base_1 = GetValue(BASE_REF_1);
     Matrix& base_2 = GetValue(BASE_REF_2);
-    base_1.resize(3, rIntegrationPoints.size(), false);
-    base_2.resize(3, rIntegrationPoints.size(), false);
+    base_1.resize(3,rIntegrationPoints.size());
+    base_2.resize(3,rIntegrationPoints.size());
 
     // Calculating geometry tensors in reference configuration on Integration points
     for (unsigned int point_number = 0; point_number < rIntegrationPoints.size(); point_number++)
diff --git a/applications/StructuralMechanicsApplication/custom_elements/shell_thick_element_3D3N.cpp b/applications/StructuralMechanicsApplication/custom_elements/shell_thick_element_3D3N.cpp
index 6d1c4d74a3..2c9db35cfb 100644
--- a/applications/StructuralMechanicsApplication/custom_elements/shell_thick_element_3D3N.cpp
+++ b/applications/StructuralMechanicsApplication/custom_elements/shell_thick_element_3D3N.cpp
@@ -2154,22 +2154,13 @@ ShellCrossSection::SectionBehaviorType ShellThickElement3D3N::GetSectionBehavior
 void ShellThickElement3D3N::save(Serializer& rSerializer) const
 {
     KRATOS_SERIALIZE_SAVE_BASE_CLASS(rSerializer, BaseShellElement);
-    bool is_corotational = (nullptr != dynamic_cast<ShellT3_CorotationalCoordinateTransformation*>(mpCoordinateTransformation.get()));
-    rSerializer.save("is_corotational", is_corotational);
-    rSerializer.save("CTr", *mpCoordinateTransformation);
+    rSerializer.save("CTr", mpCoordinateTransformation);
 }
 
 void ShellThickElement3D3N::load(Serializer& rSerializer)
 {
-    KRATOS_SERIALIZE_LOAD_BASE_CLASS(rSerializer, BaseShellElement);
-    bool is_corotational;
-    rSerializer.load("is_corotational", is_corotational);
-    if (is_corotational) {
-        mpCoordinateTransformation = Kratos::make_shared<ShellT3_CorotationalCoordinateTransformation>(pGetGeometry());
-    } else {
-        mpCoordinateTransformation = Kratos::make_shared<ShellT3_CoordinateTransformation>(pGetGeometry());
-    }
-    rSerializer.load("CTr", *mpCoordinateTransformation);
+    KRATOS_SERIALIZE_SAVE_BASE_CLASS(rSerializer, BaseShellElement);
+    rSerializer.load("CTr", mpCoordinateTransformation);
 }
 
 } // namespace Kratos
diff --git a/applications/StructuralMechanicsApplication/custom_elements/shell_thick_element_3D4N.cpp b/applications/StructuralMechanicsApplication/custom_elements/shell_thick_element_3D4N.cpp
index 182de46420..6e22a9c56e 100644
--- a/applications/StructuralMechanicsApplication/custom_elements/shell_thick_element_3D4N.cpp
+++ b/applications/StructuralMechanicsApplication/custom_elements/shell_thick_element_3D4N.cpp
@@ -1906,24 +1906,15 @@ ShellCrossSection::SectionBehaviorType ShellThickElement3D4N::GetSectionBehavior
 
 void ShellThickElement3D4N::save(Serializer& rSerializer) const
 {
-    KRATOS_SERIALIZE_SAVE_BASE_CLASS(rSerializer, BaseShellElement);
-    bool is_corotational = (nullptr != dynamic_cast<ShellQ4_CorotationalCoordinateTransformation*>(mpCoordinateTransformation.get()));
-    rSerializer.save("is_corotational", is_corotational);
-    rSerializer.save("CTr", *mpCoordinateTransformation);
+    KRATOS_SERIALIZE_SAVE_BASE_CLASS(rSerializer,  BaseShellElement );
+    rSerializer.save("CTr", mpCoordinateTransformation);
     rSerializer.save("EAS", mEASStorage);
 }
 
 void ShellThickElement3D4N::load(Serializer& rSerializer)
 {
-    KRATOS_SERIALIZE_LOAD_BASE_CLASS(rSerializer, BaseShellElement);
-    bool is_corotational;
-    rSerializer.load("is_corotational", is_corotational);
-    if (is_corotational) {
-        mpCoordinateTransformation = Kratos::make_shared<ShellQ4_CorotationalCoordinateTransformation>(pGetGeometry());
-    } else {
-        mpCoordinateTransformation = Kratos::make_shared<ShellQ4_CoordinateTransformation>(pGetGeometry());
-    }
-    rSerializer.load("CTr", *mpCoordinateTransformation);
+    KRATOS_SERIALIZE_SAVE_BASE_CLASS(rSerializer,  BaseShellElement );
+    rSerializer.load("CTr", mpCoordinateTransformation);
     rSerializer.load("EAS", mEASStorage);
 }
 
diff --git a/applications/StructuralMechanicsApplication/custom_elements/shell_thin_element_3D3N.cpp b/applications/StructuralMechanicsApplication/custom_elements/shell_thin_element_3D3N.cpp
index 46412e5136..88f0df8df2 100644
--- a/applications/StructuralMechanicsApplication/custom_elements/shell_thin_element_3D3N.cpp
+++ b/applications/StructuralMechanicsApplication/custom_elements/shell_thin_element_3D3N.cpp
@@ -1661,23 +1661,14 @@ ShellCrossSection::SectionBehaviorType ShellThinElement3D3N::GetSectionBehavior(
 
 void ShellThinElement3D3N::save(Serializer& rSerializer) const
 {
-    KRATOS_SERIALIZE_SAVE_BASE_CLASS(rSerializer, BaseShellElement);
-    bool is_corotational = (nullptr != dynamic_cast<ShellT3_CorotationalCoordinateTransformation*>(mpCoordinateTransformation.get()));
-    rSerializer.save("is_corotational", is_corotational);
-    rSerializer.save("CTr", *mpCoordinateTransformation);
+    KRATOS_SERIALIZE_SAVE_BASE_CLASS(rSerializer,  BaseShellElement );
+    rSerializer.save("CTr", mpCoordinateTransformation);
 }
 
 void ShellThinElement3D3N::load(Serializer& rSerializer)
 {
-    KRATOS_SERIALIZE_LOAD_BASE_CLASS(rSerializer, BaseShellElement);
-    bool is_corotational;
-    rSerializer.load("is_corotational", is_corotational);
-    if (is_corotational) {
-        mpCoordinateTransformation = Kratos::make_shared<ShellT3_CorotationalCoordinateTransformation>(pGetGeometry());
-    } else {
-        mpCoordinateTransformation = Kratos::make_shared<ShellT3_CoordinateTransformation>(pGetGeometry());
-    }
-    rSerializer.load("CTr", *mpCoordinateTransformation);
+    KRATOS_SERIALIZE_SAVE_BASE_CLASS(rSerializer,  BaseShellElement );
+    rSerializer.load("CTr", mpCoordinateTransformation);
 }
 
 }
diff --git a/applications/StructuralMechanicsApplication/custom_elements/shell_thin_element_3D4N.cpp b/applications/StructuralMechanicsApplication/custom_elements/shell_thin_element_3D4N.cpp
index e2d8e376b7..53a77a4248 100644
--- a/applications/StructuralMechanicsApplication/custom_elements/shell_thin_element_3D4N.cpp
+++ b/applications/StructuralMechanicsApplication/custom_elements/shell_thin_element_3D4N.cpp
@@ -2421,21 +2421,12 @@ ShellCrossSection::SectionBehaviorType ShellThinElement3D4N::GetSectionBehavior(
 void ShellThinElement3D4N::save(Serializer& rSerializer) const
 {
     KRATOS_SERIALIZE_SAVE_BASE_CLASS(rSerializer, BaseShellElement);
-    bool is_corotational = (nullptr != dynamic_cast<ShellQ4_CorotationalCoordinateTransformation*>(mpCoordinateTransformation.get()));
-    rSerializer.save("is_corotational", is_corotational);
-    rSerializer.save("CTr", *mpCoordinateTransformation);
+    rSerializer.save("CTr", mpCoordinateTransformation);
 }
 
 void ShellThinElement3D4N::load(Serializer& rSerializer)
 {
-    KRATOS_SERIALIZE_LOAD_BASE_CLASS(rSerializer, BaseShellElement);
-    bool is_corotational;
-    rSerializer.load("is_corotational", is_corotational);
-    if (is_corotational) {
-        mpCoordinateTransformation = Kratos::make_shared<ShellQ4_CorotationalCoordinateTransformation>(pGetGeometry());
-    } else {
-        mpCoordinateTransformation = Kratos::make_shared<ShellQ4_CoordinateTransformation>(pGetGeometry());
-    }
-    rSerializer.load("CTr", *mpCoordinateTransformation);
+    KRATOS_SERIALIZE_SAVE_BASE_CLASS(rSerializer, BaseShellElement);
+    rSerializer.load("CTr", mpCoordinateTransformation);
 }
 }
diff --git a/applications/StructuralMechanicsApplication/custom_elements/small_displacement_bbar.cpp b/applications/StructuralMechanicsApplication/custom_elements/small_displacement_bbar.cpp
index 46198c22f2..30fd23c285 100644
--- a/applications/StructuralMechanicsApplication/custom_elements/small_displacement_bbar.cpp
+++ b/applications/StructuralMechanicsApplication/custom_elements/small_displacement_bbar.cpp
@@ -984,6 +984,7 @@ int  SmallDisplacementBbar::Check( const ProcessInfo& rCurrentProcessInfo )
 
     void SmallDisplacementBbar::save(Serializer& rSerializer) const
     {
+        rSerializer.save("Name", "SmallDisplacementBbar");
         KRATOS_SERIALIZE_SAVE_BASE_CLASS(rSerializer, BaseSolidElement);
     }
 
diff --git a/applications/StructuralMechanicsApplication/custom_elements/solid_shell_element_sprism_3D6N.cpp b/applications/StructuralMechanicsApplication/custom_elements/solid_shell_element_sprism_3D6N.cpp
index d9f8ee4f0e..144f22c9f0 100644
--- a/applications/StructuralMechanicsApplication/custom_elements/solid_shell_element_sprism_3D6N.cpp
+++ b/applications/StructuralMechanicsApplication/custom_elements/solid_shell_element_sprism_3D6N.cpp
@@ -474,6 +474,62 @@ void SolidShellElementSprism3D6N::CalculateLocalSystem(
 /***********************************************************************************/
 /***********************************************************************************/
 
+void SolidShellElementSprism3D6N::CalculateLocalSystem(
+    std::vector< MatrixType >& rLeftHandSideMatrices,
+    const std::vector< Variable< MatrixType > >& rLHSVariables,
+    std::vector< VectorType >& rRightHandSideVectors,
+    const std::vector< Variable< VectorType > >& rRHSVariables,
+    ProcessInfo& rCurrentProcessInfo
+    )
+{
+    KRATOS_TRY;
+
+    /* Create local system components */
+    LocalSystemComponents local_system;
+
+    /* Calculation flags*/
+    local_system.CalculationFlags.Set(SolidShellElementSprism3D6N::COMPUTE_LHS_MATRIX_WITH_COMPONENTS);
+    local_system.CalculationFlags.Set(SolidShellElementSprism3D6N::COMPUTE_RHS_VECTOR_WITH_COMPONENTS);
+
+    /* Initialize sizes for the system components: */
+    if( rLHSVariables.size() != rLeftHandSideMatrices.size() ) {
+        rLeftHandSideMatrices.resize(rLHSVariables.size());
+    }
+
+    if( rRHSVariables.size() != rRightHandSideVectors.size() ) {
+        rRightHandSideVectors.resize(rRHSVariables.size());
+    }
+
+    local_system.CalculationFlags.Set(SolidShellElementSprism3D6N::COMPUTE_LHS_MATRIX);
+    for( IndexType i = 0; i < rLeftHandSideMatrices.size(); ++i ) {
+        this->InitializeSystemMatrices( rLeftHandSideMatrices[i], rRightHandSideVectors[0], local_system.CalculationFlags );
+    }
+
+    local_system.CalculationFlags.Set(SolidShellElementSprism3D6N::COMPUTE_RHS_VECTOR, true);
+    local_system.CalculationFlags.Set(SolidShellElementSprism3D6N::COMPUTE_LHS_MATRIX, false);
+
+    for( IndexType i = 0; i < rRightHandSideVectors.size(); ++i ) {
+        this->InitializeSystemMatrices( rLeftHandSideMatrices[0], rRightHandSideVectors[i], local_system.CalculationFlags );
+    }
+
+    local_system.CalculationFlags.Set(SolidShellElementSprism3D6N::COMPUTE_LHS_MATRIX, true);
+
+    /* Set general_variables to Local system components */
+    local_system.SetLeftHandSideMatrices(rLeftHandSideMatrices);
+    local_system.SetRightHandSideVectors(rRightHandSideVectors);
+
+    local_system.SetLeftHandSideVariables(rLHSVariables);
+    local_system.SetRightHandSideVariables(rRHSVariables);
+
+    /* Calculate elemental system */
+    CalculateElementalSystem( local_system, rCurrentProcessInfo );
+
+    KRATOS_CATCH("");
+}
+
+/***********************************************************************************/
+/***********************************************************************************/
+
 void SolidShellElementSprism3D6N::CalculateMassMatrix(
     MatrixType& rMassMatrix,
     ProcessInfo& rCurrentProcessInfo
@@ -2545,7 +2601,7 @@ void SolidShellElementSprism3D6N::CalculateJacobianAndInv(
 
     /* Compute inverse of the Jaccobian */
     double detJ;
-    MathUtils<double>::InvertMatrix(J, Jinv, detJ);
+    Jinv = MathUtils<double>::InvertMatrix<3>(J, detJ);
 }
 
 /***********************************************************************************/
@@ -2567,7 +2623,7 @@ void SolidShellElementSprism3D6N::CalculateJacobianAndInv(
 
     /* Compute inverse of the Jaccobian */
     double detJ;
-    MathUtils<double>::InvertMatrix(J, Jinv, detJ);
+    Jinv = MathUtils<double>::InvertMatrix<3>(J, detJ);
 }
 
 /***********************************************************************************/
@@ -2684,8 +2740,7 @@ void SolidShellElementSprism3D6N::CalculateCartesianDerOnGaussPlane(
 
     /* Compute the inverse of the Jacobian */
     double aux_det;
-    BoundedMatrix<double, 2, 2 > JinvPlane;
-    MathUtils<double>::InvertMatrix(jac, JinvPlane, aux_det);
+    const BoundedMatrix<double, 2, 2 > JinvPlane = MathUtils<double>::InvertMatrix<2>(jac, aux_det);
 
     /* Compute the Cartesian derivatives */
     noalias(InPlaneCartesianDerivativesGauss) = prod(JinvPlane, trans(local_derivative_patch));
@@ -3938,12 +3993,12 @@ void SolidShellElementSprism3D6N::CbartoFbar(
     const Matrix C_bar = MathUtils<double>::VectorToSymmetricTensor(rVariables.C);
 
     // Decompose matrix C_bar
-    MathUtils<double>::GaussSeidelEigenSystem(C_bar, eigen_vector_matrix, eigen_values_matrix, 1e-24, 100);
+    MathUtils<double>::EigenSystem<3>(C_bar, eigen_vector_matrix, eigen_values_matrix, 1e-24, 100);
 
     for (IndexType i = 0; i < 3; ++i)
         eigen_values_matrix(i, i) = std::sqrt(eigen_values_matrix(i, i));
 
-    const Matrix U_bar = prod( eigen_values_matrix, trans(eigen_vector_matrix));
+    const Matrix U_bar = prod( eigen_values_matrix, eigen_vector_matrix );
 
     /* Decompose F */
     Matrix F = ZeroMatrix(3, 3);
diff --git a/applications/StructuralMechanicsApplication/custom_elements/solid_shell_element_sprism_3D6N.h b/applications/StructuralMechanicsApplication/custom_elements/solid_shell_element_sprism_3D6N.h
index b995045fbd..bf408feec5 100644
--- a/applications/StructuralMechanicsApplication/custom_elements/solid_shell_element_sprism_3D6N.h
+++ b/applications/StructuralMechanicsApplication/custom_elements/solid_shell_element_sprism_3D6N.h
@@ -293,6 +293,23 @@ public:
         ProcessInfo& rCurrentProcessInfo
         ) override;
 
+     /**
+      * @brief This function provides a more general interface to the element.
+      * it is designed so that rLHSvariables and rRHSvariables are passed TO the element
+      * thus telling what is the desired output
+      * @param rLHSVariables paramter describing the expected LHSs
+      * @param rRightHandSideVectors container for the desired RHS output
+      * @param rRHSVariables parameter describing the expected RHSs
+      */
+
+     void CalculateLocalSystem(
+        std::vector< MatrixType >& rLeftHandSideMatrices,
+        const std::vector< Variable< MatrixType > >& rLHSVariables,
+        std::vector< VectorType >& rRightHandSideVectors,
+        const std::vector< Variable< VectorType > >& rRHSVariables,
+        ProcessInfo& rCurrentProcessInfo
+        ) override;
+
     /**
       * @brief This is called during the assembling process in order
       * to calculate the elemental mass matrix
diff --git a/applications/StructuralMechanicsApplication/custom_elements/total_lagrangian.cpp b/applications/StructuralMechanicsApplication/custom_elements/total_lagrangian.cpp
index eb99eb58e1..b7d1f2b302 100644
--- a/applications/StructuralMechanicsApplication/custom_elements/total_lagrangian.cpp
+++ b/applications/StructuralMechanicsApplication/custom_elements/total_lagrangian.cpp
@@ -459,7 +459,7 @@ void TotalLagrangian::CalculateShapeSensitivity(ShapeParameter Deriv,
     auto sensitivity_utility =
         GeometricalSensitivityUtility(J0, rDN_De);
     sensitivity_utility.CalculateSensitivity(Deriv, rDetJ0_Deriv, rDN_DX0_Deriv);
-    rF_Deriv.resize(ws_dim, ws_dim, false);
+    rF_Deriv.resize(ws_dim, ws_dim);
     rF_Deriv.clear();
     for (unsigned i = 0; i < ws_dim; ++i)
         for (unsigned j = 0; j < ws_dim; ++j)
@@ -540,12 +540,12 @@ void TotalLagrangian::CalculateSensitivityMatrix(
         const std::size_t ws_dim = r_geom.WorkingSpaceDimension();
         const std::size_t nnodes = r_geom.PointsNumber();
         const std::size_t mat_dim = nnodes * ws_dim;
-        rOutput.resize(mat_dim, mat_dim, false);
+        rOutput.resize(mat_dim, mat_dim);
         rOutput.clear();
         Matrix F, F_deriv, DN_DX0_deriv, strain_tensor_deriv, DN_DX0, B, B_deriv;
         Matrix M_deriv;
         const auto strain_size = GetStrainSize();
-        B.resize(strain_size, ws_dim * nnodes, false);
+        B.resize(strain_size, ws_dim * nnodes);
         Vector strain_vector_deriv(strain_size);
         Vector stress_vector(strain_size), stress_vector_deriv(strain_size);
         Vector residual_deriv(ws_dim * nnodes);
diff --git a/applications/StructuralMechanicsApplication/custom_elements/truss_element_3D2N.cpp b/applications/StructuralMechanicsApplication/custom_elements/truss_element_3D2N.cpp
index fa4d62e877..bb018eae6b 100644
--- a/applications/StructuralMechanicsApplication/custom_elements/truss_element_3D2N.cpp
+++ b/applications/StructuralMechanicsApplication/custom_elements/truss_element_3D2N.cpp
@@ -238,9 +238,19 @@ void TrussElement3D2N::GetSecondDerivativesVector(Vector &rValues, int Step) {
 void TrussElement3D2N::CalculateLocalSystem(MatrixType &rLeftHandSideMatrix,
                                             VectorType &rRightHandSideVector,
                                             ProcessInfo &rCurrentProcessInfo) {
-  KRATOS_TRY;
-  this->CalculateRightHandSide(rRightHandSideVector,rCurrentProcessInfo);
-  this->CalculateLeftHandSide(rLeftHandSideMatrix,rCurrentProcessInfo);
+
+  KRATOS_TRY
+  // calculate internal forces
+  BoundedVector<double, msLocalSize> internal_forces = ZeroVector(msLocalSize);
+  this->UpdateInternalForces(internal_forces);
+  // creating LHS
+  rLeftHandSideMatrix =
+      this->CreateElementStiffnessMatrix(rCurrentProcessInfo);
+
+  // create+compute RHS
+  rRightHandSideVector = -internal_forces;
+  // add bodyforces
+  if (this->HasSelfWeight()) noalias(rRightHandSideVector) += this->CalculateBodyForces();
   KRATOS_CATCH("")
 }
 
@@ -250,10 +260,14 @@ void TrussElement3D2N::CalculateRightHandSide(
   KRATOS_TRY
   rRightHandSideVector = ZeroVector(msLocalSize);
 
-  BoundedVector<double, msLocalSize> internal_forces = ZeroVector(msLocalSize);
-  this->UpdateInternalForces(internal_forces);
+  BoundedVector<double,msLocalSize> internal_forces =
+    this->GetConstitutiveLawTrialResponse(rCurrentProcessInfo,false);
 
-  noalias(rRightHandSideVector) -= internal_forces;
+  BoundedMatrix<double, msLocalSize, msLocalSize> transformation_matrix =
+      ZeroMatrix(msLocalSize, msLocalSize);
+  this->CreateTransformationMatrix(transformation_matrix);
+
+  noalias(rRightHandSideVector) -= prod(transformation_matrix, internal_forces);
 
   // add bodyforces
   if (this->HasSelfWeight()) noalias(rRightHandSideVector) += this->CalculateBodyForces();
@@ -263,7 +277,7 @@ void TrussElement3D2N::CalculateRightHandSide(
 void TrussElement3D2N::CalculateLeftHandSide(MatrixType &rLeftHandSideMatrix,
                                              ProcessInfo &rCurrentProcessInfo) {
 
-  KRATOS_TRY;
+  KRATOS_TRY
   // resizing the matrices + create memory for LHS
   rLeftHandSideMatrix = ZeroMatrix(msLocalSize, msLocalSize);
   // creating LHS
@@ -935,7 +949,7 @@ void TrussElement3D2N::CalculateLumpedMassVector(VectorType &rMassVector)
 
     // Clear matrix
     if (rMassVector.size() != msLocalSize)
-        rMassVector.resize(msLocalSize, false);
+        rMassVector.resize( msLocalSize );
 
     const double A = this->GetProperties()[CROSS_AREA];
     const double L = StructuralMechanicsElementUtilities::CalculateReferenceLength3D2N(*this);
diff --git a/applications/StructuralMechanicsApplication/custom_elements/truss_element_linear_3D2N.cpp b/applications/StructuralMechanicsApplication/custom_elements/truss_element_linear_3D2N.cpp
index 3d5a27fe5a..64fa335c57 100644
--- a/applications/StructuralMechanicsApplication/custom_elements/truss_element_linear_3D2N.cpp
+++ b/applications/StructuralMechanicsApplication/custom_elements/truss_element_linear_3D2N.cpp
@@ -65,6 +65,27 @@ TrussElementLinear3D2N::CreateElementStiffnessMatrix(
   KRATOS_CATCH("")
 }
 
+void TrussElementLinear3D2N::CalculateLocalSystem(
+    MatrixType &rLeftHandSideMatrix, VectorType &rRightHandSideVector,
+    ProcessInfo &rCurrentProcessInfo) {
+
+  KRATOS_TRY;
+  BoundedVector<double, msLocalSize> internal_forces = ZeroVector(msLocalSize);
+  this->UpdateInternalForces(internal_forces);
+
+  // resizing the matrices + create memory for LHS
+  rLeftHandSideMatrix = ZeroMatrix(msLocalSize, msLocalSize);
+  // creating LHS
+  rLeftHandSideMatrix = this->CreateElementStiffnessMatrix(rCurrentProcessInfo);
+
+  rRightHandSideVector = ZeroVector(msLocalSize);
+  noalias(rRightHandSideVector) -= internal_forces;
+  noalias(rRightHandSideVector) += this->CalculateBodyForces();
+  this->AddPrestressLinear(rRightHandSideVector);
+
+  KRATOS_CATCH("")
+}
+
 void TrussElementLinear3D2N::AddPrestressLinear(
     VectorType &rRightHandSideVector) {
   KRATOS_TRY;
@@ -92,11 +113,19 @@ void TrussElementLinear3D2N::CalculateRightHandSide(
   KRATOS_TRY
   rRightHandSideVector = ZeroVector(msLocalSize);
 
-  BoundedVector<double, msLocalSize> internal_forces = ZeroVector(msLocalSize);
-  this->UpdateInternalForces(internal_forces);
 
-  noalias(rRightHandSideVector) -= internal_forces;
+  BoundedVector<double,msLocalSize> internal_forces =
+    this->GetConstitutiveLawTrialResponse(rCurrentProcessInfo,false);
+
+  BoundedMatrix<double, msLocalSize, msLocalSize> transformation_matrix =
+      ZeroMatrix(msLocalSize, msLocalSize);
+  this->CreateTransformationMatrix(transformation_matrix);
+
+  internal_forces = prod(transformation_matrix, internal_forces);
 
+
+
+  rRightHandSideVector -= internal_forces;
   this->AddPrestressLinear(rRightHandSideVector);
 
   // add bodyforces
@@ -232,6 +261,14 @@ void TrussElementLinear3D2N::UpdateInternalForces(BoundedVector<double,msLocalSi
 }
 
 
+void TrussElementLinear3D2N::InitializeNonLinearIteration(ProcessInfo& rCurrentProcessInfo)
+{
+  KRATOS_TRY;
+  this->GetConstitutiveLawTrialResponse(rCurrentProcessInfo,true);
+  KRATOS_CATCH("");
+}
+
+
 BoundedVector<double,TrussElementLinear3D2N::msLocalSize>
   TrussElementLinear3D2N::GetConstitutiveLawTrialResponse(
    const ProcessInfo& rCurrentProcessInfo,const bool rSaveInternalVariables)
diff --git a/applications/StructuralMechanicsApplication/custom_elements/truss_element_linear_3D2N.hpp b/applications/StructuralMechanicsApplication/custom_elements/truss_element_linear_3D2N.hpp
index aed324d078..48bf52631b 100644
--- a/applications/StructuralMechanicsApplication/custom_elements/truss_element_linear_3D2N.hpp
+++ b/applications/StructuralMechanicsApplication/custom_elements/truss_element_linear_3D2N.hpp
@@ -74,6 +74,11 @@ namespace Kratos
         PropertiesType::Pointer pProperties
         ) const override;
 
+        void CalculateLocalSystem(
+            MatrixType& rLeftHandSideMatrix,
+            VectorType& rRightHandSideVector,
+            ProcessInfo& rCurrentProcessInfo) override;
+
         void CalculateRightHandSide(
             VectorType& rRightHandSideVector,
             ProcessInfo& rCurrentProcessInfo) override;
@@ -124,6 +129,10 @@ namespace Kratos
 		void UpdateInternalForces(
 			BoundedVector<double,msLocalSize>& rInternalForces) override;
 
+
+        void InitializeNonLinearIteration(ProcessInfo& rCurrentProcessInfo) override;
+
+
         /**
          * @brief This function calls the constitutive law to get stresses
          * @param rCurrentProcessInfo Current process info
diff --git a/applications/StructuralMechanicsApplication/custom_processes/postprocess_eigenvalues_process.cpp b/applications/StructuralMechanicsApplication/custom_processes/postprocess_eigenvalues_process.cpp
index c8871f5d08..3da194a2f2 100644
--- a/applications/StructuralMechanicsApplication/custom_processes/postprocess_eigenvalues_process.cpp
+++ b/applications/StructuralMechanicsApplication/custom_processes/postprocess_eigenvalues_process.cpp
@@ -88,8 +88,10 @@ namespace Kratos
         const auto& eigenvalue_vector = mrModelPart.GetProcessInfo()[EIGENVALUE_VECTOR];
         // Note: this is omega^2
         const SizeType num_eigenvalues = eigenvalue_vector.size();
-        const auto nodes_begin = mrModelPart.NodesBegin();
+
         const SizeType num_animation_steps = mOutputParameters["animation_steps"].GetInt();
+        double angle = 0.0;
+        std::string label = "";
 
         std::vector<Variable<double>> requested_double_results;
         std::vector<Variable<array_1d<double,3>>> requested_vector_results;
@@ -97,27 +99,27 @@ namespace Kratos
 
         gid_eigen_io.InitializeResults(0.0, mrModelPart.GetMesh());
 
-        for (SizeType i=0; i < num_animation_steps; ++i) {
-            const double cos_angle = std::cos(2 * Globals::Pi * i / num_animation_steps);
+        for (SizeType i=0; i < num_animation_steps; ++i)
+        {
+            angle = 2 * Globals::Pi * i / num_animation_steps;
 
-            for (SizeType j=0; j<num_eigenvalues; ++j) {
-                const std::string label = GetLabel(j, eigenvalue_vector[j]);
+            for(SizeType j=0; j<num_eigenvalues; ++j)
+            {
+                label = GetLabel(j, eigenvalue_vector[j]);
 
-                #pragma omp parallel for
-                for (int i=0; i<static_cast<int>(mrModelPart.NumberOfNodes()); ++i) {
+                for (auto& r_node : mrModelPart.Nodes()) {
                     // Copy the eigenvector to the Solutionstepvariable. Credit to Michael Andre
-                    DofsContainerType& r_node_dofs = (nodes_begin+i)->GetDofs();
-                    Matrix& r_node_eigenvectors = (nodes_begin+i)->GetValue(EIGENVECTOR_MATRIX);
+                    DofsContainerType& r_node_dofs = r_node.GetDofs();
+                    Matrix& r_node_eigenvectors = r_node.GetValue(EIGENVECTOR_MATRIX);
 
                     KRATOS_ERROR_IF_NOT(r_node_dofs.size() == r_node_eigenvectors.size2())
-                        << "Number of results on node " << (nodes_begin+i)->Id() << " is wrong" << std::endl;
+                        << "Number of results on node " << r_node.Id() << " is wrong" << std::endl;
 
                     SizeType k = 0;
-                    for (auto& r_dof : r_node_dofs) {
-                        r_dof.GetSolutionStepValue(0) = cos_angle * r_node_eigenvectors(j,k++);
-                    }
-                }
-
+                    for (auto& r_dof : r_node_dofs)
+                        r_dof.GetSolutionStepValue(0) = std::cos(angle) * r_node_eigenvectors(j,k++);
+                }     
+                
                 // Reconstruct the animation on slave-dofs
                 if (mrModelPart.NumberOfMasterSlaveConstraints() > 0) {
                     ConstraintUtilities::ResetSlaveDofs(mrModelPart);
diff --git a/applications/StructuralMechanicsApplication/custom_processes/spr_error_process.cpp b/applications/StructuralMechanicsApplication/custom_processes/spr_error_process.cpp
index 0021ae79a2..755c98c3c8 100644
--- a/applications/StructuralMechanicsApplication/custom_processes/spr_error_process.cpp
+++ b/applications/StructuralMechanicsApplication/custom_processes/spr_error_process.cpp
@@ -238,8 +238,7 @@ void SPRErrorProcess<TDim>::CalculatePatch(
     }
 
     double det;
-    BoundedMatrix<double, TDim + 1, TDim + 1> invA;
-    MathUtils<double>::InvertMatrix(A, invA, det, -1.0); // We consider a negative tolerance in order to avoid error
+    BoundedMatrix<double, TDim + 1, TDim + 1> invA = MathUtils<double>::InvertMatrix<TDim + 1>(A, det, -1.0); // We consider a negative tolerance in order to avoid error
 
     KRATOS_INFO_IF("SPRErrorProcess", mEchoLevel > 3) << A << std::endl << invA << std::endl << det<< std::endl;
 
@@ -251,7 +250,7 @@ void SPRErrorProcess<TDim>::CalculatePatch(
             for( IndexType j = 0; j < TDim + 1; j++)
                 A(i,j) += 0.001;
         }
-        MathUtils<double>::InvertMatrix(A, invA, det);
+        invA = MathUtils<double>::InvertMatrix<TDim + 1>(A,det);
         KRATOS_WARNING_IF("SPRErrorProcess", mEchoLevel > 0) << "det: " << det << std::endl;
     }
 
diff --git a/applications/StructuralMechanicsApplication/custom_python/add_custom_constitutive_laws_to_python.cpp b/applications/StructuralMechanicsApplication/custom_python/add_custom_constitutive_laws_to_python.cpp
index 6478e8d3ce..323e854d14 100644
--- a/applications/StructuralMechanicsApplication/custom_python/add_custom_constitutive_laws_to_python.cpp
+++ b/applications/StructuralMechanicsApplication/custom_python/add_custom_constitutive_laws_to_python.cpp
@@ -15,7 +15,7 @@
 // External includes
 
 // Project includes
-#include <custom_constitutive/small_strain_isotropic_damage_plane_strain_2d.h>
+#include <custom_constitutive/linear_isotropic_damage_plane_strain_2d.h>
 #include "custom_python/add_custom_constitutive_laws_to_python.h"
 
 // Elastic laws
@@ -35,7 +35,7 @@
 #include "custom_constitutive/linear_elastic_orthotropic_2D_law.h"
 #include "custom_constitutive/small_strain_j2_plasticity_3d.h"
 #include "custom_constitutive/small_strain_j2_plasticity_plane_strain_2d.h"
-#include "custom_constitutive/small_strain_isotropic_damage_3d.h"
+#include "custom_constitutive/linear_isotropic_damage_3D_law.h"
 
 // Plastic, damage laws and viscosities
 #include "custom_constitutive/small_strain_isotropic_plasticity_factory.h"
@@ -50,8 +50,6 @@
 #include "custom_constitutive/generic_small_strain_d_plus_d_minus_damage.h"
 #include "custom_constitutive/generic_small_strain_kinematic_plasticity.h"
 #include "custom_constitutive/plasticity_isotropic_kinematic_j2.h"
-#include "custom_constitutive/plane_stress_d_plus_d_minus_damage_masonry_2d.h"
-#include "custom_constitutive/d_plus_d_minus_damage_masonry_3d.h"
 
 // Integrators
 #include "custom_constitutive/constitutive_laws_integrators/generic_constitutive_law_integrator_damage.h"
@@ -150,12 +148,12 @@ void  AddCustomConstitutiveLawsToPython(pybind11::module& m)
     (m,"SmallStrainJ2Plasticity3DLaw").def(py::init<>())
     ;
 
-    py::class_< SmallStrainIsotropicDamagePlaneStrain2D, typename SmallStrainIsotropicDamagePlaneStrain2D::Pointer,  ConstitutiveLaw  >
-    (m,"SmallStrainIsotropicDamagePlaneStrain2DLaw").def(py::init<>())
+    py::class_< LinearIsotropicDamagePlaneStrain2D, typename LinearIsotropicDamagePlaneStrain2D::Pointer,  ConstitutiveLaw  >
+    (m,"LinearIsotropicDamagePlaneStrain2DLaw").def(py::init<>())
     ;
 
-    py::class_< SmallStrainIsotropicDamage3D, typename SmallStrainIsotropicDamage3D::Pointer,  ConstitutiveLaw  >
-    (m,"SmallStrainIsotropicDamage3DLaw").def(py::init<>())
+    py::class_< LinearIsotropicDamage3D, typename LinearIsotropicDamage3D::Pointer,  ConstitutiveLaw  >
+    (m,"LinearIsotropicDamage3DLaw").def(py::init<>())
     ;
 
     py::class_< PlasticityIsotropicKinematicJ2, typename PlasticityIsotropicKinematicJ2::Pointer,  ConstitutiveLaw >
@@ -1276,14 +1274,6 @@ void  AddCustomConstitutiveLawsToPython(pybind11::module& m)
     typename GenericSmallStrainDplusDminusDamage<GenericTensionConstitutiveLawIntegratorDplusDminusDamage<DruckerPragerYieldSurface<VonMisesPlasticPotential<3>>>, GenericCompressionConstitutiveLawIntegratorDplusDminusDamage<MohrCoulombYieldSurface<VonMisesPlasticPotential<3>>>>::Pointer,
     ConstitutiveLaw>(m, "SmallStrainDplusDminusDamageDruckerPragerMohrCoulomb2D").def(py::init<>())
     ;
-
-        py::class_< DamageDPlusDMinusMasonry2DLaw, typename DamageDPlusDMinusMasonry2DLaw::Pointer, ConstitutiveLaw >
-    (m, "DamageDPlusDMinusPlaneStressMasonry2DLaw").def(py::init<>())
-    ;
-
-		py::class_< DamageDPlusDMinusMasonry3DLaw, typename DamageDPlusDMinusMasonry3DLaw::Pointer, ConstitutiveLaw >
-	(m, "DamageDPlusDMinusMasonry3DLaw").def(py::init<>())
-	;
 }
 
 }  // namespace Python.
diff --git a/applications/StructuralMechanicsApplication/custom_python/add_custom_strategies_to_python.cpp b/applications/StructuralMechanicsApplication/custom_python/add_custom_strategies_to_python.cpp
index 4e33cedafc..1b6f5ba9df 100755
--- a/applications/StructuralMechanicsApplication/custom_python/add_custom_strategies_to_python.cpp
+++ b/applications/StructuralMechanicsApplication/custom_python/add_custom_strategies_to_python.cpp
@@ -30,6 +30,7 @@
 #include "custom_strategies/custom_schemes/residual_based_relaxation_scheme.hpp"
 #include "custom_strategies/custom_schemes/explicit_central_differences_scheme.hpp"
 #include "custom_strategies/custom_schemes/eigensolver_dynamic_scheme.hpp"
+#include "custom_response_functions/adjoint_schemes/adjoint_structural_static_scheme.h"
 
 // Convergence criterias
 #include "solving_strategies/convergencecriterias/convergence_criteria.h"
@@ -76,6 +77,7 @@ void  AddCustomStrategiesToPython(pybind11::module& m)
     typedef ResidualBasedRelaxationScheme< SparseSpaceType, LocalSpaceType >  ResidualBasedRelaxationSchemeType;
     typedef EigensolverDynamicScheme< SparseSpaceType, LocalSpaceType > EigensolverDynamicSchemeType;
     typedef ExplicitCentralDifferencesScheme< SparseSpaceType, LocalSpaceType >  ExplicitCentralDifferencesSchemeType;
+    typedef AdjointStructuralStaticScheme< SparseSpaceType, LocalSpaceType > AdjointStructuralStaticSchemeType;
 
 
     // Custom convergence criterion types
@@ -148,6 +150,9 @@ void  AddCustomStrategiesToPython(pybind11::module& m)
         .def(py::init< Parameters>())
         ;
 
+    py::class_<AdjointStructuralStaticSchemeType, AdjointStructuralStaticSchemeType::Pointer, BaseSchemeType>(m, "AdjointStructuralStaticScheme")
+        .def(py::init<Parameters, AdjointResponseFunction::Pointer>());
+
 
     //********************************************************************
     //*******************CONVERGENCE CRITERIA CLASSES*********************
diff --git a/applications/StructuralMechanicsApplication/custom_python/add_custom_utilities_to_python.cpp b/applications/StructuralMechanicsApplication/custom_python/add_custom_utilities_to_python.cpp
index 1336d053e9..392decd4d3 100644
--- a/applications/StructuralMechanicsApplication/custom_python/add_custom_utilities_to_python.cpp
+++ b/applications/StructuralMechanicsApplication/custom_python/add_custom_utilities_to_python.cpp
@@ -20,7 +20,6 @@
 #include "custom_utilities/formfinding_io_utility.h"
 #include "custom_utilities/rayleigh_damping_coefficients_utilities.h"
 #include "custom_utilities/explicit_integration_utilities.h"
-#include "custom_utilities/rve_periodicity_utility.h"
 
 namespace Kratos {
 namespace Python {
@@ -35,19 +34,12 @@ void  AddCustomUtilitiesToPython(pybind11::module& m)
         .def("ReadPrestressData",&FormfindingIOUtility::ReadPrestressData )
         .def("PrintPrestressData",&FormfindingIOUtility::PrintPrestressData )
         ;
-
+    
     // RayleighDampingCoefficientsUtilities
     m.def("ComputeDampingCoefficients",&RayleighDampingCoefficientsUtilities::ComputeDampingCoefficients);
-
+  
     // ExplicitIntegrationUtilities
     m.def("CalculateDeltaTime",&ExplicitIntegrationUtilities::CalculateDeltaTime);
-
-    py::class_<RVEPeriodicityUtility>(m,"RVEPeriodicityUtility")
-        .def(py::init<ModelPart&>())
-        .def(py::init<ModelPart&, std::size_t>())
-        .def("AssignPeriodicity",&RVEPeriodicityUtility::AssignPeriodicity)
-        .def("Finalize",&RVEPeriodicityUtility::Finalize)
-        ;
 }
 
 }  // namespace Python.
diff --git a/applications/StructuralMechanicsApplication/custom_python/structural_mechanics_python_application.cpp b/applications/StructuralMechanicsApplication/custom_python/structural_mechanics_python_application.cpp
index 2fafabfbed..ca9b0d4415 100644
--- a/applications/StructuralMechanicsApplication/custom_python/structural_mechanics_python_application.cpp
+++ b/applications/StructuralMechanicsApplication/custom_python/structural_mechanics_python_application.cpp
@@ -53,7 +53,6 @@ PYBIND11_MODULE(KratosStructuralMechanicsApplication,m)
     KRATOS_REGISTER_IN_PYTHON_VARIABLE(m, LOCAL_MATERIAL_AXIS_3 )
     KRATOS_REGISTER_IN_PYTHON_VARIABLE(m, CENTER_OF_GRAVITY )
     KRATOS_REGISTER_IN_PYTHON_VARIABLE(m, MASS_MOMENT_OF_INERTIA )
-    KRATOS_REGISTER_IN_PYTHON_VARIABLE(m, ELASTICITY_TENSOR )
 
     //registering variables in python
     // Generalized eigenvalue problem
@@ -254,19 +253,6 @@ PYBIND11_MODULE(KratosStructuralMechanicsApplication,m)
     KRATOS_REGISTER_IN_PYTHON_VARIABLE(m, EFFECTIVE_COMPRESSION_STRESS_VECTOR)
     KRATOS_REGISTER_IN_PYTHON_VARIABLE(m, EXPONENTIAL_SATURATION_YIELD_STRESS)
     KRATOS_REGISTER_IN_PYTHON_VARIABLE(m, ACCUMULATED_PLASTIC_STRAIN)
-    KRATOS_REGISTER_IN_PYTHON_VARIABLE(m, BACK_STRESS_VECTOR)
-    KRATOS_REGISTER_IN_PYTHON_VARIABLE(m, BACK_STRESS_TENSOR)
-
-    // D+D- Damage Constitutive laws variables, additional Masonry 2D & 3D
-    KRATOS_REGISTER_IN_PYTHON_VARIABLE(m, DAMAGE_ONSET_STRESS_COMPRESSION)
-    KRATOS_REGISTER_IN_PYTHON_VARIABLE(m, BIAXIAL_COMPRESSION_MULTIPLIER)
-    KRATOS_REGISTER_IN_PYTHON_VARIABLE(m, FRACTURE_ENERGY_TENSION)
-    KRATOS_REGISTER_IN_PYTHON_VARIABLE(m, RESIDUAL_STRESS_COMPRESSION)
-    KRATOS_REGISTER_IN_PYTHON_VARIABLE(m, BEZIER_CONTROLLER_C1)
-    KRATOS_REGISTER_IN_PYTHON_VARIABLE(m, BEZIER_CONTROLLER_C2)
-    KRATOS_REGISTER_IN_PYTHON_VARIABLE(m, BEZIER_CONTROLLER_C3)
-    KRATOS_REGISTER_IN_PYTHON_VARIABLE(m, YIELD_STRAIN_COMPRESSION)
-    KRATOS_REGISTER_IN_PYTHON_VARIABLE(m, TRIAXIAL_COMPRESSION_COEFFICIENT)
 
     // Adjoint Variables
     KRATOS_REGISTER_IN_PYTHON_3D_VARIABLE_WITH_COMPONENTS(m, ADJOINT_DISPLACEMENT)
diff --git a/applications/StructuralMechanicsApplication/custom_response_functions/adjoint_elements/adjoint_finite_difference_base_element.cpp b/applications/StructuralMechanicsApplication/custom_response_functions/adjoint_elements/adjoint_finite_difference_base_element.cpp
index ea5622f664..cc29ecefa5 100644
--- a/applications/StructuralMechanicsApplication/custom_response_functions/adjoint_elements/adjoint_finite_difference_base_element.cpp
+++ b/applications/StructuralMechanicsApplication/custom_response_functions/adjoint_elements/adjoint_finite_difference_base_element.cpp
@@ -313,7 +313,7 @@ void AdjointFiniteDifferencingBaseElement::CalculateSensitivityMatrix(const Vari
         Vector derived_RHS;
 
         if ( (rOutput.size1() != dimension * number_of_nodes) || (rOutput.size2() != local_size ) )
-            rOutput.resize(dimension * number_of_nodes, local_size, false);
+            rOutput.resize(dimension * number_of_nodes, local_size);
 
         IndexType index = 0;
 
@@ -357,9 +357,9 @@ void AdjointFiniteDifferencingBaseElement::CalculateStressDisplacementDerivative
         StressCalculation::CalculateStressOnGP(*pGetPrimalElement(), traced_stress_type, stress_derivatives_vector, rCurrentProcessInfo);
     else
         StressCalculation::CalculateStressOnNode(*pGetPrimalElement(), traced_stress_type, stress_derivatives_vector, rCurrentProcessInfo);
-    rOutput.resize(num_dofs, stress_derivatives_vector.size(), false);
+    rOutput.resize(num_dofs, stress_derivatives_vector.size() );
     rOutput.clear();
-    initial_state_variables.resize(num_dofs, false);
+    initial_state_variables.resize(num_dofs);
 
     // Build vector of variables containing the DOF-variables of the primal problem
     std::vector<VariableComponent<VectorComponentAdaptor<array_1d<double, 3>>>> primal_solution_variable_list;
@@ -440,7 +440,7 @@ void AdjointFiniteDifferencingBaseElement::CalculateStressDesignVariableDerivati
     const double delta = this->GetPerturbationSize(rDesignVariable);
 
     const SizeType stress_vector_size = stress_vector_undist.size();
-    rOutput.resize(1, stress_vector_size, false);
+    rOutput.resize(1, stress_vector_size);
 
     if( mpPrimalElement->GetProperties().Has(rDesignVariable) )
     {
@@ -501,7 +501,7 @@ void AdjointFiniteDifferencingBaseElement::CalculateStressDesignVariableDerivati
             StressCalculation::CalculateStressOnNode(*pGetPrimalElement(), traced_stress_type, stress_vector_undist, rCurrentProcessInfo);
 
         const SizeType stress_vector_size = stress_vector_undist.size();
-        rOutput.resize(dimension * number_of_nodes, stress_vector_size, false);
+        rOutput.resize(dimension * number_of_nodes, stress_vector_size);
 
         IndexType index = 0;
         //TODO: look that this works also for parallel computing
diff --git a/applications/StructuralMechanicsApplication/custom_response_functions/adjoint_schemes/adjoint_structural_static_scheme.h b/applications/StructuralMechanicsApplication/custom_response_functions/adjoint_schemes/adjoint_structural_static_scheme.h
new file mode 100644
index 0000000000..fe9e7912d2
--- /dev/null
+++ b/applications/StructuralMechanicsApplication/custom_response_functions/adjoint_schemes/adjoint_structural_static_scheme.h
@@ -0,0 +1,427 @@
+// KRATOS  ___|  |                   |                   |
+//       \___ \  __|  __| |   |  __| __| |   |  __| _` | |
+//             | |   |    |   | (    |   |   | |   (   | |
+//       _____/ \__|_|   \__,_|\___|\__|\__,_|_|  \__,_|_| MECHANICS
+//
+//  License:		 BSD License
+//					 license: structural_mechanics_application/license.txt
+//
+//  Main authors:    Martin Fusseder, https://github.com/MFusseder
+//
+
+#if !defined(KRATOS_ADJOINT_STRUCTURAL_STATIC_SCHEME)
+#define KRATOS_ADJOINT_STRUCTURAL_STATIC_SCHEME
+
+// System includes
+#include <vector>
+#include <string>
+
+// External includes
+
+// Project includes
+#include "includes/define.h"
+#include "includes/model_part.h"
+#include "includes/kratos_parameters.h"
+#include "utilities/openmp_utils.h"
+#include "solving_strategies/schemes/scheme.h"
+#include "containers/variable.h"
+#include "response_functions/adjoint_response_function.h"
+
+// Application includes
+
+namespace Kratos
+{
+///@addtogroup StructuralMechanicsApplication
+///@{
+
+///@name Kratos Classes
+///@{
+
+/// A scheme for for adjoint equations.
+/**
+ *
+ *
+ */
+template <class TSparseSpace, class TDenseSpace>
+class AdjointStructuralStaticScheme : public Scheme<TSparseSpace, TDenseSpace>
+{
+public:
+    ///@name Type Definitions
+    ///@{
+
+    KRATOS_CLASS_POINTER_DEFINITION(AdjointStructuralStaticScheme);
+
+    typedef Scheme<TSparseSpace, TDenseSpace> BaseType;
+
+    typedef typename BaseType::TSystemMatrixType SystemMatrixType;
+
+    typedef typename BaseType::TSystemVectorType SystemVectorType;
+
+    typedef typename BaseType::LocalSystemVectorType LocalSystemVectorType;
+
+    typedef typename BaseType::LocalSystemMatrixType LocalSystemMatrixType;
+
+    typedef typename BaseType::DofsArrayType DofsArrayType;
+
+    ///@}
+    ///@name Life Cycle
+    ///@{
+
+    /// Constructor.
+    AdjointStructuralStaticScheme(Parameters rParameters, AdjointResponseFunction::Pointer pResponseFunction)
+        : Scheme<TSparseSpace, TDenseSpace>()
+    {
+        KRATOS_TRY;
+
+        Parameters default_params(R"(
+        {
+            "scheme_type": "adjoint_structural",
+            "rotation_dofs": false
+        })");
+
+        rParameters.ValidateAndAssignDefaults(default_params);
+
+        mpResponseFunction = pResponseFunction;
+
+        mHasRotationDofs = rParameters["rotation_dofs"].GetBool();
+
+        KRATOS_CATCH("");
+    }
+
+    /// Destructor.
+    ~AdjointStructuralStaticScheme() override
+    {
+    }
+
+    ///@}
+    ///@name Operators
+    ///@{
+
+    ///@}
+    ///@name Operations
+    ///@{
+
+    void Initialize(ModelPart& rModelPart) override
+    {
+        KRATOS_TRY;
+
+        BaseType::Initialize(rModelPart);
+
+        // Allocate auxiliary memory
+        int num_threads = OpenMPUtils::GetNumThreads();
+        mAdjointValues.resize(num_threads);
+
+        mpResponseFunction->Initialize();
+
+        KRATOS_CATCH("");
+    }
+
+    void InitializeSolutionStep(ModelPart& rModelPart,
+                                SystemMatrixType& rA,
+                                SystemVectorType& rDx,
+                                SystemVectorType& rb) override
+    {
+        KRATOS_TRY;
+
+        // Sensitivities are generally computed as a time integral. For steady
+        // problems, we set the time step to -1.0 (minus because adjoint is
+        // backward in time).
+        rModelPart.GetProcessInfo()[DELTA_TIME] = -1.0;
+
+        BaseType::InitializeSolutionStep(rModelPart, rA, rDx, rb);
+
+        // initialize the variables to zero.
+        #pragma omp parallel for
+        for (int k = 0; k< static_cast<int> (rModelPart.Nodes().size()); ++k)
+        {
+            auto it_node = rModelPart.NodesBegin() + k;
+            noalias(it_node->FastGetSolutionStepValue(ADJOINT_DISPLACEMENT)) = ADJOINT_DISPLACEMENT.Zero();
+        }
+
+        if(mHasRotationDofs)
+        {
+            #pragma omp parallel for
+            for (int k = 0; k< static_cast<int> (rModelPart.Nodes().size()); ++k)
+            {
+                auto it_node = rModelPart.NodesBegin() + k;
+                noalias(it_node->FastGetSolutionStepValue(ADJOINT_ROTATION)) = ADJOINT_ROTATION.Zero();
+            }
+        }
+
+        mpResponseFunction->InitializeSolutionStep();
+
+        KRATOS_CATCH("");
+    }
+
+    void FinalizeSolutionStep(ModelPart& rModelPart,
+                              SystemMatrixType& rA,
+                              SystemVectorType& rDx,
+                              SystemVectorType& rb) override
+    {
+        KRATOS_TRY;
+
+        BaseType::FinalizeSolutionStep(rModelPart, rA, rDx, rb);
+
+        mpResponseFunction->FinalizeSolutionStep();
+
+        KRATOS_CATCH("");
+    }
+
+    /// Update adjoint.
+    void Update(ModelPart& rModelPart,
+                DofsArrayType& rDofSet,
+                SystemMatrixType& rA,
+                SystemVectorType& rDx,
+                SystemVectorType& rb) override
+    {
+        KRATOS_TRY;
+
+        Communicator& r_comm = rModelPart.GetCommunicator();
+
+        if (r_comm.TotalProcesses() == 1)
+        {
+            int ndofs = static_cast<int>(rDofSet.size());
+            #pragma omp parallel for
+            for (int i = 0; i < ndofs; ++i)
+            {
+                typename DofsArrayType::iterator it = rDofSet.begin() + i;
+                if (it->IsFree() == true)
+                    it->GetSolutionStepValue() +=
+                        TSparseSpace::GetValue(rDx, it->EquationId());
+            }
+        }
+        else
+        {
+            int ndofs = static_cast<int>(rDofSet.size());
+            #pragma omp parallel for
+            for (int i = 0; i < ndofs; ++i)
+            {
+                typename DofsArrayType::iterator it = rDofSet.begin() + i;
+                if (it->GetSolutionStepValue(PARTITION_INDEX) == r_comm.MyPID())
+                    if (it->IsFree() == true)
+                        it->GetSolutionStepValue() +=
+                            TSparseSpace::GetValue(rDx, it->EquationId());
+            }
+
+            // todo: add a function Communicator::SynchronizeDofVariables() to
+            // reduce communication here.
+            r_comm.SynchronizeNodalSolutionStepsData();
+        }
+
+        KRATOS_CATCH("");
+    }
+
+    int Check(ModelPart& rModelPart) override
+    {
+        KRATOS_TRY;
+
+        // check domain dimension and element
+        const unsigned int working_space_dimension =
+            rModelPart.Elements().begin()->GetGeometry().WorkingSpaceDimension();
+
+        ProcessInfo& r_current_process_info = rModelPart.GetProcessInfo();
+        const unsigned int domain_size =
+            static_cast<unsigned int>(r_current_process_info[DOMAIN_SIZE]);
+        KRATOS_ERROR_IF(domain_size != 2 && domain_size != 3) << "Invalid DOMAIN_SIZE: " << domain_size << std::endl;
+        KRATOS_ERROR_IF(domain_size != working_space_dimension) << "DOMAIN_SIZE != WorkingSpaceDimension()" << std::endl;
+
+        for(auto& rnode : rModelPart.Nodes())
+           KRATOS_CHECK_VARIABLE_IN_NODAL_DATA(ADJOINT_DISPLACEMENT, rnode)
+        if(mHasRotationDofs)
+        {
+            for(auto& rnode : rModelPart.Nodes())
+                KRATOS_CHECK_VARIABLE_IN_NODAL_DATA(ADJOINT_ROTATION, rnode)
+        }
+
+        return BaseType::Check(rModelPart); // check elements and conditions
+        KRATOS_CATCH("");
+    }
+
+    /// Calculate residual based element contributions to steady adjoint.
+    void CalculateSystemContributions(Element::Pointer pCurrentElement,
+                                      LocalSystemMatrixType& rLHS_Contribution,
+                                      LocalSystemVectorType& rRHS_Contribution,
+                                      Element::EquationIdVectorType& rEquationId,
+                                      ProcessInfo& rCurrentProcessInfo) override
+    {
+        KRATOS_TRY;
+
+        int thread_id = OpenMPUtils::ThisThread();
+
+        // Get element stiffness matrix
+        pCurrentElement->CalculateLeftHandSide(rLHS_Contribution, rCurrentProcessInfo);
+
+        if (rRHS_Contribution.size() != rLHS_Contribution.size1())
+            rRHS_Contribution.resize(rLHS_Contribution.size1(), false);
+
+        // Calculate transposed gradient of response function on element w.r.t. primal solution
+        mpResponseFunction->CalculateGradient(
+            *pCurrentElement, rLHS_Contribution, rRHS_Contribution, rCurrentProcessInfo);
+
+        noalias(rRHS_Contribution) = -rRHS_Contribution;
+
+        // Calculate system contributions in residual form.
+        pCurrentElement->GetValuesVector(mAdjointValues[thread_id]);
+        noalias(rRHS_Contribution) -= prod(rLHS_Contribution, mAdjointValues[thread_id]);
+
+        pCurrentElement->EquationIdVector(rEquationId, rCurrentProcessInfo);
+
+        KRATOS_CATCH("");
+    }
+
+    void Calculate_LHS_Contribution(Element::Pointer pCurrentElement,
+                                    LocalSystemMatrixType& rLHS_Contribution,
+                                    Element::EquationIdVectorType& rEquationId,
+                                    ProcessInfo& rCurrentProcessInfo) override
+    {
+        KRATOS_TRY;
+
+        LocalSystemVectorType RHS_contribution;
+
+        RHS_contribution.resize(rLHS_Contribution.size1(), false);
+
+        CalculateSystemContributions(
+            pCurrentElement, rLHS_Contribution, RHS_contribution, rEquationId, rCurrentProcessInfo);
+
+        KRATOS_CATCH("");
+    }
+
+    void Condition_CalculateSystemContributions(Condition::Pointer pCurrentCondition,
+                                                 LocalSystemMatrixType& rLHS_Contribution,
+                                                 LocalSystemVectorType& rRHS_Contribution,
+                                                 Condition::EquationIdVectorType& rEquationId,
+                                                 ProcessInfo& rCurrentProcessInfo) override
+    {
+        KRATOS_TRY;
+
+        int thread_id = OpenMPUtils::ThisThread();
+
+        // Calculate transposed gradient of condition residual w.r.t. primal solution.
+        pCurrentCondition->CalculateLeftHandSide(rLHS_Contribution, rCurrentProcessInfo);
+
+        if (rRHS_Contribution.size() != rLHS_Contribution.size1())
+             rRHS_Contribution.resize(rLHS_Contribution.size1(), false);
+
+        // Calculate transposed gradient of response function on condition w.r.t. primal solution.
+        mpResponseFunction->CalculateGradient(
+             *pCurrentCondition, rLHS_Contribution, rRHS_Contribution, rCurrentProcessInfo);
+
+        noalias(rRHS_Contribution) = -rRHS_Contribution;
+
+        // Calculate system contributions in residual form.
+        pCurrentCondition->GetValuesVector(mAdjointValues[thread_id]);
+        noalias(rRHS_Contribution) -= prod(rLHS_Contribution, mAdjointValues[thread_id]);
+
+        pCurrentCondition->EquationIdVector(rEquationId, rCurrentProcessInfo);
+
+        KRATOS_CATCH("");
+    }
+
+    void Condition_Calculate_LHS_Contribution(Condition::Pointer pCurrentCondition,
+                                               LocalSystemMatrixType& rLHS_Contribution,
+                                               Condition::EquationIdVectorType& rEquationId,
+                                               ProcessInfo& rCurrentProcessInfo) override
+    {
+        KRATOS_TRY;
+        LocalSystemVectorType RHS_contribution;
+
+        RHS_contribution.resize(rLHS_Contribution.size1(), false);
+
+        Condition_CalculateSystemContributions(
+             pCurrentCondition, rLHS_Contribution, RHS_contribution, rEquationId, rCurrentProcessInfo);
+
+        KRATOS_CATCH("");
+    }
+
+    ///@}
+    ///@name Access
+    ///@{
+
+    ///@}
+    ///@name Inquiry
+    ///@{
+
+    ///@}
+    ///@name Friends
+    ///@{
+
+    ///@}
+
+protected:
+    ///@name Protected static Member Variables
+    ///@{
+
+    ///@}
+    ///@name Protected member Variables
+    ///@{
+
+    ///@}
+    ///@name Protected Operators
+    ///@{
+
+    ///@}
+    ///@name Protected Operations
+    ///@{
+
+    ///@}
+    ///@name Protected  Access
+    ///@{
+
+    ///@}
+    ///@name Protected Inquiry
+    ///@{
+
+    ///@}
+    ///@name Protected LifeCycle
+    ///@{
+
+    ///@}
+
+private:
+    ///@name Static Member Variables
+    ///@{
+
+    ///@}
+    ///@name Member Variables
+    ///@{
+
+    AdjointResponseFunction::Pointer mpResponseFunction;
+    std::vector<LocalSystemVectorType> mAdjointValues;
+    bool mHasRotationDofs;
+
+    ///@}
+    ///@name Private Operators
+    ///@{
+
+    ///@}
+    ///@name Private Operations
+    ///@{
+
+    ///@}
+    ///@name Private  Access
+    ///@{
+
+    ///@}
+    ///@name Private Inquiry
+    ///@{
+
+    ///@}
+    ///@name Un accessible methods
+    ///@{
+
+    ///@}
+
+}; /* Class Scheme */
+
+///@}
+
+///@name Type Definitions
+///@{
+
+///@}
+
+///@} // Structural Mechanics Application group
+
+} /* namespace Kratos.*/
+
+#endif /* KRATOS_ADJOINT_STRUCTURAL_STATIC_SCHEME defined */
diff --git a/applications/StructuralMechanicsApplication/custom_response_functions/response_utilities/adjoint_local_stress_response_function.h b/applications/StructuralMechanicsApplication/custom_response_functions/response_utilities/adjoint_local_stress_response_function.h
index cbb9defd94..c9f212caa3 100644
--- a/applications/StructuralMechanicsApplication/custom_response_functions/response_utilities/adjoint_local_stress_response_function.h
+++ b/applications/StructuralMechanicsApplication/custom_response_functions/response_utilities/adjoint_local_stress_response_function.h
@@ -78,8 +78,6 @@ public:
     ///@name Operations
     ///@{
 
-    using AdjointStructuralResponseFunction::CalculateGradient;
-
     void CalculateGradient(const Element& rAdjointElement,
                                    const Matrix& rResidualGradient,
                                    Vector& rResponseGradient,
diff --git a/applications/StructuralMechanicsApplication/custom_response_functions/response_utilities/adjoint_nodal_displacement_response_function.cpp b/applications/StructuralMechanicsApplication/custom_response_functions/response_utilities/adjoint_nodal_displacement_response_function.cpp
index 51a5621b4b..6520f0ce04 100644
--- a/applications/StructuralMechanicsApplication/custom_response_functions/response_utilities/adjoint_nodal_displacement_response_function.cpp
+++ b/applications/StructuralMechanicsApplication/custom_response_functions/response_utilities/adjoint_nodal_displacement_response_function.cpp
@@ -182,7 +182,7 @@ namespace Kratos
         const VariableComponentType& r_traced_dof =
             KratosComponents<VariableComponentType>::Get(mTracedDofLabel);
 
-        return rModelPart.GetNode(mpTracedNode->Id()).FastGetSolutionStepValue(r_traced_dof, 0);
+        return mpTracedNode->FastGetSolutionStepValue(r_traced_dof, 0);
 
         KRATOS_CATCH("");
     }
diff --git a/applications/StructuralMechanicsApplication/custom_response_functions/response_utilities/adjoint_nodal_displacement_response_function.h b/applications/StructuralMechanicsApplication/custom_response_functions/response_utilities/adjoint_nodal_displacement_response_function.h
index 3b0e0690d3..64e3cf029c 100644
--- a/applications/StructuralMechanicsApplication/custom_response_functions/response_utilities/adjoint_nodal_displacement_response_function.h
+++ b/applications/StructuralMechanicsApplication/custom_response_functions/response_utilities/adjoint_nodal_displacement_response_function.h
@@ -81,13 +81,11 @@ public:
     ///@name Operations
     ///@{
 
-    using AdjointStructuralResponseFunction::CalculateGradient;
-
     void CalculateGradient(const Element& rAdjointElement,
                                    const Matrix& rResidualGradient,
                                    Vector& rResponseGradient,
                                    const ProcessInfo& rProcessInfo) override;
-
+    
     void CalculateFirstDerivativesGradient(const Element& rAdjointElement,
                                            const Matrix& rResidualGradient,
                                            Vector& rResponseGradient,
diff --git a/applications/StructuralMechanicsApplication/custom_response_functions/response_utilities/adjoint_structural_response_function.h b/applications/StructuralMechanicsApplication/custom_response_functions/response_utilities/adjoint_structural_response_function.h
index 01049e2fa5..758d39b156 100644
--- a/applications/StructuralMechanicsApplication/custom_response_functions/response_utilities/adjoint_structural_response_function.h
+++ b/applications/StructuralMechanicsApplication/custom_response_functions/response_utilities/adjoint_structural_response_function.h
@@ -59,7 +59,7 @@ public:
     AdjointStructuralResponseFunction(ModelPart& rModelPart, Parameters ResponseSettings);
 
     /// Destructor.
-    virtual ~AdjointStructuralResponseFunction() override
+     ~AdjointStructuralResponseFunction() override
     {
     }
 
@@ -71,16 +71,14 @@ public:
     ///@name Operations
     ///@{
 
-    virtual void Initialize() override;
+    void Initialize() override;
 
-    using AdjointResponseFunction::CalculateGradient;
-
-    virtual void CalculateGradient(const Condition& rAdjointCondition,
+    void CalculateGradient(const Condition& rAdjointCondition,
                                    const Matrix& rResidualGradient,
                                    Vector& rResponseGradient,
                                    const ProcessInfo& rProcessInfo) override;
 
-    virtual double CalculateValue(ModelPart& rModelPart) override;
+    double CalculateValue(ModelPart& rModelPart) override;
 
     ///@}
 
diff --git a/applications/StructuralMechanicsApplication/custom_response_functions/response_utilities/element_finite_difference_utility.cpp b/applications/StructuralMechanicsApplication/custom_response_functions/response_utilities/element_finite_difference_utility.cpp
index 3791504dcc..627e5ab240 100644
--- a/applications/StructuralMechanicsApplication/custom_response_functions/response_utilities/element_finite_difference_utility.cpp
+++ b/applications/StructuralMechanicsApplication/custom_response_functions/response_utilities/element_finite_difference_utility.cpp
@@ -37,7 +37,7 @@ namespace Kratos
             Vector RHS_perturbed;
 
             if ( (rOutput.size1() != 1) || (rOutput.size2() != rRHS.size() ) )
-                rOutput.resize(1, rRHS.size(), false);
+                rOutput.resize(1, rRHS.size());
 
             // Save property pointer
             Properties::Pointer p_global_properties = rElement.pGetProperties();
@@ -141,7 +141,7 @@ namespace Kratos
                 Vector dummy;
 
                 if ( (rOutput.size1() != rLHS.size1()) || (rOutput.size2() != rLHS.size2() ) )
-                    rOutput.resize(rLHS.size1(), rLHS.size2(), false);
+                    rOutput.resize(rLHS.size1(), rLHS.size2());
 
                 // perturb the design variable
                 rNode.GetInitialPosition()[coord_dir] += rPertubationSize;
@@ -191,7 +191,7 @@ namespace Kratos
                 Matrix perturbed_mass_matrix;
 
                 if ( (rOutput.size1() != rMassMatrix.size1()) || (rOutput.size2() != rMassMatrix.size2() ) )
-                    rOutput.resize(rMassMatrix.size1(), rMassMatrix.size2(), false);
+                    rOutput.resize(rMassMatrix.size1(), rMassMatrix.size2());
 
                 // perturb the design variable
                 rNode.GetInitialPosition()[coord_dir] += rPertubationSize;
diff --git a/applications/StructuralMechanicsApplication/custom_response_functions/response_utilities/stress_response_definitions.cpp b/applications/StructuralMechanicsApplication/custom_response_functions/response_utilities/stress_response_definitions.cpp
index f5f18fe532..5dd54ac0a5 100644
--- a/applications/StructuralMechanicsApplication/custom_response_functions/response_utilities/stress_response_definitions.cpp
+++ b/applications/StructuralMechanicsApplication/custom_response_functions/response_utilities/stress_response_definitions.cpp
@@ -348,7 +348,7 @@ void StressCalculation::CalculateStressOnGPShell(Element& rElement,
     else
         rElement.CalculateOnIntegrationPoints(SHELL_FORCE_GLOBAL, stress_vector, rCurrentProcessInfo);
 
-    rOutput.resize(num_gps, false);
+    rOutput.resize(num_gps);
     for(IndexType i = 0; i < num_gps; i++)
     {
         rOutput(i) = stress_vector[i](direction_1, direction_2);
@@ -427,7 +427,7 @@ void StressCalculation::CalculateStressOnGPBeam(Element& rElement,
 
     const SizeType GP_num = rElement.GetGeometry().IntegrationPointsNumber(Kratos::GeometryData::GI_GAUSS_3);
 
-    rOutput.resize(GP_num, false);
+    rOutput.resize(GP_num);
     for(IndexType i = 0; i < GP_num ; i++)
     {
         rOutput(i) = stress_vector[i][direction_1];
@@ -449,7 +449,7 @@ void StressCalculation::CalculateStressOnNodeBeam(Element& rElement,
                                             stress_vector, rCurrentProcessInfo,
                                             direction_1);
 
-    rOutput.resize(2, false);
+    rOutput.resize(2);
     rOutput(0) = 2 * stress_vector[0][direction_1] - stress_vector[1][direction_1];
     rOutput(1) = 2 * stress_vector[2][direction_1] - stress_vector[1][direction_1];
 
diff --git a/applications/StructuralMechanicsApplication/custom_strategies/custom_schemes/explicit_central_differences_scheme.hpp b/applications/StructuralMechanicsApplication/custom_strategies/custom_schemes/explicit_central_differences_scheme.hpp
index 6dac609900..68d77eaf4e 100644
--- a/applications/StructuralMechanicsApplication/custom_strategies/custom_schemes/explicit_central_differences_scheme.hpp
+++ b/applications/StructuralMechanicsApplication/custom_strategies/custom_schemes/explicit_central_differences_scheme.hpp
@@ -128,7 +128,7 @@ public:
         {
             "time_step_prediction_level" : 0.0,
             "fraction_delta_time"        : 0.9,
-            "max_delta_time"             : 1.0e0
+            "max_delta_time"             : 1.0e-5
         })" );
 
         rParameters.ValidateAndAssignDefaults(default_parameters);
@@ -181,8 +181,8 @@ public:
             Parameters prediction_parameters = Parameters(R"(
             {
                 "time_step_prediction_level" : 2.0,
-                "max_delta_time"             : 1.0e0,
-                "safety_factor"              : 0.8
+                "max_delta_time"             : 1.0e-3,
+                "safety_factor"              : 0.5
             })" );
             prediction_parameters["time_step_prediction_level"].SetDouble(mDeltaTime.PredictionLevel);
             prediction_parameters["max_delta_time"].SetDouble(mDeltaTime.Maximum);
@@ -235,8 +235,8 @@ public:
             Parameters prediction_parameters = Parameters(R"(
             {
                 "time_step_prediction_level" : 2.0,
-                "max_delta_time"             : 1.0e0,
-                "safety_factor"              : 0.8
+                "max_delta_time"             : 1.0e-3,
+                "safety_factor"              : 0.5
             })" );
             prediction_parameters["time_step_prediction_level"].SetDouble(mDeltaTime.PredictionLevel); // WARNING This could be problematic if PredictionLevel is a double and not a integer
             prediction_parameters["max_delta_time"].SetDouble(mDeltaTime.Maximum);
@@ -267,14 +267,14 @@ public:
         ProcessInfo& r_current_process_info = rModelPart.GetProcessInfo();
 
         const auto it_elem_begin = rModelPart.ElementsBegin();
-        #pragma omp parallel for schedule(guided,512)
+        #pragma omp parallel for
         for(int i=0; i<static_cast<int>(rModelPart.Elements().size()); ++i) {
             auto it_elem = it_elem_begin + i;
             it_elem->InitializeNonLinearIteration(r_current_process_info);
         }
 
         const auto it_cond_begin = rModelPart.ConditionsBegin();
-        #pragma omp parallel for schedule(guided,512)
+        #pragma omp parallel for
         for(int i=0; i<static_cast<int>(rModelPart.Conditions().size()); ++i) {
             auto it_elem = it_cond_begin + i;
             it_elem->InitializeNonLinearIteration(r_current_process_info);
@@ -321,33 +321,31 @@ public:
         NodesArrayType& r_nodes = rModelPart.Nodes();
 
         // The first iterator of the array of nodes
-        const auto it_node_begin = rModelPart.NodesBegin();
+        const auto it_begin_node = rModelPart.NodesBegin();
 
         /// Initialise the database of the nodes
         const array_1d<double, 3> zero_array = ZeroVector(3);
-        #pragma omp parallel for schedule(guided,512)
+        #pragma omp parallel for
         for (int i = 0; i < static_cast<int>(r_nodes.size()); ++i) {
-            auto it_node = (it_node_begin + i);
+            auto it_node = (it_begin_node + i);
             it_node->SetValue(NODAL_MASS, 0.0);
-            array_1d<double, 3>& r_middle_velocity = it_node->FastGetSolutionStepValue(MIDDLE_VELOCITY);
-            r_middle_velocity  = ZeroVector(3);
+            it_node->SetValue(MIDDLE_VELOCITY, zero_array);
         }
-        const bool has_dof_for_rot_z = it_node_begin->HasDofFor(ROTATION_Z);
+        const bool has_dof_for_rot_z = it_begin_node->HasDofFor(ROTATION_Z);
         if (has_dof_for_rot_z) {
-            #pragma omp parallel for schedule(guided,512)
+            #pragma omp parallel for
             for (int i = 0; i < static_cast<int>(r_nodes.size()); ++i) {
-                auto it_node = (it_node_begin + i);
+                auto it_node = (it_begin_node + i);
+                it_node->SetValue(MIDDLE_ANGULAR_VELOCITY, zero_array);
                 it_node->SetValue(NODAL_INERTIA, zero_array);
-                array_1d<double, 3>& r_middle_angular_velocity = it_node->FastGetSolutionStepValue(MIDDLE_ANGULAR_VELOCITY);
-                r_middle_angular_velocity  = ZeroVector(3);
             }
         }
 
-        #pragma omp parallel for schedule(guided,512)
+        #pragma omp parallel for
         for (int i = 0; i < static_cast<int>(r_nodes.size()); ++i) {
-            auto it_node = (it_node_begin + i);
+            auto it_node = (it_begin_node + i);
 
-            array_1d<double, 3>& r_middle_velocity = it_node->FastGetSolutionStepValue(MIDDLE_VELOCITY);
+            array_1d<double, 3>& r_middle_velocity = it_node->GetValue(MIDDLE_VELOCITY);
             const array_1d<double, 3>& r_current_velocity = it_node->FastGetSolutionStepValue(VELOCITY);
             array_1d<double, 3>& r_current_residual = it_node->FastGetSolutionStepValue(FORCE_RESIDUAL);
 //             array_1d<double,3>& r_current_displacement  = it_node->FastGetSolutionStepValue(DISPLACEMENT);
@@ -359,7 +357,7 @@ public:
             }
 
             if (has_dof_for_rot_z) {
-                array_1d<double, 3>& r_middle_angular_velocity = it_node->FastGetSolutionStepValue(MIDDLE_ANGULAR_VELOCITY);
+                array_1d<double, 3>& r_middle_angular_velocity = it_node->GetValue(MIDDLE_ANGULAR_VELOCITY);
                 const array_1d<double, 3>& r_current_angular_velocity = it_node->FastGetSolutionStepValue(ANGULAR_VELOCITY);
                 array_1d<double, 3>& r_current_residual_moment = it_node->FastGetSolutionStepValue(MOMENT_RESIDUAL);
 //                 array_1d<double,3>& current_rotation = it_node->FastGetSolutionStepValue(ROTATION);
@@ -408,33 +406,31 @@ public:
         mTime.Current = r_current_process_info[TIME];
         mTime.Delta = r_current_process_info[DELTA_TIME];
 
-        mTime.Middle   = mTime.Current - 0.50*mTime.Delta;
-        mTime.Previous = mTime.Current - 1.00*mTime.Delta;
-        mTime.PreviousMiddle = mTime.Middle - 1.00*mTime.Delta;
+        mTime.Middle = 0.5 * (mTime.Previous + mTime.Current);
 
-        if (mTime.Previous<0.0) mTime.Previous=0.00;
-        if (mTime.PreviousMiddle<0.0) mTime.PreviousMiddle=0.00;
         // The iterator of the first node
-        const auto it_node_begin = rModelPart.NodesBegin();
-        const bool has_dof_for_rot_z = it_node_begin->HasDofFor(ROTATION_Z);
+        const auto it_begin_node = rModelPart.NodesBegin();
+        const bool has_dof_for_rot_z = it_begin_node->HasDofFor(ROTATION_Z);
 
         // Getting dof position
-        const IndexType disppos = it_node_begin->GetDofPosition(DISPLACEMENT_X);
-        const IndexType rotppos = has_dof_for_rot_z ? it_node_begin->GetDofPosition(ROTATION_X) : 0;
+        const IndexType disppos = it_begin_node->GetDofPosition(DISPLACEMENT_X);
+        const IndexType rotppos = has_dof_for_rot_z ? it_begin_node->GetDofPosition(ROTATION_X) : 0;
 
-        #pragma omp parallel for schedule(guided,512)
+        #pragma omp parallel for
         for (int i = 0; i < static_cast<int>(r_nodes.size()); ++i) {
             // Current step information "N+1" (before step update).
-            this->UpdateTranslationalDegreesOfFreedom(it_node_begin + i, disppos, dim);
+            this->UpdateTranslationalDegreesOfFreedom(it_begin_node + i, disppos, dim);
         } // for Node parallel
 
         if (has_dof_for_rot_z){
-            #pragma omp parallel for schedule(guided,512)
+            #pragma omp parallel for
             for (int i = 0; i < static_cast<int>(r_nodes.size()); ++i) {
-                this->UpdateRotationalDegreesOfFreedom(it_node_begin + i, rotppos, dim);
+                this->UpdateRotationalDegreesOfFreedom(it_begin_node + i, rotppos, dim);
             } // for Node parallel
         }
 
+        mTime.Previous = mTime.Current;
+        mTime.PreviousMiddle = mTime.Middle;
 
         KRATOS_CATCH("")
     }
@@ -457,12 +453,10 @@ public:
 
         array_1d<double, 3>& r_current_velocity = itCurrentNode->FastGetSolutionStepValue(VELOCITY);
         array_1d<double, 3>& r_current_displacement = itCurrentNode->FastGetSolutionStepValue(DISPLACEMENT);
-        array_1d<double, 3>& r_middle_velocity = itCurrentNode->FastGetSolutionStepValue(MIDDLE_VELOCITY);
+        array_1d<double, 3>& r_middle_velocity = itCurrentNode->GetValue(MIDDLE_VELOCITY);
 
         array_1d<double, 3>& r_current_acceleration = itCurrentNode->FastGetSolutionStepValue(ACCELERATION);
 
-        const array_1d<double, 3>& r_previous_displacement = itCurrentNode->FastGetSolutionStepValue(DISPLACEMENT, 1);
-        const array_1d<double, 3>& r_previous_middle_velocity = itCurrentNode->FastGetSolutionStepValue(MIDDLE_VELOCITY, 1);
         // Solution of the explicit equation:
         if (nodal_mass > numerical_limit)
             noalias(r_current_acceleration) = (r_current_residual - nodal_displacement_damping * r_current_velocity) / nodal_mass;
@@ -482,9 +476,9 @@ public:
                 r_middle_velocity[j] = 0.0;
             }
 
-            r_current_velocity[j] =  r_previous_middle_velocity[j] + (mTime.Previous - mTime.PreviousMiddle) * r_current_acceleration[j]; //+ actual_velocity;
+            r_current_velocity[j] =  r_middle_velocity[j] + (mTime.Previous - mTime.PreviousMiddle) * r_current_acceleration[j]; //+ actual_velocity;
             r_middle_velocity[j] = r_current_velocity[j] + (mTime.Middle - mTime.Previous) * r_current_acceleration[j];
-            r_current_displacement[j] = r_previous_displacement[j] + mTime.Delta * r_middle_velocity[j];
+            r_current_displacement[j] = r_current_displacement[j] + mTime.Delta * r_middle_velocity[j];
         } // for DomainSize
     }
 
@@ -506,13 +500,9 @@ public:
         const array_1d<double, 3>& r_current_residual_moment = itCurrentNode->FastGetSolutionStepValue(MOMENT_RESIDUAL);
         array_1d<double, 3>& r_current_angular_velocity = itCurrentNode->FastGetSolutionStepValue(ANGULAR_VELOCITY);
         array_1d<double, 3>& r_current_rotation = itCurrentNode->FastGetSolutionStepValue(ROTATION);
-        array_1d<double, 3>& r_middle_angular_velocity = itCurrentNode->FastGetSolutionStepValue(MIDDLE_ANGULAR_VELOCITY);
+        array_1d<double, 3>& r_middle_angular_velocity = itCurrentNode->GetValue(MIDDLE_ANGULAR_VELOCITY);
         array_1d<double, 3>& r_current_angular_acceleration = itCurrentNode->FastGetSolutionStepValue(ANGULAR_ACCELERATION);
 
-
-        const array_1d<double, 3>& r_previous_rotation = itCurrentNode->FastGetSolutionStepValue(ROTATION, 1);
-        const array_1d<double, 3>& r_previous_middle_angular_velocity = itCurrentNode->FastGetSolutionStepValue(MIDDLE_ANGULAR_VELOCITY, 1);
-
         const IndexType initial_k = DomainSize == 3 ? 0 : 2; // We do this because in 2D only the rotation Z is needed, then we start with 2, instead of 0
         for (IndexType kk = initial_k; kk < 3; ++kk) {
             if (nodal_inertia[kk] > numerical_limit)
@@ -533,9 +523,9 @@ public:
                 r_current_angular_acceleration[j] = 0.0;
                 r_middle_angular_velocity[j] = 0.0;
             }
-            r_current_angular_velocity[j] = r_previous_middle_angular_velocity[j] + (mTime.Previous - mTime.PreviousMiddle) * r_current_angular_acceleration[j];
+            r_current_angular_velocity[j] = r_middle_angular_velocity[j] + (mTime.Previous - mTime.PreviousMiddle) * r_current_angular_acceleration[j];
             r_middle_angular_velocity[j] = r_current_angular_velocity[j] + (mTime.Middle - mTime.Previous) * r_current_angular_acceleration[j];
-            r_current_rotation[j] = r_previous_rotation[j] + mTime.Delta * r_middle_angular_velocity[j];
+            r_current_rotation[j] = r_current_rotation[j] + mTime.Delta * r_middle_angular_velocity[j];
         }
     }
 
@@ -555,29 +545,29 @@ public:
         NodesArrayType& r_nodes = rModelPart.Nodes();
 
         // The fisrt node interator
-        const auto it_node_begin = rModelPart.NodesBegin();
+        auto it_begin_node = rModelPart.NodesBegin();
 
         // If we consider the rotation DoF
-        const bool has_dof_for_rot_z = it_node_begin->HasDofFor(ROTATION_Z);
+        const bool has_dof_for_rot_z = it_begin_node->HasDofFor(ROTATION_Z);
 
         // Auxiliar zero array
         const array_1d<double, 3> zero_array = ZeroVector(3);
 
         // Getting dof position
-        const IndexType disppos = it_node_begin->GetDofPosition(DISPLACEMENT_X);
-        const IndexType rotppos = has_dof_for_rot_z ? it_node_begin->GetDofPosition(ROTATION_X) : 0;
+        const IndexType disppos = it_begin_node->GetDofPosition(DISPLACEMENT_X);
+        const IndexType rotppos = has_dof_for_rot_z ? it_begin_node->GetDofPosition(ROTATION_X) : 0;
 
-        #pragma omp parallel for schedule(guided,512)
+        #pragma omp parallel for firstprivate(it_begin_node)
         for (int i = 0; i < static_cast<int>(r_nodes.size()); ++i) {
             // Current step information "N+1" (before step update).
-            auto it_node = it_node_begin + i;
+            auto it_node = (it_begin_node + i);
 
             const double nodal_mass = it_node->GetValue(NODAL_MASS);
             const array_1d<double, 3>& r_current_residual = it_node->FastGetSolutionStepValue(FORCE_RESIDUAL);
 
             array_1d<double, 3>& r_current_velocity = it_node->FastGetSolutionStepValue(VELOCITY);
 //             array_1d<double,3>& r_current_displacement = it_node->FastGetSolutionStepValue(DISPLACEMENT);
-            array_1d<double, 3>& r_middle_velocity = it_node->FastGetSolutionStepValue(MIDDLE_VELOCITY);
+            array_1d<double, 3>& r_middle_velocity = it_node->GetValue(MIDDLE_VELOCITY);
 
             array_1d<double, 3>& r_current_acceleration = it_node->FastGetSolutionStepValue(ACCELERATION);
 
@@ -613,7 +603,7 @@ public:
                 const array_1d<double, 3>& r_current_residual_moment = it_node->FastGetSolutionStepValue(MOMENT_RESIDUAL);
                 array_1d<double, 3>& r_current_angular_velocity = it_node->FastGetSolutionStepValue(ANGULAR_VELOCITY);
                 // array_1d<double,3>& current_rotation = it_node->FastGetSolutionStepValue(ROTATION);
-                array_1d<double, 3>& r_middle_angular_velocity = it_node->FastGetSolutionStepValue(MIDDLE_ANGULAR_VELOCITY);
+                array_1d<double, 3>& r_middle_angular_velocity = it_node->GetValue(MIDDLE_ANGULAR_VELOCITY);
                 array_1d<double, 3>& r_current_angular_acceleration = it_node->FastGetSolutionStepValue(ANGULAR_ACCELERATION);
 
                 const IndexType initial_k = DomainSize == 3 ? 0 : 2; // We do this because in 2D only the rotation Z is needed, then we start with 2, instead of 0
@@ -814,10 +804,10 @@ private:
         ProcessInfo& rCurrentProcessInfo
         )
     {
-        pCurrentEntity->CalculateRightHandSide(RHS_Contribution, rCurrentProcessInfo);
+        (pCurrentEntity)->CalculateRightHandSide(RHS_Contribution, rCurrentProcessInfo);
 
-        pCurrentEntity->AddExplicitContribution(RHS_Contribution, RESIDUAL_VECTOR, FORCE_RESIDUAL, rCurrentProcessInfo);
-        pCurrentEntity->AddExplicitContribution(RHS_Contribution, RESIDUAL_VECTOR, MOMENT_RESIDUAL, rCurrentProcessInfo);
+        (pCurrentEntity)->AddExplicitContribution(RHS_Contribution, RESIDUAL_VECTOR, FORCE_RESIDUAL, rCurrentProcessInfo);
+        (pCurrentEntity)->AddExplicitContribution(RHS_Contribution, RESIDUAL_VECTOR, MOMENT_RESIDUAL, rCurrentProcessInfo);
     }
 
     ///@}
diff --git a/applications/StructuralMechanicsApplication/custom_strategies/custom_strategies/mechanical_explicit_strategy.hpp b/applications/StructuralMechanicsApplication/custom_strategies/custom_strategies/mechanical_explicit_strategy.hpp
index d3225c2b8f..77067bfea7 100644
--- a/applications/StructuralMechanicsApplication/custom_strategies/custom_strategies/mechanical_explicit_strategy.hpp
+++ b/applications/StructuralMechanicsApplication/custom_strategies/custom_strategies/mechanical_explicit_strategy.hpp
@@ -240,7 +240,7 @@ public:
                 VariableUtils().SetNonHistoricalVariable(NODAL_INERTIA, zero_array, r_nodes);
                 VariableUtils().SetNonHistoricalVariable(NODAL_ROTATION_DAMPING, zero_array, r_nodes);
 
-                #pragma omp parallel for firstprivate(dummy_vector), schedule(guided,512)
+                #pragma omp parallel for firstprivate(dummy_vector)
                 for (int i = 0; i < static_cast<int>(r_elements.size()); ++i) {
                     // Getting nodal mass and inertia from element
                     // this function needs to be implemented in the respective
@@ -249,7 +249,7 @@ public:
                     it_elem->AddExplicitContribution(dummy_vector, RESIDUAL_VECTOR, NODAL_INERTIA, r_current_process_info);
                 }
             } else { // Only NODAL_MASS is needed
-                #pragma omp parallel for firstprivate(dummy_vector), schedule(guided,512)
+                #pragma omp parallel for firstprivate(dummy_vector)
                 for (int i = 0; i < static_cast<int>(r_elements.size()); ++i) {
                     // Getting nodal mass and inertia from element
                     // this function needs to be implemented in the respective
@@ -300,7 +300,7 @@ public:
                 VariableUtils().SetNonHistoricalVariable(NODAL_INERTIA, zero_array, r_nodes);
                 VariableUtils().SetNonHistoricalVariable(NODAL_ROTATION_DAMPING, zero_array, r_nodes);
 
-                #pragma omp parallel for firstprivate(dummy_vector), schedule(guided,512)
+                #pragma omp parallel for firstprivate(dummy_vector)
                 for (int i = 0; i < static_cast<int>(r_elements.size()); ++i) {
                     // Getting nodal mass and inertia from element
                     // this function needs to be implemented in the respective
@@ -309,7 +309,7 @@ public:
                     it_elem->AddExplicitContribution(dummy_vector, RESIDUAL_VECTOR, NODAL_INERTIA, r_current_process_info);
                 }
             } else { // Only NODAL_MASS and NODAL_DISPLACEMENT_DAMPING are needed
-                #pragma omp parallel for firstprivate(dummy_vector), schedule(guided,512)
+                #pragma omp parallel for firstprivate(dummy_vector)
                 for (int i = 0; i < static_cast<int>(r_elements.size()); ++i) {
                     // Getting nodal mass and inertia from element
                     // this function needs to be implemented in the respective
@@ -342,13 +342,13 @@ public:
         LocalSystemVectorType RHS_Contribution = LocalSystemVectorType(0);
         Element::EquationIdVectorType equation_id_vector_dummy; // Dummy
 
-        #pragma omp parallel for firstprivate(RHS_Contribution, equation_id_vector_dummy), schedule(guided,512)
+        #pragma omp parallel for firstprivate(RHS_Contribution, equation_id_vector_dummy)
         for (int i = 0; i < static_cast<int>(r_conditions.size()); ++i) {
             auto it_cond = r_conditions.begin() + i;
             pScheme->Condition_Calculate_RHS_Contribution((*it_cond.base()), RHS_Contribution, equation_id_vector_dummy, r_current_process_info);
         }
 
-        #pragma omp parallel for firstprivate(RHS_Contribution, equation_id_vector_dummy), schedule(guided,512)
+        #pragma omp parallel for firstprivate(RHS_Contribution, equation_id_vector_dummy)
         for (int i = 0; i < static_cast<int>(r_elements.size()); ++i) {
             auto it_elem = r_elements.begin() + i;
             pScheme->Calculate_RHS_Contribution((*it_elem.base()), RHS_Contribution, equation_id_vector_dummy, r_current_process_info);
@@ -527,51 +527,42 @@ private:
         const bool has_dof_for_rot_z = (r_nodes.begin())->HasDofFor(ROTATION_Z);
 
         // Auxiliar values
-        const array_1d<double, 3> zero_array = ZeroVector(3);
         array_1d<double, 3> force_residual = ZeroVector(3);
         array_1d<double, 3> moment_residual = ZeroVector(3);
 
-        // Getting
-        const auto it_node_begin = r_nodes.begin();
-        const IndexType disppos = it_node_begin->GetDofPosition(DISPLACEMENT_X);
-        const IndexType rotppos = it_node_begin->GetDofPosition(ROTATION_X);
-
         // Iterating nodes
-        #pragma omp parallel for firstprivate(force_residual, moment_residual), schedule(guided,512)
+        const auto it_node_begin = r_nodes.begin();
+        #pragma omp parallel for firstprivate(force_residual, moment_residual)
         for(int i=0; i<static_cast<int>(r_nodes.size()); ++i) {
             auto it_node = it_node_begin + i;
 
             noalias(force_residual) = it_node->FastGetSolutionStepValue(FORCE_RESIDUAL);
             if (has_dof_for_rot_z) {
                 noalias(moment_residual) = it_node->FastGetSolutionStepValue(MOMENT_RESIDUAL);
-            } else {
-                noalias(moment_residual) = zero_array;
             }
 
-            if (it_node->GetDof(DISPLACEMENT_X, disppos).IsFixed()) {
-                double& r_reaction = it_node->FastGetSolutionStepValue(REACTION_X);
-                r_reaction = force_residual[0];
-            }
-            if (it_node->GetDof(DISPLACEMENT_Y, disppos + 1).IsFixed()) {
-                double& r_reaction = it_node->FastGetSolutionStepValue(REACTION_Y);
-                r_reaction = force_residual[1];
-            }
-            if (it_node->GetDof(DISPLACEMENT_Z, disppos + 2).IsFixed()) {
-                double& r_reaction = it_node->FastGetSolutionStepValue(REACTION_Z);
-                r_reaction = force_residual[2];
-            }
-            if (has_dof_for_rot_z) {
-                if (it_node->GetDof(ROTATION_X, rotppos).IsFixed()) {
-                    double& r_reaction = it_node->FastGetSolutionStepValue(REACTION_MOMENT_X);
-                    r_reaction = moment_residual[0];
-                }
-                if (it_node->GetDof(ROTATION_Y, rotppos + 1).IsFixed()) {
-                    double& r_reaction = it_node->FastGetSolutionStepValue(REACTION_MOMENT_Y);
-                    r_reaction = moment_residual[1];
-                }
-                if (it_node->GetDof(ROTATION_Z, rotppos + 2).IsFixed()) {
-                    double& r_reaction = it_node->FastGetSolutionStepValue(REACTION_MOMENT_Z);
-                    r_reaction = moment_residual[2];
+            for (auto& r_dof : it_node->GetDofs()) {
+                if (r_dof.IsFixed()) {
+                    const auto& r_var = r_dof.GetVariable();
+                    if (r_var == DISPLACEMENT_X) {
+                        double& r_reaction = it_node->FastGetSolutionStepValue(REACTION_X);
+                        r_reaction = force_residual[0];
+                    } else if (r_var == DISPLACEMENT_Y) {
+                        double& r_reaction = it_node->FastGetSolutionStepValue(REACTION_Y);
+                        r_reaction = force_residual[1];
+                    } else if (r_var == DISPLACEMENT_Z) {
+                        double& r_reaction = it_node->FastGetSolutionStepValue(REACTION_Z);
+                        r_reaction = force_residual[2];
+                    } else if (r_var == ROTATION_X) {
+                        double& r_reaction = it_node->FastGetSolutionStepValue(REACTION_MOMENT_X);
+                        r_reaction = moment_residual[0];
+                    } else if (r_var == ROTATION_Y) {
+                        double& r_reaction = it_node->FastGetSolutionStepValue(REACTION_MOMENT_Y);
+                        r_reaction = moment_residual[1];
+                    } else if (r_var == ROTATION_Z) {
+                        double& r_reaction = it_node->FastGetSolutionStepValue(REACTION_MOMENT_Z);
+                        r_reaction = moment_residual[2];
+                    }
                 }
             }
         }
diff --git a/applications/StructuralMechanicsApplication/custom_utilities/add_custom_utilities_to_python.cpp b/applications/StructuralMechanicsApplication/custom_utilities/add_custom_utilities_to_python.cpp
deleted file mode 100644
index f2bccbec68..0000000000
--- a/applications/StructuralMechanicsApplication/custom_utilities/add_custom_utilities_to_python.cpp
+++ /dev/null
@@ -1,46 +0,0 @@
-// KRATOS  ___|  |                   |                   |
-//       \___ \  __|  __| |   |  __| __| |   |  __| _` | |
-//             | |   |    |   | (    |   |   | |   (   | |
-//       _____/ \__|_|   \__,_|\___|\__|\__,_|_|  \__,_|_| MECHANICS
-//
-//  License:		 BSD License
-//					 license: structural_mechanics_application/license.txt
-//
-//  Main authors:    Riccardo Rossi
-//
-
-// System includes
-
-// External includes
-
-// Project includes
-#include "custom_python/add_custom_utilities_to_python.h"
-
-//Utilities
-#include "custom_utilities/formfinding_io_utility.h"
-#include "custom_utilities/rve_periodicity_utility.h"
-
-namespace Kratos {
-namespace Python {
-
-void  AddCustomUtilitiesToPython(pybind11::module& m)
-{
-    namespace py = pybind11;
-
-    py::class_<FormfindingIOUtility>(m,"FormfindingIOUtility")
-        .def(py::init<ModelPart&, const Parameters>())
-        .def("PrintModelPart",&FormfindingIOUtility::PrintModelPart)
-        .def("ReadPrestressData",&FormfindingIOUtility::ReadPrestressData )
-        .def("PrintPrestressData",&FormfindingIOUtility::PrintPrestressData )
-        ;
-
-    py::class_<RVEPeriodicityUtility>(m,"RVEPeriodicityUtility")
-        .def(py::init<ModelPart&>())
-        .def("AssignPeriodicity",&RVEPeriodicityUtility::AssignPeriodicity)
-        .def("Finalize",&RVEPeriodicityUtility::Finalize)
-        ;
-}
-
-}  // namespace Python.
-} // Namespace Kratos
-
diff --git a/applications/StructuralMechanicsApplication/custom_utilities/constitutive_law_utilities.cpp b/applications/StructuralMechanicsApplication/custom_utilities/constitutive_law_utilities.cpp
index 360a5dd66d..4ab31c22a1 100644
--- a/applications/StructuralMechanicsApplication/custom_utilities/constitutive_law_utilities.cpp
+++ b/applications/StructuralMechanicsApplication/custom_utilities/constitutive_law_utilities.cpp
@@ -43,7 +43,7 @@ void ConstitutiveLawUtilities<3>::CalculateI1Invariant(
     )
 {
     rI1 = rStressVector[0];
-    for (IndexType i = 1; i < Dimension; ++i)
+    for (IndexType i = 1; i < Dimension; ++i) 
         rI1 += rStressVector[i];
 }
 
@@ -133,13 +133,13 @@ void ConstitutiveLawUtilities<3>::CalculateJ2Invariant(
     )
 {
     rDeviator = rStressVector;
-    const double p_mean = I1 / 3.0;
+    const double p_mean = I1 / static_cast<double>(Dimension);
 
     for (IndexType i = 0; i < Dimension; ++i)
         rDeviator[i] -= p_mean;
 
-    rJ2 = 0.5 * (std::pow(rDeviator[0], 2.0) + std::pow(rDeviator[1], 2.0) + std::pow(p_mean, 2.0)) +
-          std::pow(rDeviator[2], 2.0);
+    rJ2 = 0.5 * (std::pow(rDeviator[0], 2) + std::pow(rDeviator[1], 2)) +
+          std::pow(rDeviator[2], 2);
 }
 
 /***********************************************************************************/
@@ -316,30 +316,6 @@ double ConstitutiveLawUtilities<TVoigtSize>::CalculateCharacteristicLength(const
 /***********************************************************************************/
 /***********************************************************************************/
 
-template<SizeType TVoigtSize>
-double ConstitutiveLawUtilities<TVoigtSize>::CalculateCharacteristicLengthOnReferenceConfiguration(const GeometryType& rGeometry)
-{
-    double radius = 0.0;
-
-    const SizeType points_number = rGeometry.size();
-	array_1d<double, 3> center = rGeometry[0].GetInitialPosition().Coordinates();
-    for ( IndexType i_node = 1 ; i_node < points_number ; ++i_node ) {
-        center += rGeometry[i_node].GetInitialPosition().Coordinates();
-    }
-    center /= static_cast<double>( points_number );
-
-    for(IndexType i_node = 0; i_node < points_number; ++i_node)  {
-        const array_1d<double, 3>& aux_vector = center - rGeometry[i_node].GetInitialPosition().Coordinates();
-        double aux_value = inner_prod(aux_vector, aux_vector);
-        if(aux_value > radius) radius = aux_value;
-    }
-
-    return std::sqrt(radius);
-}
-
-/***********************************************************************************/
-/***********************************************************************************/
-
 template<SizeType TVoigtSize>
 Matrix ConstitutiveLawUtilities<TVoigtSize>::ComputeEquivalentSmallDeformationDeformationGradient(const Vector& rStrainVector)
 {
@@ -377,8 +353,8 @@ void ConstitutiveLawUtilities<TVoigtSize>::CalculateGreenLagrangianStrain(
 {
     // Doing resize in case is needed
     if (rStrainVector.size() != VoigtSize)
-        rStrainVector.resize(VoigtSize, false);
-
+        rStrainVector.resize(VoigtSize);
+    
     // Identity matrix
     MatrixType identity_matrix(Dimension, Dimension);
     for (IndexType i = 0; i < Dimension; ++i) {
@@ -387,7 +363,7 @@ void ConstitutiveLawUtilities<TVoigtSize>::CalculateGreenLagrangianStrain(
             else identity_matrix(i, j) = 0.0;
         }
     }
-
+    
     // Calculate E matrix
     const BoundedMatrixType E_matrix = 0.5 * (rCauchyTensor - identity_matrix);
 
@@ -406,8 +382,8 @@ void ConstitutiveLawUtilities<TVoigtSize>::CalculateAlmansiStrain(
 {
     // Doing resize in case is needed
     if (rStrainVector.size() != VoigtSize)
-        rStrainVector.resize(VoigtSize, false);
-
+        rStrainVector.resize(VoigtSize);
+    
     // Identity matrix
     MatrixType identity_matrix(Dimension, Dimension);
     for (IndexType i = 0; i < Dimension; ++i) {
@@ -421,7 +397,7 @@ void ConstitutiveLawUtilities<TVoigtSize>::CalculateAlmansiStrain(
     MatrixType inverse_B_tensor ( Dimension, Dimension );
     double aux_det_b = 0;
     MathUtils<double>::InvertMatrix( rLeftCauchyTensor, inverse_B_tensor, aux_det_b);
-
+    
     // Calculate E matrix
     const BoundedMatrixType E_matrix = 0.5 * (identity_matrix - inverse_B_tensor);
 
@@ -440,13 +416,13 @@ void ConstitutiveLawUtilities<TVoigtSize>::CalculateHenckyStrain(
 {
     // Doing resize in case is needed
     if (rStrainVector.size() != VoigtSize)
-        rStrainVector.resize(VoigtSize, false);
-
+        rStrainVector.resize(VoigtSize);
+    
     // Declare the different matrix
     BoundedMatrixType eigen_values_matrix, eigen_vectors_matrix;
 
     // Decompose matrix
-    MathUtils<double>::GaussSeidelEigenSystem(rCauchyTensor, eigen_vectors_matrix, eigen_values_matrix, 1.0e-16, 20);
+    MathUtils<double>::EigenSystem<Dimension>(rCauchyTensor, eigen_vectors_matrix, eigen_values_matrix, 1.0e-16, 20);
 
     // Calculate the eigenvalues of the E matrix
     for (IndexType i = 0; i < Dimension; ++i) {
@@ -454,8 +430,7 @@ void ConstitutiveLawUtilities<TVoigtSize>::CalculateHenckyStrain(
     }
 
     // Calculate E matrix
-    BoundedMatrixType E_matrix;
-    MathUtils<double>::BDBtProductOperation(E_matrix, eigen_values_matrix, eigen_vectors_matrix);
+    const BoundedMatrixType E_matrix = prod(trans(eigen_vectors_matrix), prod<BoundedMatrixType>(eigen_values_matrix, eigen_vectors_matrix));
 
     // Hencky Strain Calculation
     rStrainVector = MathUtils<double>::StrainTensorToVector(E_matrix, TVoigtSize);
@@ -472,13 +447,13 @@ void ConstitutiveLawUtilities<TVoigtSize>::CalculateBiotStrain(
 {
     // Doing resize in case is needed
     if (rStrainVector.size() != VoigtSize)
-        rStrainVector.resize(VoigtSize, false);
+        rStrainVector.resize(VoigtSize);
 
     // Declare the different matrix
     BoundedMatrixType eigen_values_matrix, eigen_vectors_matrix;
 
     // Decompose matrix
-    MathUtils<double>::GaussSeidelEigenSystem(rCauchyTensor, eigen_vectors_matrix, eigen_values_matrix, 1.0e-16, 20);
+    MathUtils<double>::EigenSystem<Dimension>(rCauchyTensor, eigen_vectors_matrix, eigen_values_matrix, 1.0e-16, 20);
 
     // Calculate the eigenvalues of the E matrix
     for (IndexType i = 0; i < Dimension; ++i) {
@@ -486,8 +461,7 @@ void ConstitutiveLawUtilities<TVoigtSize>::CalculateBiotStrain(
     }
 
     // Calculate E matrix
-    BoundedMatrixType E_matrix;
-    MathUtils<double>::BDBtProductOperation(E_matrix, eigen_values_matrix, eigen_vectors_matrix);
+    const BoundedMatrixType E_matrix = prod(trans(eigen_vectors_matrix), prod<BoundedMatrixType>(eigen_values_matrix, eigen_vectors_matrix));
 
     // Biot Strain Calculation
     rStrainVector = MathUtils<double>::StrainTensorToVector(E_matrix, TVoigtSize);
@@ -505,21 +479,21 @@ void ConstitutiveLawUtilities<TVoigtSize>::PolarDecomposition(
 {
     // Doing resize in case is needed
     if (rRMatrix.size1() != Dimension || rRMatrix.size2() != Dimension)
-        rRMatrix.resize(Dimension, Dimension, false);
+        rRMatrix.resize(Dimension, Dimension);
     if (rUMatrix.size1() != Dimension || rUMatrix.size2() != Dimension)
-        rUMatrix.resize(Dimension, Dimension, false);
+        rUMatrix.resize(Dimension, Dimension);
 
     // We compute Right Cauchy tensor
     const MatrixType C = prod(trans(rFDeformationGradient), rFDeformationGradient);
 
     // Decompose matrix C
     BoundedMatrix<double, Dimension, Dimension> eigen_vector_matrix, eigen_values_matrix;
-    MathUtils<double>::GaussSeidelEigenSystem(C, eigen_vector_matrix, eigen_values_matrix, 1.0e-16, 200);
+    MathUtils<double>::EigenSystem<Dimension>(C, eigen_vector_matrix, eigen_values_matrix, 1.0e-16, 200);
 
     for (IndexType i = 0; i < Dimension; ++i)
         eigen_values_matrix(i, i) = std::sqrt(eigen_values_matrix(i, i));
 
-    noalias(rUMatrix) = prod(eigen_values_matrix, trans(eigen_vector_matrix));
+    noalias(rUMatrix) = prod(eigen_values_matrix, eigen_vector_matrix);
 
     double aux_det;
     MatrixType invU(Dimension, Dimension);
@@ -582,7 +556,7 @@ void ConstitutiveLawUtilities<3>::CalculatePrincipalStresses(
     const BoundedVectorType& rStressVector
     )
 {
-    rPrincipalStressVector[0] = 0.5 * (rStressVector[0] + rStressVector[1]) +
+    rPrincipalStressVector[0] = 0.5 * (rStressVector[0] + rStressVector[1]) + 
         std::sqrt(std::pow(0.5 * (rStressVector[0] - rStressVector[1]), 2)  +
         std::pow(rStressVector[2], 2));
 
@@ -649,18 +623,18 @@ void ConstitutiveLawUtilities<6>::CalculateProjectionOperator(
     BoundedMatrix<double, Dimension, Dimension> eigen_vectors_matrix;
     BoundedMatrix<double, Dimension, Dimension> eigen_values_matrix;
 
-    MathUtils<double>::GaussSeidelEigenSystem(strain_tensor, eigen_vectors_matrix, eigen_values_matrix, 1.0e-16, 20);
+    MathUtils<double>::EigenSystem<Dimension>(strain_tensor, eigen_vectors_matrix, eigen_values_matrix, 1.0e-16, 20);
 
     std::vector<Vector> eigen_vectors_container;
 
     Vector auxiliar_vector = ZeroVector(Dimension);
     for (IndexType i = 0; i < Dimension; ++i) {
-        auxiliar_vector[0] = eigen_vectors_matrix(i, 0);
-        auxiliar_vector[1] = eigen_vectors_matrix(i, 1);
-        auxiliar_vector[2] = eigen_vectors_matrix(i, 2);
+        auxiliar_vector[0] = eigen_vectors_matrix(0, i);
+        auxiliar_vector[1] = eigen_vectors_matrix(1, i);
+        auxiliar_vector[2] = eigen_vectors_matrix(2, i);
         eigen_vectors_container.push_back(auxiliar_vector);
     }
-
+    
     Vector sigma_tension_vector;
     Matrix sigma_tension_tensor;
     for (IndexType i = 0; i < Dimension; ++i) {
@@ -672,7 +646,7 @@ void ConstitutiveLawUtilities<6>::CalculateProjectionOperator(
     }
 
     Matrix indexes_ij;
-    indexes_ij.resize(3, 2, false);
+    indexes_ij.resize(3, 2);
     indexes_ij(0, 0) = 0;
     indexes_ij(0, 1) = 1;
     indexes_ij(1, 0) = 1;
@@ -718,17 +692,17 @@ void ConstitutiveLawUtilities<3>::CalculateProjectionOperator(
     BoundedMatrix<double, Dimension, Dimension> eigen_vectors_matrix;
     BoundedMatrix<double, Dimension, Dimension> eigen_values_matrix;
 
-    MathUtils<double>::GaussSeidelEigenSystem(strain_tensor, eigen_vectors_matrix, eigen_values_matrix, 1.0e-16, 20);
+    MathUtils<double>::EigenSystem<Dimension>(strain_tensor, eigen_vectors_matrix, eigen_values_matrix, 1.0e-16, 20);
 
     std::vector<Vector> eigen_vectors_container;
 
     Vector auxiliar_vector = ZeroVector(Dimension);
     for (IndexType i = 0; i < Dimension; ++i) {
-        auxiliar_vector[0] = eigen_vectors_matrix(i, 0);
-        auxiliar_vector[1] = eigen_vectors_matrix(i, 1);
+        auxiliar_vector[0] = eigen_vectors_matrix(0, i);
+        auxiliar_vector[1] = eigen_vectors_matrix(1, i);
         eigen_vectors_container.push_back(auxiliar_vector);
     }
-
+    
     Vector sigma_tension_vector;
     Matrix sigma_tension_tensor;
     for (IndexType i = 0; i < Dimension; ++i) {
@@ -773,13 +747,13 @@ void ConstitutiveLawUtilities<TVoigtSize>::SpectralDecomposition(
     BoundedMatrix<double, Dimension, Dimension> eigen_vectors_matrix;
     BoundedMatrix<double, Dimension, Dimension> eigen_values_matrix;
 
-    MathUtils<double>::GaussSeidelEigenSystem(stress_tensor, eigen_vectors_matrix, eigen_values_matrix, 1.0e-16, 20);
+    MathUtils<double>::EigenSystem<Dimension>(stress_tensor, eigen_vectors_matrix, eigen_values_matrix, 1.0e-16, 20);
 
     std::vector<Vector> eigen_vectors_container;
     Vector auxiliar_vector = ZeroVector(Dimension);
     for (IndexType i = 0; i < Dimension; ++i) {
         for (IndexType j = 0; j < Dimension; ++j) {
-            auxiliar_vector[j] = eigen_vectors_matrix(i, j);
+            auxiliar_vector[j] = eigen_vectors_matrix(j, i);
         }
         eigen_vectors_container.push_back(auxiliar_vector);
     }
@@ -804,7 +778,7 @@ Matrix ConstitutiveLawUtilities<TVoigtSize>::CalculateLinearPlasticDeformationGr
     const double PlasticConsistencyFactorIncrement
     )
 {
-    const MatrixType plastic_deformation_gradient_increment  = IdentityMatrix(Dimension) + PlasticConsistencyFactorIncrement * MathUtils<double>::StrainVectorToTensor<BoundedVectorType, MatrixType>(rPlasticPotentialDerivative);
+    const MatrixType plastic_deformation_gradient_increment  = IdentityMatrix(Dimension, Dimension) + PlasticConsistencyFactorIncrement * MathUtils<double>::StrainVectorToTensor<BoundedVectorType, MatrixType>(rPlasticPotentialDerivative);
 
     return plastic_deformation_gradient_increment;
 }
@@ -823,14 +797,14 @@ Matrix ConstitutiveLawUtilities<TVoigtSize>::CalculateExponentialPlasticDeformat
     MatrixType plastic_deformation_gradient_increment(Dimension, Dimension);
 
     // Define plastic flow
-    const BoundedMatrixType plastic_flow = PlasticConsistencyFactorIncrement * MathUtils<double>::VectorToSymmetricTensor<BoundedVectorType, MatrixType>(rPlasticPotentialDerivative);
+    const MatrixType plastic_flow = PlasticConsistencyFactorIncrement * MathUtils<double>::VectorToSymmetricTensor<BoundedVectorType, MatrixType>(rPlasticPotentialDerivative);
 
     // Declare the different eigen decomposition matrices
     BoundedMatrixType eigen_values_matrix, eigen_vectors_matrix;
 
     // We compute the exponential matrix
     // Decompose matrix
-    MathUtils<double>::GaussSeidelEigenSystem(plastic_flow, eigen_vectors_matrix, eigen_values_matrix, 1.0e-16, 20);
+    MathUtils<double>::EigenSystem<Dimension>(plastic_flow, eigen_vectors_matrix, eigen_values_matrix, 1.0e-16, 20);
 
     // Calculate the eigenvalues of the E matrix
     for (std::size_t i = 0; i < Dimension; ++i) {
@@ -838,7 +812,7 @@ Matrix ConstitutiveLawUtilities<TVoigtSize>::CalculateExponentialPlasticDeformat
     }
 
     // Calculate exponential matrix
-    MathUtils<double>::BDBtProductOperation(plastic_deformation_gradient_increment, eigen_values_matrix, eigen_vectors_matrix);
+    noalias(plastic_deformation_gradient_increment) = prod(trans(eigen_vectors_matrix), prod<Matrix>(eigen_values_matrix, eigen_vectors_matrix));
 
     // Pre and post multiply by Re
     plastic_deformation_gradient_increment = prod(plastic_deformation_gradient_increment, rRe);
@@ -850,7 +824,7 @@ Matrix ConstitutiveLawUtilities<TVoigtSize>::CalculateExponentialPlasticDeformat
 /***********************************************************************************/
 /***********************************************************************************/
 
-template class ConstitutiveLawUtilities<3>;
+template class ConstitutiveLawUtilities<3>; 
 template class ConstitutiveLawUtilities<6>;
 
 } // namespace Kratos
diff --git a/applications/StructuralMechanicsApplication/custom_utilities/constitutive_law_utilities.h b/applications/StructuralMechanicsApplication/custom_utilities/constitutive_law_utilities.h
index cc3aae1ca5..bd2acd3872 100644
--- a/applications/StructuralMechanicsApplication/custom_utilities/constitutive_law_utilities.h
+++ b/applications/StructuralMechanicsApplication/custom_utilities/constitutive_law_utilities.h
@@ -209,13 +209,6 @@ class KRATOS_API(STRUCTURAL_MECHANICS_APPLICATION) ConstitutiveLawUtilities
      */
     static double CalculateCharacteristicLength(const GeometryType& rGeometry);
 
-    /**
-     * @brief Calculates the maximal distance between corner node of a geometry and its center (on reference configuration)
-     * @param rGeometry The geometry to compute
-     * @return The characteristic length
-     */
-    static double CalculateCharacteristicLengthOnReferenceConfiguration(const GeometryType& rGeometry);
-
     /**
      * @brief This method computes the equivalent deformation gradient for the elements which provide the deformation gradient as input
      * @param rStrainVector The strain vector
diff --git a/applications/StructuralMechanicsApplication/custom_utilities/explicit_integration_utilities.cpp b/applications/StructuralMechanicsApplication/custom_utilities/explicit_integration_utilities.cpp
index 7e7dfae508..c07a64ab2e 100644
--- a/applications/StructuralMechanicsApplication/custom_utilities/explicit_integration_utilities.cpp
+++ b/applications/StructuralMechanicsApplication/custom_utilities/explicit_integration_utilities.cpp
@@ -33,8 +33,8 @@ double CalculateDeltaTime(
     Parameters default_parameters = Parameters(R"(
     {
         "time_step_prediction_level" : 2.0,
-        "max_delta_time"             : 1.0e0,
-        "safety_factor"              : 0.80,
+        "max_delta_time"             : 1.0e-3,
+        "safety_factor"              : 0.4,
         "mass_factor"                : 1.0,
         "desired_delta_time"         : -1.0,
         "max_number_of_iterations"   : 10
@@ -121,7 +121,7 @@ double InnerCalculateDeltaTime(
 
         /* Get geometric and material properties */
         const Properties& r_properties = it_elem->GetProperties();
-        auto& r_geometry = it_elem->GetGeometry();
+        const auto& r_geometry = it_elem->GetGeometry();
 
         // Initialize
         check_has_all_variables = true;
@@ -151,7 +151,7 @@ double InnerCalculateDeltaTime(
         if (r_properties.Has(POISSON_RATIO)) {
             nu = r_properties[POISSON_RATIO];
         } else {
-            nu = -1.0;
+            nu = 0.0;
         }
 
         // Getting density
@@ -162,28 +162,23 @@ double InnerCalculateDeltaTime(
         }
 
         if (check_has_all_variables) {
-            // Computing length as the smallest side of the geometry
+            // Computing length as the element radius
 //             const double length = it_elem->GetGeometry().Length();
-            double min_length = std::numeric_limits<double>::max();
-            for (IndexType i_edge = 0; i_edge < r_geometry.EdgesNumber(); ++i_edge) {
-                min_length = std::min(r_geometry.Edges()[i_edge].Length(), min_length);
-            }
-
-            // We compute the minimum height of the face too
-            for (IndexType i_face = 0; i_face < r_geometry.FacesNumber(); ++i_face) {
-                double max_length = 0.0;
-
-                for (IndexType i_edge = 0; i_edge < r_geometry.Faces()[i_face].EdgesNumber(); ++i_edge) {
-                    max_length = std::max(r_geometry.Faces()[i_face].Edges()[i_edge].Length(), max_length);
-                }
-
-                min_length = std::min(r_geometry.Faces()[i_face].Area()/max_length, min_length);
+            double length = 0.0;
+            const Point& r_center = r_geometry.Center();
+
+            array_1d<double, 3> aux_vector;
+            for(std::size_t i_node = 0; i_node < r_geometry.PointsNumber(); ++i_node)  {
+                noalias(aux_vector) = r_center.Coordinates() - r_geometry[i_node].Coordinates();
+                const double aux_value = norm_2(aux_vector);
+                if(aux_value > length)
+                    length = aux_value;
             }
 
             // Compute courant criterion
-            const double bulk_modulus = (nu < 0.0) ? E : E / (3.0 * (1.0 - 2.0 * nu));
+            const double bulk_modulus = E / (3.0 * (1.0 - 2.0 * nu));
             const double wavespeed = std::sqrt(bulk_modulus / rho);
-            const double w = 2.0 * wavespeed / min_length; // Frequency
+            const double w = 2.0 * wavespeed / length; // Frequency
 
             const double psi = 0.5 * (alpha / w + beta * w); // Critical ratio;
             stable_delta_time = (2.0 / w) * (std::sqrt(1.0 + psi * psi) - psi);
diff --git a/applications/StructuralMechanicsApplication/custom_utilities/rayleigh_damping_coefficients_utilities.cpp b/applications/StructuralMechanicsApplication/custom_utilities/rayleigh_damping_coefficients_utilities.cpp
index 75c97261bc..ab808e0a24 100644
--- a/applications/StructuralMechanicsApplication/custom_utilities/rayleigh_damping_coefficients_utilities.cpp
+++ b/applications/StructuralMechanicsApplication/custom_utilities/rayleigh_damping_coefficients_utilities.cpp
@@ -20,9 +20,7 @@
 
 namespace Kratos
 {
-namespace RayleighDampingCoefficientsUtilities
-{
-Vector ComputeDampingCoefficients(Parameters ThisParameters)
+Vector RayleighDampingCoefficientsUtilities::ComputeDampingCoefficients(Parameters ThisParameters)
 {
     KRATOS_TRY
 
@@ -69,8 +67,7 @@ Vector ComputeDampingCoefficients(Parameters ThisParameters)
 
             // We compute the inverse
             double det;
-            BoundedMatrix<double, 2, 2> inverse_frequencies_matrix;
-            MathUtils<double>::InvertMatrix(frequencies_matrix, inverse_frequencies_matrix, det);
+            const BoundedMatrix<double, 2, 2> inverse_frequencies_matrix = MathUtils<double>::InvertMatrix<2>(frequencies_matrix, det);
 
             // We can compute now
             const array_1d<double, 2> aux_solution = prod(inverse_frequencies_matrix, damping_ratios);
@@ -92,5 +89,4 @@ Vector ComputeDampingCoefficients(Parameters ThisParameters)
 
     KRATOS_CATCH("")
 }
-} // namespace RayleighDampingCoefficientsUtilities
 } // namespace Kratos
diff --git a/applications/StructuralMechanicsApplication/custom_utilities/rve_periodicity_utility.cpp b/applications/StructuralMechanicsApplication/custom_utilities/rve_periodicity_utility.cpp
deleted file mode 100644
index 9b651a954d..0000000000
--- a/applications/StructuralMechanicsApplication/custom_utilities/rve_periodicity_utility.cpp
+++ /dev/null
@@ -1,236 +0,0 @@
-//    |  /           |
-//    ' /   __| _` | __|  _ \   __|
-//    . \  |   (   | |   (   |\__ `
-//   _|\_\_|  \__,_|\__|\___/ ____/
-//                   Multi-Physics
-//
-//  License:		 BSD License
-//					 Kratos default license: kratos/license.txt
-//
-//  Main authors:    Riccardo Rossi
-//
-
-// System includes
-
-// External includes
-
-// Project includes
-#include "rve_periodicity_utility.h"
-#include "utilities/binbased_fast_point_locator_conditions.h"
-#include "includes/linear_master_slave_constraint.h"
-
-namespace Kratos
-{
-void RVEPeriodicityUtility::AssignPeriodicity(
-    ModelPart& rMasterModelPart,
-    ModelPart& rSlaveModelPart,
-    const Matrix& rStrainTensor,
-    const Vector& rDirection
-    )
-{
-    KRATOS_ERROR_IF(rMasterModelPart.NumberOfConditions() == 0) << "the master is expected to have conditions and it is empty" << std::endl;
-
-    const Vector translation = prod(rStrainTensor, rDirection);
-
-    BinBasedFastPointLocatorConditions<3> bin_based_point_locator(rMasterModelPart);
-    bin_based_point_locator.UpdateSearchDatabase();
-
-    int max_search_results = 100;
-    double search_tolerance = 1e-6;
-
-    // Construct auxiliary data structure to contain the master slave relation.
-    // Slave nodes must appear once, however a non-circular dependency is allowed between the masters
-    for (IndexType i = 0; i < rSlaveModelPart.Nodes().size(); ++i) {
-        // Search in which condition it falls
-        auto it_node = rSlaveModelPart.NodesBegin() + i;
-
-        Condition::Pointer p_host_cond;
-        Vector N;
-        array_1d<double, 3> transformed_slave_coordinates = it_node->Coordinates() - rDirection;
-
-        // Finding the host element for this node
-        const bool is_found = bin_based_point_locator.FindPointOnMeshSimplified(transformed_slave_coordinates, N, p_host_cond, max_search_results, search_tolerance);
-        if (is_found) {
-            const auto& r_geometry = p_host_cond->GetGeometry();
-
-            DataTupletype aux_data;
-
-            auto &T = std::get<2>(aux_data);
-            T = translation;
-
-            auto& r_master_ids = std::get<0>(aux_data);
-            auto& r_weights = std::get<1>(aux_data);
-            for (IndexType j = 0; j < r_geometry.size(); ++j) {
-                r_master_ids.push_back(r_geometry[j].Id());
-                r_weights.push_back(N[j]);
-            }
-
-            if (mAuxPairings.find(it_node->Id()) == mAuxPairings.end()) { // This slave is not already present
-                mAuxPairings[it_node->Id()] = aux_data;
-            } else {
-                KRATOS_INFO("RVEPeriodicityUtility") << "Slave model part = " << rSlaveModelPart << std::endl;
-                KRATOS_INFO("RVEPeriodicityUtility") << "Master model part = " << rMasterModelPart << std::endl;
-                KRATOS_ERROR << "Attempting to add twice the slave node with Id " << it_node->Id() << std::endl;
-            }
-        } else {
-            KRATOS_ERROR << "Counterpart not found for slave node " << it_node->Id() << std::endl;
-        }
-    }
-}
-
-/***********************************************************************************/
-/***********************************************************************************/
-
-void RVEPeriodicityUtility::AppendIdsAndWeights(
-    std::map<IndexType, DataTupletype>& rAux,
-    const IndexType MasterId,
-    const double MasterWeight,
-    std::vector<IndexType>& rFinalMastersIds,
-    std::vector<double>& rFinalMastersWeights,
-    Vector& rFinalT)
-{
-    if (std::abs(MasterWeight) > 1e-12) { // Discard nodes with negligible weight (note that weights sum to 1)
-        if (rAux.find(MasterId) == rAux.end()) { // Master is NOT also a slave
-            rFinalMastersIds.push_back(MasterId);
-            rFinalMastersWeights.push_back(MasterWeight);
-        } else { // Master also happens to be a slave
-            const auto& r_other_data = rAux[MasterId];
-            const auto& r_other_master_ids = std::get<0>(r_other_data);
-            const auto& r_other_master_weights = std::get<1>(r_other_data);
-            const auto& r_other_T = std::get<2>(r_other_data);
-            for (IndexType j = 0; j < r_other_master_ids.size(); ++j) {
-                AppendIdsAndWeights(rAux, r_other_master_ids[j], MasterWeight * r_other_master_weights[j], rFinalMastersIds, rFinalMastersWeights, rFinalT);
-            }
-
-            rFinalT += MasterWeight * r_other_T;
-        }
-    }
-}
-
-/***********************************************************************************/
-/***********************************************************************************/
-
-MasterSlaveConstraint::Pointer RVEPeriodicityUtility::GenerateConstraint(
-    IndexType& rConstraintId,
-    const VariableComponentType& rVar,
-    NodeType::Pointer pSlaveNode,
-    const std::vector<IndexType>& rMasterIds,
-    const Matrix& rRelationMatrix,
-    const Vector& rTranslationVector)
-{
-    DofPointerVectorType slave_dofs, master_dofs;
-    slave_dofs.reserve(1);
-    master_dofs.reserve(rMasterIds.size());
-
-    slave_dofs.push_back(pSlaveNode->pGetDof(rVar));
-    for (IndexType i = 0; i < rMasterIds.size(); ++i)
-        master_dofs.push_back(mrModelPart.pGetNode(rMasterIds[i])->pGetDof(rVar));
-
-    auto pconstraint = Kratos::make_shared<LinearMasterSlaveConstraint>(rConstraintId, master_dofs, slave_dofs, rRelationMatrix, rTranslationVector);
-    rConstraintId++;
-    return pconstraint;
-}
-
-/***********************************************************************************/
-/***********************************************************************************/
-
-void RVEPeriodicityUtility::Finalize(const Variable<array_1d<double, 3>>& rVariable)
-{
-    // Get the components
-    const std::string& r_base_variable_name = rVariable.Name();
-    auto& r_var_x = KratosComponents<VariableComponent<VectorComponentAdaptor<array_1d<double, 3>>>>::Get(r_base_variable_name + "_X");
-    auto& r_var_y = KratosComponents<VariableComponent<VectorComponentAdaptor<array_1d<double, 3>>>>::Get(r_base_variable_name + "_Y");
-    auto& r_var_z = KratosComponents<VariableComponent<VectorComponentAdaptor<array_1d<double, 3>>>>::Get(r_base_variable_name + "_Z");
-
-    for (auto& r_data : mAuxPairings) {
-        auto& r_master_data = r_data.second;
-        auto& r_master_ids = std::get<0>(r_master_data);
-        auto& r_master_weights = std::get<1>(r_master_data);
-        auto& r_T = std::get<2>(r_master_data);
-
-        std::vector<IndexType> final_master_ids;
-        std::vector<double> final_master_weights;
-        Vector final_T = r_T;
-
-        for (IndexType i = 0; i < r_master_ids.size(); ++i) {
-            AppendIdsAndWeights(mAuxPairings, r_master_ids[i], r_master_weights[i], final_master_ids, final_master_weights, final_T);
-        }
-
-        // Assign back the finalized pairings and weights to the data structure
-        r_master_ids = final_master_ids;
-        r_master_weights = final_master_weights;
-        r_T = final_T;
-    }
-
-    // First assign master and slave all to false
-    auto& r_nodes_array = mrModelPart.Nodes();
-    const auto it_node_begin = r_nodes_array.begin();
-    #pragma omp parallel for
-    for (int i_node = 0; i_node < static_cast<int>(r_nodes_array.size()); ++i_node) {
-        auto it_node = it_node_begin + i_node;
-        it_node->Set(SLAVE, false);
-        it_node->Set(MASTER, false);
-    }
-    // Compute the max id of the constraint
-    IndexType constraint_id = 0;
-    if (mrModelPart.NumberOfMasterSlaveConstraints() != 0) {
-        constraint_id = (mrModelPart.MasterSlaveConstraints().end() - 1)->Id();
-    }
-    constraint_id++;
-
-    // Define translation vector
-    Vector xtranslation(1);
-    Vector ytranslation(1);
-    Vector ztranslation(1);
-
-    ModelPart::MasterSlaveConstraintContainerType constraints;
-
-    for (const auto& r_data : mAuxPairings) {
-        const IndexType slave_id = r_data.first;
-        const auto& r_master_data = r_data.second;
-        auto& r_master_ids = std::get<0>(r_master_data);
-        auto& r_master_weights = std::get<1>(r_master_data);
-        auto& r_T = std::get<2>(r_master_data);
-
-        // Very useful for debugging
-        if (mEchoLevel > 0) {
-            std::cout << "slave_id "  << slave_id << " - " << "master_ids ";
-            for(auto& master_id : r_master_ids)
-                std::cout << master_id << " ";
-            std::cout << " - " << "master_weights ";
-            for(auto& w : r_master_weights)
-                std::cout << w << " " << "T ";
-            std::cout << " - " << r_T << std::endl;
-        }
-
-        // Flag slave and master nodes
-        mrModelPart.pGetNode(slave_id)->Set(SLAVE);
-        for (auto id : r_master_ids) {
-            mrModelPart.pGetNode(id)->Set(MASTER);
-        }
-
-        // Obtain the slave node
-        auto pslave_node = mrModelPart.pGetNode(slave_id);
-
-        // Define relation matrix (same for the different components)
-        Matrix relation_matrix(1, r_master_weights.size());
-        for (IndexType i = 0; i < relation_matrix.size2(); ++i) {
-            relation_matrix(0, i) = r_master_weights[i];
-        }
-
-        xtranslation[0] = r_T[0];
-        constraints.push_back(GenerateConstraint(constraint_id, r_var_x, pslave_node, r_master_ids, relation_matrix, xtranslation));
-
-        ytranslation[0] = r_T[1];
-        constraints.push_back(GenerateConstraint(constraint_id, r_var_y, pslave_node, r_master_ids, relation_matrix, ytranslation));
-
-        ztranslation[0] = r_T[2];
-        constraints.push_back(GenerateConstraint(constraint_id, r_var_z, pslave_node, r_master_ids, relation_matrix, ztranslation));
-    }
-
-    mrModelPart.AddMasterSlaveConstraints(constraints.begin(), constraints.end());
-}
-
-}  // namespace Kratos.
-
-
diff --git a/applications/StructuralMechanicsApplication/custom_utilities/rve_periodicity_utility.h b/applications/StructuralMechanicsApplication/custom_utilities/rve_periodicity_utility.h
deleted file mode 100644
index aa6538c881..0000000000
--- a/applications/StructuralMechanicsApplication/custom_utilities/rve_periodicity_utility.h
+++ /dev/null
@@ -1,223 +0,0 @@
-//    |  /           |
-//    ' /   __| _` | __|  _ \   __|
-//    . \  |   (   | |   (   |\__ `
-//   _|\_\_|  \__,_|\__|\___/ ____/
-//                   Multi-Physics
-//
-//  License:		 BSD License
-//					 Kratos default license: kratos/license.txt
-//
-//  Main authors:    Riccardo Rossi
-//
-
-#if !defined (KRATOS_RVE_PERIODICITY_UTILITY_H_INCLUDED)
-#define KRATOS_RVE_PERIODICITY_UTILITY_H_INCLUDED
-
-// System includes
-
-// External includes
-#include <tuple>
-
-// Project includes
-#include "includes/define.h"
-#include "includes/model_part.h"
-
-namespace Kratos
-{
-///@addtogroup StructuralMechanicsApplication
-///@{
-///@name Kratos Classes
-///@{
-
-/**
- * @class RVEPeriodicityUtility
- * @ingroup StructuralMechanicsApplication
- * @brief This defines a class to define periodic BC to a RVE
- * @details It uses MPC in order to set the periodic BC
- * @author Riccardo Rossi
-*/
-class KRATOS_API(STRUCTURAL_MECHANICS_APPLICATION) RVEPeriodicityUtility
-{
-  public:
-    ///@name Type Definitions
-    ///@{
-
-    /// Pointer definition of RVEPeriodicityUtility
-    KRATOS_CLASS_POINTER_DEFINITION(RVEPeriodicityUtility);
-
-    /// Definition of the index type
-    typedef std::size_t IndexType;
-
-    /// Definition of the data tuple type
-    typedef std::tuple<std::vector<IndexType>, std::vector<double>, Vector> DataTupletype;
-
-    /// The DoF type definition
-    typedef Dof<double> DofType;
-
-    /// The DoF pointer vector type definition
-    typedef std::vector< DofType::Pointer > DofPointerVectorType;
-
-    /// Definition of the node
-    typedef Node<3> NodeType;
-
-    /// Definition of the component of variable type
-    typedef VariableComponent<VectorComponentAdaptor<array_1d<double, 3>>> VariableComponentType;
-
-    ///@}
-    ///@name Life Cycle
-    ///@{
-
-    /// Default constructor.
-    RVEPeriodicityUtility(
-        ModelPart& rDestinationModelPart,
-        std::size_t EchoLevel = 0
-        ) : mrModelPart(rDestinationModelPart)
-          , mEchoLevel(EchoLevel)  { }
-
-    /// Copy constructor.
-    RVEPeriodicityUtility(RVEPeriodicityUtility const& rOther) = delete;
-
-    /// Destructor.
-    virtual ~RVEPeriodicityUtility() = default;
-
-    ///@}
-    ///@name Operators
-    ///@{
-
-    /// Assignment operator.
-    RVEPeriodicityUtility &operator=(RVEPeriodicityUtility const& rOther) = delete;
-
-    ///@}
-    ///@name Operations
-    ///@{
-
-    /**
-     * @brief This function assign a pairing condition between two modelparts which contain two flat faces, parallel to  each other and separated by a distance rDistance.
-     *  @details Note that this function should be called multiple times to pair the different faces in a box.
-     *  @param rMasterModelPart master part to be paired
-     *  @param rSlaveModelPart slave in the pairing
-     *  @param rStrainTensor strain tensor which will be used in computing the pairing conditions the condition to be guaranteed will be that :    uslave = umaster + rStrainTensor * rDirection
-     *  @param rDirection  a node with coordinates Xs on the slave, will be paired to the corresponding point with coordinates Xm on the master
-     *         Xm will be computed as      Xm = Xs - rDirection
-     */
-    void AssignPeriodicity(ModelPart& rMasterModelPart,
-                           ModelPart& rSlaveModelPart,
-                           const Matrix& rStrainTensor,
-                           const Vector& rDirection);
-
-    /** this function finalizes the computation of the pairings. It can be called ONLY ONCE
-     * @param rVariable is the value to which the pairing condition will be applied (needs to be a Variable with components)
-     */
-    void Finalize(const Variable<array_1d<double, 3>>& rVariable);
-
-    ///@}
-    ///@name Input and output
-    ///@{
-
-    /// Turn back information as a string.
-    virtual std::string Info() const
-    {
-        std::stringstream buffer;
-        buffer << "RVEPeriodicityUtility";
-        return buffer.str();
-    }
-
-    /// Print information about this object.
-    virtual void PrintInfo(std::ostream& rOStream) const
-    {
-        rOStream << "RVEPeriodicityUtility";
-    }
-
-    /// Print object's data.
-    virtual void PrintData(std::ostream& rOStream) const {}
-
-    ///@}
-
-  protected:
-    ///@name Protected Operations
-    ///@{
-
-    /**
-    * @brief This method appends the weights and ids to construct the MPC
-    * @param rAux The auxiliar map containing the ids and tuples
-    * @param MasterId The id of the master dof
-    * @param MasterWeight The constribution of the master dof in the MPC
-    * @param rFinalMastersIds The resulting vector of ids
-    * @param rFinalMastersWeights The resulting vector of weights
-    * @param rFinalT The resulting vector of constants (rigid displacements)
-    */
-    void AppendIdsAndWeights(
-        std::map<IndexType, DataTupletype>& rAux,
-        const IndexType MasterId,
-        const double MasterWeight,
-        std::vector<IndexType>& rFinalMastersIds,
-        std::vector<double>& rFinalMastersWeights,
-        Vector& rFinalT
-        );
-
-    ///@}
-
-private:
-    ///@name Member Variables
-    ///@{
-
-    ModelPart& mrModelPart; /// The model part where to apply the constraints
-
-    std::map<IndexType, DataTupletype> mAuxPairings; /// This map contains the pairings
-
-    std::size_t mEchoLevel = 0; /// The echo level of the utility
-
-    ///@}
-    ///@name Private Operations
-    ///@{
-
-    /**
-     * @brief This method helps to create the constraints
-     * @param rConstraintId The new constraint ID
-     * @param rVar The variable to be set with the constraint
-     * @param pSlaveNode The pointer to the slave node
-     * @param rMasterIds The id of the master dof
-     * @param rRelationMatrix The relation matrix between master slave dofs
-     * @param rTranslationVector The rigid motion vector of the dofs
-     */
-    MasterSlaveConstraint::Pointer  GenerateConstraint(
-        IndexType& rConstraintId,
-        const VariableComponentType& rVar,
-        NodeType::Pointer pSlaveNode,
-        const std::vector<IndexType>& rMasterIds,
-        const Matrix& rRelationMatrix,
-        const Vector& rTranslationVector
-        );
-
-    ///@}
-
-}; // Class RVEPeriodicityUtility
-
-///@}
-///@name Input and output
-///@{
-
-/// input stream function
-inline std::istream &operator>>(std::istream& rIStream,
-                                RVEPeriodicityUtility& rThis)
-{
-    return rIStream;
-}
-
-/// output stream function
-inline std::ostream &operator<<(std::ostream& rOStream,
-                                const RVEPeriodicityUtility& rThis)
-{
-    rThis.PrintInfo(rOStream);
-    rOStream << std::endl;
-    rThis.PrintData(rOStream);
-
-    return rOStream;
-}
-///@}
-
-///@} addtogroup block
-
-} // namespace Kratos.
-
-#endif // KRATOS_RVE_PERIODICITY_UTILITY_H_INCLUDED defined
diff --git a/applications/StructuralMechanicsApplication/custom_utilities/shell_cross_section.cpp b/applications/StructuralMechanicsApplication/custom_utilities/shell_cross_section.cpp
index d1804de1b1..dce45d0261 100644
--- a/applications/StructuralMechanicsApplication/custom_utilities/shell_cross_section.cpp
+++ b/applications/StructuralMechanicsApplication/custom_utilities/shell_cross_section.cpp
@@ -890,18 +890,18 @@ void ShellCrossSection::InitializeParameters(SectionParameters& rValues, Constit
 
     rVariables.DeterminantF = 1.0;
 
-    rVariables.DeformationGradientF_2D = IdentityMatrix(2);
-    rVariables.StrainVector_2D.resize(3, false);
-    rVariables.StressVector_2D.resize(3, false);
-    rVariables.ConstitutiveMatrix_2D.resize(3,3, false);
+    rVariables.DeformationGradientF_2D = IdentityMatrix(2,2);
+    rVariables.StrainVector_2D.resize(3);
+    rVariables.StressVector_2D.resize(3);
+    rVariables.ConstitutiveMatrix_2D.resize(3,3);
 
     if(mNeedsOOPCondensation) // avoid useless allocations
     {
-        rVariables.DeformationGradientF_3D = IdentityMatrix(3);
-        rVariables.DeformationGradientF0_3D = IdentityMatrix(3);
-        rVariables.StrainVector_3D.resize(6, false);
-        rVariables.StressVector_3D.resize(6, false);
-        rVariables.ConstitutiveMatrix_3D.resize(6,6, false);
+        rVariables.DeformationGradientF_3D = IdentityMatrix(3,3);
+        rVariables.DeformationGradientF0_3D = IdentityMatrix(3,3);
+        rVariables.StrainVector_3D.resize(6);
+        rVariables.StressVector_3D.resize(6);
+        rVariables.ConstitutiveMatrix_3D.resize(6,6);
     }
 
     // by default set the 2D data for materials
diff --git a/applications/StructuralMechanicsApplication/custom_utilities/shellq4_coordinate_transformation.hpp b/applications/StructuralMechanicsApplication/custom_utilities/shellq4_coordinate_transformation.hpp
index 3d36cb1493..f1c2f47cb5 100644
--- a/applications/StructuralMechanicsApplication/custom_utilities/shellq4_coordinate_transformation.hpp
+++ b/applications/StructuralMechanicsApplication/custom_utilities/shellq4_coordinate_transformation.hpp
@@ -142,14 +142,14 @@ namespace Kratos
 			                                                   const Vector& globalDisplacements,
 															   size_t nodeid)
 		{
-			return IdentityMatrix(3);
+			return IdentityMatrix(3,3);
 		}
 
 		virtual MatrixType GetNodalDeformationalRotationTensor(const ShellQ4_LocalCoordinateSystem & LCS,
 			                                                   const Vector& globalDisplacements,
 															   const Vector& N)
 		{
-			return IdentityMatrix(3);
+			return IdentityMatrix(3,3);
 		}
 
 	public:
diff --git a/applications/StructuralMechanicsApplication/custom_utilities/shellq4_corotational_coordinate_transformation.hpp b/applications/StructuralMechanicsApplication/custom_utilities/shellq4_corotational_coordinate_transformation.hpp
index 150837a865..3f9fbaf5fe 100644
--- a/applications/StructuralMechanicsApplication/custom_utilities/shellq4_corotational_coordinate_transformation.hpp
+++ b/applications/StructuralMechanicsApplication/custom_utilities/shellq4_corotational_coordinate_transformation.hpp
@@ -333,7 +333,7 @@ namespace Kratos
 			                                                   const Vector& globalDisplacements,
 															   size_t nodeid) override
 		{
-			if(nodeid>3) return IdentityMatrix(3);
+			if(nodeid>3) return IdentityMatrix(3,3);
 
 			QuaternionType Q = QuaternionType::FromRotationMatrix( LCS.Orientation() );
 
@@ -558,7 +558,7 @@ namespace Kratos
 
 		void load(Serializer& rSerializer) override
 		{
-			KRATOS_SERIALIZE_LOAD_BASE_CLASS(rSerializer,  ShellQ4_CoordinateTransformation );
+			KRATOS_SERIALIZE_SAVE_BASE_CLASS(rSerializer,  ShellQ4_CoordinateTransformation );
 			rSerializer.load("init", mInitialized);
 			rSerializer.load("Q0", mQ0);
 			rSerializer.load("C0", mC0);
diff --git a/applications/StructuralMechanicsApplication/custom_utilities/shellq4_local_coordinate_system.hpp b/applications/StructuralMechanicsApplication/custom_utilities/shellq4_local_coordinate_system.hpp
index 408a2194da..ad2830edec 100644
--- a/applications/StructuralMechanicsApplication/custom_utilities/shellq4_local_coordinate_system.hpp
+++ b/applications/StructuralMechanicsApplication/custom_utilities/shellq4_local_coordinate_system.hpp
@@ -244,7 +244,7 @@ namespace Kratos
 			if(W.size1() != mat_size || W.size2() != mat_size)
 				W.resize(mat_size, mat_size, false);
 
-			noalias( W ) = IdentityMatrix(mat_size);
+			noalias( W ) = IdentityMatrix(mat_size, mat_size);
 
 			W( 0,  4) = -wf;
 			W( 1,  3) =  wf;
@@ -284,7 +284,7 @@ namespace Kratos
 			// if needed, include the warpage correction.
 			if(this->IsWarped())
 			{
-				MatrixType W( IdentityMatrix(24) );
+				MatrixType W( IdentityMatrix(24, 24) );
 				RealType z1 = this->Z1();
 				RealType z2 = this->Z2();
 				RealType z3 = this->Z3();
diff --git a/applications/StructuralMechanicsApplication/custom_utilities/shellt3_coordinate_transformation.hpp b/applications/StructuralMechanicsApplication/custom_utilities/shellt3_coordinate_transformation.hpp
index 4f73e865b1..8a8d40b5b0 100644
--- a/applications/StructuralMechanicsApplication/custom_utilities/shellt3_coordinate_transformation.hpp
+++ b/applications/StructuralMechanicsApplication/custom_utilities/shellt3_coordinate_transformation.hpp
@@ -132,14 +132,14 @@ public:
             const Vector& globalDisplacements,
             size_t nodeid)
     {
-        return IdentityMatrix(3);
+        return IdentityMatrix(3,3);
     }
 
     virtual MatrixType GetNodalDeformationalRotationTensor(const ShellT3_LocalCoordinateSystem & LCS,
             const Vector& globalDisplacements,
             const Vector& N)
     {
-        return IdentityMatrix(3);
+        return IdentityMatrix(3,3);
     }
 
 public:
diff --git a/applications/StructuralMechanicsApplication/custom_utilities/shellt3_corotational_coordinate_transformation.hpp b/applications/StructuralMechanicsApplication/custom_utilities/shellt3_corotational_coordinate_transformation.hpp
index 607c5ed9cc..3da203e7c3 100644
--- a/applications/StructuralMechanicsApplication/custom_utilities/shellt3_corotational_coordinate_transformation.hpp
+++ b/applications/StructuralMechanicsApplication/custom_utilities/shellt3_corotational_coordinate_transformation.hpp
@@ -337,7 +337,7 @@ public:
             const Vector& globalDisplacements,
             size_t nodeid) override
     {
-        if(nodeid>2) return IdentityMatrix(3);
+        if(nodeid>2) return IdentityMatrix(3,3);
 
         QuaternionType Q = QuaternionType::FromRotationMatrix( LCS.Orientation() );
 
@@ -586,7 +586,7 @@ private:
 
     void load(Serializer& rSerializer) override
     {
-        KRATOS_SERIALIZE_LOAD_BASE_CLASS(rSerializer,  ShellT3_CoordinateTransformation );
+        KRATOS_SERIALIZE_SAVE_BASE_CLASS(rSerializer,  ShellT3_CoordinateTransformation );
         rSerializer.load("init", mInitialized);
         rSerializer.load("Q0", mQ0);
         rSerializer.load("C0", mC0);
diff --git a/applications/StructuralMechanicsApplication/python_scripts/automatic_rayleigh_parameters_computation_process.py b/applications/StructuralMechanicsApplication/python_scripts/automatic_rayleigh_parameters_computation_process.py
index 6e0626b214..ffde7cc176 100644
--- a/applications/StructuralMechanicsApplication/python_scripts/automatic_rayleigh_parameters_computation_process.py
+++ b/applications/StructuralMechanicsApplication/python_scripts/automatic_rayleigh_parameters_computation_process.py
@@ -72,10 +72,11 @@ class AutomaticRayleighComputationProcess(KM.Process):
         """
 
         import KratosMultiphysics.kratos_utilities as kratos_utils
-        if kratos_utils.CheckIfApplicationsAvailable("ExternalSolversApplication"):
-            from KratosMultiphysics import ExternalSolversApplication
-        elif kratos_utils.CheckIfApplicationsAvailable("EigenSolversApplication"):
-            from KratosMultiphysics import EigenSolversApplication
+        if kratos_utils.AreApplicationsAvailable(["ExternalSolversApplication", "EigenSolversApplication"]):
+            if kratos_utils.IsApplicationAvailable("ExternalSolversApplication"):
+                from KratosMultiphysics import ExternalSolversApplication
+            if kratos_utils.IsApplicationAvailable("EigenSolversApplication"):
+                from KratosMultiphysics import EigenSolversApplication
         else:
             raise Exception("ExternalSolversApplication or EigenSolversApplication not available")
 
@@ -178,7 +179,7 @@ class AutomaticRayleighComputationProcess(KM.Process):
                     "number_of_eigenvalues"      : 2,
                     "search_dimension"           : 15,
                     "linear_solver_settings": {
-                        "solver_type": "skyline_lu_complex"
+                        "solver_type": "SkylineLUComplexSolver"
                     }
                 }
             }
diff --git a/applications/StructuralMechanicsApplication/python_scripts/element_sensitivity_domain_integration_process.py b/applications/StructuralMechanicsApplication/python_scripts/element_sensitivity_domain_integration_process.py
deleted file mode 100644
index 2c7305b16f..0000000000
--- a/applications/StructuralMechanicsApplication/python_scripts/element_sensitivity_domain_integration_process.py
+++ /dev/null
@@ -1,127 +0,0 @@
-from __future__ import print_function, absolute_import, division #makes KratosMultiphysics backward compatible with python 2.6 and 2.7
-# Importing the Kratos Library
-import KratosMultiphysics
-import sys
-
-def Factory(settings, model):
-    if not isinstance(settings, KratosMultiphysics.Parameters):
-        raise Exception("Expected input shall be a Parameters object, encapsulating a json string")
-    return ElementSensitivityDomainIntegrationProcess(model, settings["Parameters"])
-
-def CheckAvailabilityOfSensitivities(variable, model_part):
-    """ Check if element sensitivities w.r.t. given variable are available.
-    Keyword arguments:
-    variable -- traced variable within sensitivity analysis.
-    model_part -- sub model part of the sensitivity model part.
-    """
-
-    if sys.version_info[0] >= 3: # python3 syntax
-        return model_part.Elements.__iter__().__next__().Has(variable)
-    else: # python2 syntax
-        return model_part.Elements.__iter__().next().Has(variable)
-
-
-class ElementSensitivityDomainIntegrationProcess(KratosMultiphysics.Process):
-    """
-        This class integrates scalar element sensitivities (material and cross-section
-        properties like CROSS_AREA or YOUNGS_MODULUS) within defined domains.
-        The integration domains are defined by sub model parts of the sensitivity model part.
-    """
-
-    def __init__(self, model, parameter):
-        """ The default constructor of the class
-
-        Keyword arguments:
-        self -- It signifies an instance of a class.
-        model -- the model contaning the model_parts
-        parameter -- Kratos parameters containing process settings.
-        """
-        KratosMultiphysics.Process.__init__(self)
-
-        ## Settings string in json format
-        default_parameters = KratosMultiphysics.Parameters("""{
-            "help"                             : "This class integrates element sensitivities within domains defined by sub model parts",
-            "element_sensitivity_variables"    : [],
-            "model_part_name"                  : "",
-            "sensitivity_model_part_name"      : "",
-            "sensitivity_sub_model_part_list"  : []
-        }""")
-
-        ## Overwrite the default settings with user-provided parameters
-        parameter.ValidateAndAssignDefaults(default_parameters)
-
-        model_part_name = parameter["model_part_name"].GetString()
-        sensitivity_model_part_name = parameter["sensitivity_model_part_name"].GetString()
-        sensitivity_sub_model_part_names = [ parameter["sensitivity_sub_model_part_list"][i].GetString() for i in range( 0, parameter["sensitivity_sub_model_part_list"].size() ) ]
-
-        # Get sensitivity model part
-        if (sensitivity_model_part_name != ""):
-            self.sensitivity_model_part = model[model_part_name].GetSubModelPart(sensitivity_model_part_name)
-        else:
-            self.sensitivity_model_part = model[model_part_name]
-
-        # Get defined sub model parts of sensitivity model part as integration domains
-        self.sensitivity_sub_model_parts = []
-        if len(sensitivity_sub_model_part_names) is 0:
-            self.sensitivity_sub_model_parts.append(self.sensitivity_model_part)
-        else:
-            for mp_name in sensitivity_sub_model_part_names:
-                self.sensitivity_sub_model_parts.append(self.sensitivity_model_part.GetSubModelPart(mp_name))
-
-        self.element_sensitivity_variables = self.__GenerateVariableListFromInput(parameter["element_sensitivity_variables"])
-
-
-    def Check(self):
-        """ This method is executed at the begining to verify that the input is correct.
-        Keyword arguments:
-        self -- It signifies an instance of a class.
-        """
-        # Check integration domains
-        for sub_mp_i in self.sensitivity_sub_model_parts:
-            if sub_mp_i.NumberOfElements() < 1:
-                raise Exception("sensitivity sub model part has no elements!")
-        return 0
-
-
-    def ExecuteFinalizeSolutionStep(self):
-        """ This method is executed in order to finalize the current step
-        Keyword arguments:
-        self -- It signifies an instance of a class.
-        """
-
-        # loop over sensitivty variables for which integration should performed
-        for variable_i in self.element_sensitivity_variables:
-            if CheckAvailabilityOfSensitivities(variable_i, self.sensitivity_model_part):
-                # loop over integration domains
-                for sub_mp_i in self.sensitivity_sub_model_parts:
-                    domain_sensitivity = KratosMultiphysics.VariableUtils().SumElementScalarVariable(variable_i, sub_mp_i)
-                    KratosMultiphysics.VariableUtils().SetNonHistoricalVariable(variable_i, domain_sensitivity, sub_mp_i.Elements)
-            else:
-                raise Exception(variable_i.Name() + " is not available for domain integration!")
-
-
-    def __GenerateVariableListFromInput(self, parameter):
-        """ Parse a list of variables from input.
-        Keyword arguments:
-        self -- It signifies an instance of a class.
-        parameter -- Kratos parameters containing process settings.
-        """
-
-        if not parameter.IsArray():
-            raise Exception("{0} Error: Variable list is unreadable".format(self.__class__.__name__))
-
-        variable_list = []
-        for i in range(0, parameter.size()):
-            variable_type = KratosMultiphysics.KratosGlobals.GetVariableType(parameter[i].GetString())
-            if (variable_type == "Double"):
-                variable_list.append(KratosMultiphysics.KratosGlobals.GetVariable( parameter[i].GetString() ))
-            else:
-                raise Exception("sensitivity domain integration is only available for variables of data type 'Double' but " + parameter[i].GetString() + " is of type '" + variable_type + "'.")
-
-        return variable_list
-
-
-
-
-
-
diff --git a/applications/StructuralMechanicsApplication/python_scripts/rve_analysis.py b/applications/StructuralMechanicsApplication/python_scripts/rve_analysis.py
deleted file mode 100644
index 6712220eae..0000000000
--- a/applications/StructuralMechanicsApplication/python_scripts/rve_analysis.py
+++ /dev/null
@@ -1,344 +0,0 @@
-# makes KratosMultiphysics backward compatible with python 2.6 and 2.7
-from __future__ import print_function, absolute_import, division
-
-import KratosMultiphysics
-import KratosMultiphysics.StructuralMechanicsApplication
-from KratosMultiphysics.StructuralMechanicsApplication.structural_mechanics_analysis import StructuralMechanicsAnalysis
-
-
-class RVEAnalysis(StructuralMechanicsAnalysis):
-    def __init__(self, model, project_parameters):
-
-        # input parameters of the analysis
-        self.boundary_mp_name = project_parameters["rve_settings"]["boundary_mp_name"].GetString()
-        self.averaging_mp_name = project_parameters["rve_settings"]["averaging_mp_name"].GetString()
-        self.print_rve_post = project_parameters["rve_settings"]["print_rve_post"].GetBool()
-        self.perturbation = project_parameters["rve_settings"]["perturbation"].GetDouble()
-
-        self.averaging_volume = -1.0  # it will be computed in initialize
-        domain_size = project_parameters["solver_settings"]["domain_size"].GetInt()
-        if(domain_size == 2):
-            self.strain_size = 3
-        else:
-            self.strain_size = 6
-
-        # Pseudo time to be used for output
-        self.time = 0.0
-
-        super(RVEAnalysis, self).__init__(model, project_parameters)
-
-    # Here populate the submodelparts to be used for periodicity
-    def ModifyInitialGeometry(self):
-        super(RVEAnalysis, self).ModifyInitialGeometry()
-
-        boundary_mp = self.model[self.boundary_mp_name]
-        averaging_mp = self.model[self.averaging_mp_name]
-
-        # Construct auxiliary modelparts
-        self.min_corner, self.max_corner = self._DetectBoundingBox(averaging_mp)
-        self._ConstructFaceModelParts(self.min_corner, self.max_corner, boundary_mp)
-
-        self.averaging_volume = (self.max_corner[0]-self.min_corner[0]) * (self.max_corner[1]-self.min_corner[1]) * (self.max_corner[2]-self.min_corner[2])
-        KratosMultiphysics.Logger.PrintInfo(self._GetSimulationName(), "RVE undeformed averaging volume = ", self.averaging_volume)
-
-    def InitializeSolutionStep(self):
-        raise Exception("Should use the _CustomInitializeSolutionStep instead of this")
-
-    def __CustomInitializeSolutionStep(self, strain, boundary_mp, averaging_mp):
-        #reset position
-        KratosMultiphysics.VariableUtils().UpdateCurrentToInitialConfiguration(averaging_mp.Nodes)
-
-        self.ApplyBoundaryConditions()  # here the processes are called
-
-        # construct MPCs according to the provided strain
-        self._ApplyPeriodicity(strain, averaging_mp, boundary_mp)
-
-        # apply BCs for RVE according to the provided strain
-        self._ApplyMinimalConstraints(
-            averaging_mp, strain, self.min_corner, self.max_corner)
-
-        self.ChangeMaterialProperties()  # this is normally empty
-
-        self._GetSolver().InitializeSolutionStep()
-
-        if self.is_printing_rank:
-            KratosMultiphysics.Logger.PrintInfo(self._GetSimulationName(), "STEP: ", self._GetSolver().GetComputingModelPart().ProcessInfo[KratosMultiphysics.STEP])
-            KratosMultiphysics.Logger.PrintInfo(self._GetSimulationName(), "TIME: ", self.time)
-
-    def RunSolutionLoop(self):
-
-        perturbation = self.perturbation
-
-        boundary_mp = self.model[self.boundary_mp_name]
-        averaging_mp = self.model[self.averaging_mp_name]
-
-        stress_and_strain = []
-        if(self.strain_size == 3):  # 2D case - ordering s00 s11 s01
-            stress_and_strain.append(self._ComputeEquivalentStress(0, 0, perturbation, boundary_mp, averaging_mp))
-            stress_and_strain.append(self._ComputeEquivalentStress(1, 1, perturbation, boundary_mp, averaging_mp))
-            stress_and_strain.append(self._ComputeEquivalentStress(0, 1, perturbation, boundary_mp, averaging_mp))
-        elif(self.strain_size == 6):  # 3D case - ordering:  s00 s11 s22 s01 s12 s02
-            stress_and_strain.append(self._ComputeEquivalentStress(0, 0, perturbation, boundary_mp, averaging_mp))
-            stress_and_strain.append(self._ComputeEquivalentStress(1, 1, perturbation, boundary_mp, averaging_mp))
-            stress_and_strain.append(self._ComputeEquivalentStress(2, 2, perturbation, boundary_mp, averaging_mp))
-            stress_and_strain.append(self._ComputeEquivalentStress(0, 1, perturbation, boundary_mp, averaging_mp))
-            stress_and_strain.append(self._ComputeEquivalentStress(1, 2, perturbation, boundary_mp, averaging_mp))
-            stress_and_strain.append(self._ComputeEquivalentStress(0, 2, perturbation, boundary_mp, averaging_mp))
-
-        C = self._ComputeEquivalentElasticTensor(stress_and_strain, perturbation)
-        averaging_mp.SetValue(KratosMultiphysics.StructuralMechanicsApplication.ELASTICITY_TENSOR, C)
-        self._MatrixOutput(C)
-
-    def _DetectBoundingBox(self, mp):
-        min_corner = KratosMultiphysics.Array3()
-        min_corner[0] = 1e20
-        min_corner[1] = 1e20
-        min_corner[2] = 1e20
-
-        max_corner = KratosMultiphysics.Array3()
-        max_corner[0] = -1e20
-        max_corner[1] = -1e20
-        max_corner[2] = -1e20
-
-        for node in mp.Nodes:
-            x = node.X
-            min_corner[0] = min(min_corner[0], x)
-            max_corner[0] = max(max_corner[0], x)
-
-            y = node.Y
-            min_corner[1] = min(min_corner[1], y)
-            max_corner[1] = max(max_corner[1], y)
-
-            z = node.Z
-            min_corner[2] = min(min_corner[2], z)
-            max_corner[2] = max(max_corner[2], z)
-
-        KratosMultiphysics.Logger.PrintInfo(self._GetSimulationName(), "Boundng box detected")
-        KratosMultiphysics.Logger.PrintInfo(self._GetSimulationName(), "Min. corner = ", min_corner)
-        KratosMultiphysics.Logger.PrintInfo(self._GetSimulationName(), "Max. corner = ", max_corner)
-
-        return min_corner, max_corner
-
-    def __PopulateMp(self, face_name, coordinate, component, eps, mp):
-        if mp.NumberOfConditions() == 0:
-            raise Exception("Boundary_mp is expected to have conditions and has none")
-
-        mp = mp.GetRootModelPart()
-
-        if not mp.HasSubModelPart(face_name):
-            mp.CreateSubModelPart(face_name)
-        face_mp = mp.GetSubModelPart(face_name)
-
-        for cond in mp.Conditions:
-            xc = cond.GetGeometry().Center()
-            if abs(xc[component]-coordinate) < eps:
-                face_mp.AddCondition(cond)
-
-        node_ids = set()
-        for cond in face_mp.Conditions:
-            for node in cond.GetNodes():
-                if(not node.Is(KratosMultiphysics.SLAVE)):
-                    node_ids.add(node.Id)
-                    node.Set(KratosMultiphysics.SLAVE)
-
-        face_mp.AddNodes(list(node_ids))
-        return face_mp
-
-    def _ConstructFaceModelParts(self, min_corner, max_corner, mp):
-
-        eps = 0.0001*(max_corner[0] - min_corner[0])/mp.NumberOfNodes()
-
-        KratosMultiphysics.VariableUtils().SetFlag(KratosMultiphysics.SLAVE, False, mp.Nodes)
-        KratosMultiphysics.VariableUtils().SetFlag(KratosMultiphysics.MASTER, False, mp.Nodes)
-
-        # Populate the slave faces
-        self.max_x_face = self.__PopulateMp("max_x_face", max_corner[0], 0, eps, mp)
-        self.max_y_face = self.__PopulateMp("max_y_face", max_corner[1], 1, eps, mp)
-        self.max_z_face = self.__PopulateMp("max_z_face", max_corner[2], 2, eps, mp)
-
-        # First populate the master faces (min)
-        self.min_x_face = self.__PopulateMp("min_x_face", min_corner[0], 0, eps, mp)
-        self.min_y_face = self.__PopulateMp("min_y_face", min_corner[1], 1, eps, mp)
-        self.min_z_face = self.__PopulateMp("min_z_face", min_corner[2], 2, eps, mp)
-
-        if self.min_x_face.NumberOfConditions() == 0:
-            raise Exception("min_x_face has 0 conditions")
-        if self.min_y_face.NumberOfConditions() == 0:
-            raise Exception("min_y_face has 0 conditions")
-        if self.min_z_face.NumberOfConditions() == 0:
-            raise Exception("min_z_face has 0 conditions")
-
-    def _SelectClosestNode(self, mp, coords):
-        min_distance = 1e30
-        selected_node = 0
-        for node in mp.Nodes:
-            dx = node.X0 - coords[0]
-            dy = node.Y0 - coords[1]
-            dz = node.Z0 - coords[2]
-            d = dx**2 + dy**2 + dz**2
-
-            if(d < min_distance):
-                selected_node = node
-                min_distance = d
-
-        return selected_node
-
-    # prescribed conditions to avoid rigid body motions
-    def _ApplyMinimalConstraints(self, mp, strain, min_corner, max_corner):
-        aux = KratosMultiphysics.Array3()
-
-        # point coinciding with the min_corner
-        node = self._SelectClosestNode(mp, min_corner)
-        node.Fix(KratosMultiphysics.DISPLACEMENT_X)
-        node.Fix(KratosMultiphysics.DISPLACEMENT_Y)
-        node.Fix(KratosMultiphysics.DISPLACEMENT_Z)
-
-        coords_min_corner = KratosMultiphysics.Array3(node)
-        coords_min_corner[0] = node.X0
-        coords_min_corner[1] = node.Y0
-        coords_min_corner[2] = node.Z0
-
-        disp_min_corner = strain*coords_min_corner
-        node.SetSolutionStepValue(
-            KratosMultiphysics.DISPLACEMENT, 0, disp_min_corner)
-
-    def _ComputeEquivalentElasticTensor(self, stress_and_strain, perturbation):
-        C = KratosMultiphysics.Matrix(self.strain_size, self.strain_size)
-
-        for j in range(len(stress_and_strain)):
-            stress = stress_and_strain[j][0]
-            for i in range(self.strain_size):
-                C[i, j] = stress[i]
-
-        inverse_perturbation = KratosMultiphysics.Matrix(self.strain_size, self.strain_size)
-        inverse_perturbation.fill(0.0)
-        if(self.strain_size == 3):
-            inverse_perturbation[0, 0] = 1.0/perturbation
-            inverse_perturbation[1, 1] = 1.0/perturbation
-            inverse_perturbation[2, 2] = 0.5/perturbation
-        else:
-            inverse_perturbation[0, 0] = 1.0/perturbation
-            inverse_perturbation[1, 1] = 1.0/perturbation
-            inverse_perturbation[2, 2] = 1.0/perturbation
-            inverse_perturbation[3, 3] = 0.5/perturbation
-            inverse_perturbation[4, 4] = 0.5/perturbation
-            inverse_perturbation[5, 5] = 0.5/perturbation
-
-        C = C*inverse_perturbation
-
-        return C
-
-    def _MatrixOutput(self, C, filename="rve_elasticity_tensor.txt"):
-        f = open(filename, 'w')
-
-        if(self.strain_size == 3):  # 2D
-            f.write(str(C[0, 0]) + " " + str(C[0, 1]) +
-                    " " + str(C[0, 2]) + "\n")
-            f.write(str(C[1, 0]) + " " + str(C[1, 1]) +
-                    " " + str(C[1, 2]) + "\n")
-            f.write(str(C[2, 0]) + " " + str(C[2, 1]) +
-                    " " + str(C[2, 2]) + "\n")
-
-        elif(self.strain_size == 6):
-            for i in range(6):
-                f.write(str(C[i, 0]) + " " + str(C[i, 1]) + " " + str(C[i, 2]) +
-                        " " + str(C[i, 3]) + " " + str(C[i, 4]) + " " + str(C[i, 5]) + "\n")
-
-        f.close()
-
-    def _ComputeEquivalentStress(self, i, j, perturbation, boundary_mp, averaging_mp):
-        # Here use a pseudotime for output
-        self.time = self.time + 1.0
-        averaging_mp.GetRootModelPart().CloneTimeStep(self.time)
-
-        strain = KratosMultiphysics.Matrix(3, 3)
-        strain.fill(0.0)
-
-        strain[i, j] = perturbation
-        strain[j, i] = perturbation
-
-        strain_vector = KratosMultiphysics.Vector(self.strain_size)
-        if(self.strain_size == 2):
-            strain_vector[0] = strain[0, 0]
-            strain_vector[1] = strain[1, 1]
-            strain_vector[2] = 2.0*strain[1, 2]
-        elif(self.strain_size == 6):
-            strain_vector[0] = strain[0, 0]
-            strain_vector[1] = strain[1, 1]
-            strain_vector[2] = strain[2, 2]
-            strain_vector[3] = 2.0*strain[0, 1]
-            strain_vector[4] = 2.0*strain[1, 2]
-            strain_vector[5] = 2.0*strain[0, 2]
-
-        self.__CustomInitializeSolutionStep(strain, boundary_mp, averaging_mp)
-
-        self._GetSolver().Predict()
-
-        self._GetSolver().SolveSolutionStep()
-        process_info = averaging_mp.ProcessInfo
-        avg_stress = KratosMultiphysics.Vector(self.strain_size)
-        avg_stress.fill(0.0)
-        measured_volume = 0.0
-
-        for elem in averaging_mp.Elements:
-            tmp = elem.CalculateOnIntegrationPoints(KratosMultiphysics.PK2_STRESS_VECTOR, process_info)
-            ngauss = len(tmp)
-            A = elem.GetGeometry().Area()
-            measured_volume += A
-            # TODO: this is only valid for gauss points with the same weight. should be generalized
-            Agauss = A/ngauss
-            for item in tmp:
-                avg_stress = avg_stress + item*Agauss
-
-        self._GetSolver().Clear()
-
-        KratosMultiphysics.Logger.PrintInfo(
-            self._GetSimulationName(), "Measured volume = ", measured_volume)
-
-        avg_stress /= self.averaging_volume
-
-        KratosMultiphysics.Logger.PrintInfo(
-            self._GetSimulationName(), "Applied strain = ", strain_vector)
-        KratosMultiphysics.Logger.PrintInfo(
-            self._GetSimulationName(), "Average stress = ", avg_stress)
-
-        if self.print_rve_post:
-            self.OutputSolutionStep()
-
-        # Reset position of nodes
-        KratosMultiphysics.VariableUtils().UpdateCurrentToInitialConfiguration(averaging_mp.Nodes)
-        zero = KratosMultiphysics.Vector(3)
-        zero[0] = 0.0
-        zero[1] = 0.0
-        zero[2] = 0.0
-        KratosMultiphysics.VariableUtils().SetNonHistoricalVariable(KratosMultiphysics.DISPLACEMENT, zero, averaging_mp.Nodes)
-        return avg_stress, strain_vector
-
-    def _ApplyPeriodicity(self, strain, volume_mp, boundary_mp):
-        # clear
-        for constraint in volume_mp.GetRootModelPart().MasterSlaveConstraints:
-            constraint.Set(KratosMultiphysics.TO_ERASE)
-        volume_mp.GetRootModelPart().RemoveMasterSlaveConstraintsFromAllLevels(
-            KratosMultiphysics.TO_ERASE)
-
-        dx = self.max_corner[0] - self.min_corner[0]
-        dy = self.max_corner[1] - self.min_corner[1]
-        dz = self.max_corner[2] - self.min_corner[2]
-
-        periodicity_utility = KratosMultiphysics.StructuralMechanicsApplication.RVEPeriodicityUtility(self._GetSolver().GetComputingModelPart())
-
-        # assign periodicity to faces
-        periodicity_utility.AssignPeriodicity(self.min_x_face, self.max_x_face, strain, KratosMultiphysics.Vector([dx, 0.0, 0.0]))
-        periodicity_utility.AssignPeriodicity(self.min_y_face, self.max_y_face, strain, KratosMultiphysics.Vector([0.0, dy, 0.0]))
-        periodicity_utility.AssignPeriodicity(self.min_z_face, self.max_z_face, strain, KratosMultiphysics.Vector([0.0, 0.0, dz]))
-
-        periodicity_utility.Finalize(KratosMultiphysics.DISPLACEMENT)
-
-        # start from the exact solution in the case of a constant strain
-        x = KratosMultiphysics.Array3()
-        for node in volume_mp.Nodes:
-            x[0] = node.X0
-            x[1] = node.Y0
-            x[2] = node.Z0
-            d = strain*x
-            node.SetSolutionStepValue(KratosMultiphysics.DISPLACEMENT, 0, d)
diff --git a/applications/StructuralMechanicsApplication/python_scripts/structural_mechanics_adjoint_static_solver.py b/applications/StructuralMechanicsApplication/python_scripts/structural_mechanics_adjoint_static_solver.py
index 6c98bad5de..b693206b74 100644
--- a/applications/StructuralMechanicsApplication/python_scripts/structural_mechanics_adjoint_static_solver.py
+++ b/applications/StructuralMechanicsApplication/python_scripts/structural_mechanics_adjoint_static_solver.py
@@ -15,6 +15,17 @@ class StructuralMechanicsAdjointStaticSolver(structural_mechanics_solver.Mechani
 
     def __init__(self, model, custom_settings):
 
+        adjoint_settings = KratosMultiphysics.Parameters("""
+        {
+            "scheme_settings" : {
+                "scheme_type": "adjoint_structural"
+            }
+        }
+        """)
+
+        self.validate_and_transfer_matching_settings(custom_settings, adjoint_settings)
+        self.scheme_settings = adjoint_settings["scheme_settings"]
+
         self.response_function_settings = custom_settings["response_function_settings"].Clone()
         self.sensitivity_settings = custom_settings["sensitivity_settings"].Clone()
         custom_settings.RemoveValue("response_function_settings")
@@ -65,7 +76,6 @@ class StructuralMechanicsAdjointStaticSolver(structural_mechanics_solver.Mechani
         self.adjoint_postprocess.Initialize()
 
         super(StructuralMechanicsAdjointStaticSolver, self).Initialize()
-        self.response_function.Initialize()
 
         self.print_on_rank_zero("::[AdjointMechanicalSolver]:: ", "Finished initialization.")
 
@@ -76,13 +86,14 @@ class StructuralMechanicsAdjointStaticSolver(structural_mechanics_solver.Mechani
     def FinalizeSolutionStep(self):
         super(StructuralMechanicsAdjointStaticSolver, self).FinalizeSolutionStep()
         self.response_function.FinalizeSolutionStep()
-        self.adjoint_postprocess.UpdateSensitivities()
 
     def SolveSolutionStep(self):
         if self.response_function_settings["response_type"].GetString() == "adjoint_linear_strain_energy":
             self._SolveSolutionStepSpecialLinearStrainEnergy()
         else:
             super(StructuralMechanicsAdjointStaticSolver, self).SolveSolutionStep()
+        #after adjoint solution, calculate sensitivities
+        self.adjoint_postprocess.UpdateSensitivities() # TODO call postprocess here or in FinalizeSolutionStep ?
 
     def _SolveSolutionStepSpecialLinearStrainEnergy(self):
         for node in self.main_model_part.Nodes:
@@ -107,4 +118,5 @@ class StructuralMechanicsAdjointStaticSolver(structural_mechanics_solver.Mechani
         return mechanical_solution_strategy
 
     def _create_solution_scheme(self):
-        return KratosMultiphysics.ResidualBasedAdjointStaticScheme(self.response_function)
+        self.scheme_settings.AddValue("rotation_dofs",self.settings["rotation_dofs"])
+        return StructuralMechanicsApplication.AdjointStructuralStaticScheme(self.scheme_settings, self.response_function)
diff --git a/applications/StructuralMechanicsApplication/python_scripts/structural_mechanics_explicit_dynamic_solver.py b/applications/StructuralMechanicsApplication/python_scripts/structural_mechanics_explicit_dynamic_solver.py
index 9dc2cd30e1..30681a6257 100644
--- a/applications/StructuralMechanicsApplication/python_scripts/structural_mechanics_explicit_dynamic_solver.py
+++ b/applications/StructuralMechanicsApplication/python_scripts/structural_mechanics_explicit_dynamic_solver.py
@@ -29,8 +29,7 @@ class ExplicitMechanicalSolver(structural_mechanics_solver.MechanicalSolver):
         {
             "scheme_type"                : "central_differences",
             "time_step_prediction_level" : 0,
-            "delta_time_refresh"         : 1000,
-            "max_delta_time"             : 1.0e0,
+            "max_delta_time"             : 1.0e-5,
             "fraction_delta_time"        : 0.9,
             "rayleigh_alpha"             : 0.0,
             "rayleigh_beta"              : 0.0
@@ -40,9 +39,6 @@ class ExplicitMechanicalSolver(structural_mechanics_solver.MechanicalSolver):
         self.validate_and_transfer_matching_settings(custom_settings, self.dynamic_settings)
         # Validate the remaining settings in the base class.
 
-        # Delta time refresh counter
-        self.delta_time_refresh_counter = self.dynamic_settings["delta_time_refresh"].GetInt()
-
         # Construct the base solver.
         super(ExplicitMechanicalSolver, self).__init__(model, custom_settings)
         # Lumped mass-matrix is necessary for explicit analysis
@@ -72,11 +68,7 @@ class ExplicitMechanicalSolver(structural_mechanics_solver.MechanicalSolver):
             
     def ComputeDeltaTime(self):
         if self.dynamic_settings["time_step_prediction_level"].GetInt() > 1:
-            if self.delta_time_refresh_counter >= self.dynamic_settings["delta_time_refresh"].GetInt():
-                self.delta_time = StructuralMechanicsApplication.CalculateDeltaTime(self.GetComputingModelPart(), self.delta_time_settings)
-                self.delta_time_refresh_counter = 0
-            else:
-                self.delta_time_refresh_counter += 1
+            self.delta_time = StructuralMechanicsApplication.CalculateDeltaTime(self.GetComputingModelPart(), self.delta_time_settings)
         return self.delta_time
 
     def Initialize(self):
diff --git a/applications/StructuralMechanicsApplication/python_scripts/structural_mechanics_implicit_dynamic_solver.py b/applications/StructuralMechanicsApplication/python_scripts/structural_mechanics_implicit_dynamic_solver.py
index a8a63372d3..d87d446ead 100644
--- a/applications/StructuralMechanicsApplication/python_scripts/structural_mechanics_implicit_dynamic_solver.py
+++ b/applications/StructuralMechanicsApplication/python_scripts/structural_mechanics_implicit_dynamic_solver.py
@@ -31,7 +31,6 @@ class ImplicitMechanicalSolver(structural_mechanics_solver.MechanicalSolver):
         {
             "scheme_type"   : "bossak",
             "damp_factor_m" :-0.3,
-            "newmark_beta" : 0.25,
             "rayleigh_alpha": 0.0,
             "rayleigh_beta" : 0.0
         }
@@ -82,12 +81,10 @@ class ImplicitMechanicalSolver(structural_mechanics_solver.MechanicalSolver):
         # Setting the time integration schemes
         if(scheme_type == "newmark"):
             damp_factor_m = 0.0
-            newmark_beta = self.dynamic_settings["newmark_beta"].GetDouble()
-            mechanical_scheme = KratosMultiphysics.ResidualBasedBossakDisplacementScheme(damp_factor_m, newmark_beta)
+            mechanical_scheme = KratosMultiphysics.ResidualBasedBossakDisplacementScheme(damp_factor_m)
         elif(scheme_type == "bossak"):
             damp_factor_m = self.dynamic_settings["damp_factor_m"].GetDouble()
-            newmark_beta = self.dynamic_settings["newmark_beta"].GetDouble()
-            mechanical_scheme = KratosMultiphysics.ResidualBasedBossakDisplacementScheme(damp_factor_m, newmark_beta)
+            mechanical_scheme = KratosMultiphysics.ResidualBasedBossakDisplacementScheme(damp_factor_m)
         elif(scheme_type == "pseudo_static"):
             mechanical_scheme = KratosMultiphysics.ResidualBasedPseudoStaticDisplacementScheme(StructuralMechanicsApplication.RAYLEIGH_BETA)
         elif(scheme_type.startswith("bdf") or scheme_type == "backward_euler"):
diff --git a/applications/StructuralMechanicsApplication/python_scripts/structural_mechanics_solver.py b/applications/StructuralMechanicsApplication/python_scripts/structural_mechanics_solver.py
index db46338288..794fe2ea88 100755
--- a/applications/StructuralMechanicsApplication/python_scripts/structural_mechanics_solver.py
+++ b/applications/StructuralMechanicsApplication/python_scripts/structural_mechanics_solver.py
@@ -415,9 +415,9 @@ class MechanicalSolver(PythonSolver):
         else:
             # using a default linear solver (selecting the fastest one available)
             import KratosMultiphysics.kratos_utilities as kratos_utils
-            if kratos_utils.CheckIfApplicationsAvailable("EigenSolversApplication"):
+            if kratos_utils.IsApplicationAvailable("EigenSolversApplication"):
                 from KratosMultiphysics import EigenSolversApplication
-            elif kratos_utils.CheckIfApplicationsAvailable("ExternalSolversApplication"):
+            elif kratos_utils.IsApplicationAvailable("ExternalSolversApplication"):
                 from KratosMultiphysics import ExternalSolversApplication
 
             linear_solvers_by_speed = [
diff --git a/applications/StructuralMechanicsApplication/python_scripts/structural_response.py b/applications/StructuralMechanicsApplication/python_scripts/structural_response.py
index 7655a4eb64..d3b4f8e4a5 100755
--- a/applications/StructuralMechanicsApplication/python_scripts/structural_response.py
+++ b/applications/StructuralMechanicsApplication/python_scripts/structural_response.py
@@ -297,6 +297,7 @@ class AdjointResponseFunction(ResponseFunctionBase):
         self.adjoint_analysis.Initialize()
 
     def InitializeSolutionStep(self):
+
         # Run the primal analysis.
         # TODO if primal_analysis.status==solved: return
         Logger.PrintInfo("\n> Starting primal analysis for response:", self.identifier)
@@ -306,6 +307,16 @@ class AdjointResponseFunction(ResponseFunctionBase):
         self.primal_analysis.RunSolutionLoop()
         Logger.PrintInfo("> Time needed for solving the primal analysis = ",round(timer.time() - startTime,2),"s")
 
+        # TODO the response value calculation for stresses currently only works on the adjoint modelpart
+        # this needs to be improved, also the response value should be calculated on the PRIMAL modelpart!!
+        self.adjoint_analysis.time = self.adjoint_analysis._GetSolver().AdvanceInTime(self.adjoint_analysis.time)
+
+        # synchronize the modelparts
+        self._SynchronizeAdjointFromPrimal()
+
+        self.adjoint_analysis.InitializeSolutionStep()
+
+
     def CalculateValue(self):
         startTime = timer.time()
         value = self._GetResponseFunctionUtility().CalculateValue(self.primal_model_part)
@@ -313,32 +324,40 @@ class AdjointResponseFunction(ResponseFunctionBase):
 
         self.primal_model_part.ProcessInfo[StructuralMechanicsApplication.RESPONSE_VALUE] = value
 
+
     def CalculateGradient(self):
-        # synchronize the modelparts
-        self._SynchronizeAdjointFromPrimal()
-        startTime = timer.time()
         Logger.PrintInfo("\n> Starting adjoint analysis for response:", self.identifier)
-        if not self.adjoint_analysis.time < self.adjoint_analysis.end_time:
-            self.adjoint_analysis.end_time += 1
-        self.adjoint_analysis.RunSolutionLoop()
+        startTime = timer.time()
+        self.adjoint_analysis._GetSolver().Predict()
+        self.adjoint_analysis._GetSolver().SolveSolutionStep()
         Logger.PrintInfo("> Time needed for solving the adjoint analysis = ",round(timer.time() - startTime,2),"s")
 
+
     def GetValue(self):
         return self.primal_model_part.ProcessInfo[StructuralMechanicsApplication.RESPONSE_VALUE]
 
+
     def GetShapeGradient(self):
         gradient = {}
         for node in self.adjoint_model_part.Nodes:
             gradient[node.Id] = node.GetSolutionStepValue(KratosMultiphysics.SHAPE_SENSITIVITY)
         return gradient
 
+
+    def FinalizeSolutionStep(self):
+        self.adjoint_analysis.FinalizeSolutionStep()
+        self.adjoint_analysis.OutputSolutionStep()
+
+
     def Finalize(self):
         self.primal_analysis.Finalize()
         self.adjoint_analysis.Finalize()
 
+
     def _GetResponseFunctionUtility(self):
         return self.adjoint_analysis._GetSolver().response_function
 
+
     def _SynchronizeAdjointFromPrimal(self):
         Logger.PrintInfo("\n> Synchronize primal and adjoint modelpart for response:", self.identifier)
 
@@ -396,16 +415,17 @@ class AdjointResponseFunction(ResponseFunctionBase):
                 solver_settings.AddEmptyValue("move_mesh_flag")
             solver_settings["move_mesh_flag"].SetBool(False)
 
-            if solver_settings.Has("scheme_settings"):
-                depr_msg = '\nDEPRECATION-WARNING: "scheme_settings" is deprecated, please remove it from your json parameters.\n'
-                KratosMultiphysics.Logger.PrintWarning(__name__, depr_msg)
-                solver_settings.RemoveValue("scheme_settings")
+            if not solver_settings.Has("scheme_settings"):
+                tmp = solver_settings.AddEmptyValue("scheme_settings")
+                if not tmp.Has("scheme_type"):
+                    tmp.AddEmptyValue("scheme_type")
+            solver_settings["scheme_settings"]["scheme_type"].SetString("adjoint_structural")
 
             # Dirichlet conditions: change variables
             for i in range(0,primal_parameters["processes"]["constraints_process_list"].size()):
                 process = adjoint_parameters["processes"]["constraints_process_list"][i]
                 variable_name = process["Parameters"]["variable_name"].GetString()
-                process["Parameters"]["variable_name"].SetString("ADJOINT_"+variable_name)
+            process["Parameters"]["variable_name"].SetString("ADJOINT_"+variable_name)
 
             # Neumann conditions - do not modify to read the same load values as in primal:
 
diff --git a/applications/StructuralMechanicsApplication/structural_mechanics_application.cpp b/applications/StructuralMechanicsApplication/structural_mechanics_application.cpp
index fb5d7c6f71..933951ab6f 100644
--- a/applications/StructuralMechanicsApplication/structural_mechanics_application.cpp
+++ b/applications/StructuralMechanicsApplication/structural_mechanics_application.cpp
@@ -193,8 +193,6 @@ void KratosStructuralMechanicsApplication::Register() {
     KRATOS_REGISTER_VARIABLE(LOCAL_MATERIAL_AXIS_3);
     KRATOS_REGISTER_VARIABLE(CENTER_OF_GRAVITY);
     KRATOS_REGISTER_VARIABLE(MASS_MOMENT_OF_INERTIA);
-    KRATOS_REGISTER_VARIABLE(ELASTICITY_TENSOR);
-
 
     // Generalized eigenvalue problem
     KRATOS_REGISTER_VARIABLE(BUILD_LEVEL)
@@ -384,8 +382,6 @@ void KratosStructuralMechanicsApplication::Register() {
     KRATOS_REGISTER_VARIABLE(EFFECTIVE_COMPRESSION_STRESS_VECTOR)
     KRATOS_REGISTER_VARIABLE(EXPONENTIAL_SATURATION_YIELD_STRESS)
     KRATOS_REGISTER_VARIABLE(ACCUMULATED_PLASTIC_STRAIN)
-    KRATOS_REGISTER_VARIABLE(BACK_STRESS_VECTOR)
-    KRATOS_REGISTER_VARIABLE(BACK_STRESS_TENSOR)
 
     // D+D- Damage Constitutive laws variables
     KRATOS_REGISTER_VARIABLE(DAMAGE_TENSION)
@@ -396,18 +392,6 @@ void KratosStructuralMechanicsApplication::Register() {
     KRATOS_REGISTER_VARIABLE(UNIAXIAL_STRESS_COMPRESSION)
     KRATOS_REGISTER_VARIABLE(FRACTURE_ENERGY_COMPRESSION)
 
-    // D+D- Damage Constitutive laws variables, additional Masonry 2D & 3D
-    KRATOS_REGISTER_VARIABLE(DAMAGE_ONSET_STRESS_COMPRESSION)
-    KRATOS_REGISTER_VARIABLE(BIAXIAL_COMPRESSION_MULTIPLIER)
-    KRATOS_REGISTER_VARIABLE(FRACTURE_ENERGY_TENSION)
-    KRATOS_REGISTER_VARIABLE(RESIDUAL_STRESS_COMPRESSION)
-    KRATOS_REGISTER_VARIABLE(BEZIER_CONTROLLER_C1)
-    KRATOS_REGISTER_VARIABLE(BEZIER_CONTROLLER_C2)
-    KRATOS_REGISTER_VARIABLE(BEZIER_CONTROLLER_C3)
-    KRATOS_REGISTER_VARIABLE(YIELD_STRAIN_COMPRESSION)
-    KRATOS_REGISTER_VARIABLE(SHEAR_COMPRESSION_REDUCTOR)
-    KRATOS_REGISTER_VARIABLE(TRIAXIAL_COMPRESSION_COEFFICIENT)
-
     // Response function variables
     KRATOS_REGISTER_VARIABLE(RESPONSE_VALUE)
     // Adjoint variables
@@ -597,8 +581,8 @@ void KratosStructuralMechanicsApplication::Register() {
     KRATOS_REGISTER_CONSTITUTIVE_LAW("HyperElasticPlaneStrain2DLaw", mHyperElasticIsotropicNeoHookeanPlaneStrain2D);
     KRATOS_REGISTER_CONSTITUTIVE_LAW("SmallStrainJ2PlasticityPlaneStrain2DLaw", mSmallStrainJ2PlasticityPlaneStrain2D);
     KRATOS_REGISTER_CONSTITUTIVE_LAW("SmallStrainJ2Plasticity3DLaw", mSmallStrainJ2Plasticity3D);
-    KRATOS_REGISTER_CONSTITUTIVE_LAW("SmallStrainIsotropicDamagePlaneStrain2DLaw", mSmallStrainIsotropicDamagePlaneStrain2D);
-    KRATOS_REGISTER_CONSTITUTIVE_LAW("SmallStrainIsotropicDamage3DLaw", mSmallStrainIsotropicDamage3D);
+    KRATOS_REGISTER_CONSTITUTIVE_LAW("LinearIsotropicDamagePlaneStrain2DLaw", mLinearIsotropicDamagePlaneStrain2D);
+    KRATOS_REGISTER_CONSTITUTIVE_LAW("LinearIsotropicDamage3DLaw", mLinearIsotropicDamage3D);
 
     // Damage and plasticity
     KRATOS_REGISTER_CONSTITUTIVE_LAW("SmallStrainIsotropicPlasticityFactory", mSmallStrainIsotropicPlasticityFactory);
@@ -879,7 +863,5 @@ void KratosStructuralMechanicsApplication::Register() {
     KRATOS_REGISTER_CONSTITUTIVE_LAW("SmallStrainDplusDminusDamageVonMisesMohrCoulomb2D", mSmallStrainDplusDminusDamageVonMisesMohrCoulomb2D);
     KRATOS_REGISTER_CONSTITUTIVE_LAW("SmallStrainDplusDminusDamageTrescaMohrCoulomb2D", mSmallStrainDplusDminusDamageTrescaMohrCoulomb2D);
     KRATOS_REGISTER_CONSTITUTIVE_LAW("SmallStrainDplusDminusDamageDruckerPragerMohrCoulomb2D", mSmallStrainDplusDminusDamageDruckerPragerMohrCoulomb2D);
-    KRATOS_REGISTER_CONSTITUTIVE_LAW("DamageDPlusDMinusPlaneStressMasonry2DLaw", mDamageDPlusDMinusPlaneStressMasonry2DLaw);
-    KRATOS_REGISTER_CONSTITUTIVE_LAW("DamageDPlusDMinusMasonry3DLaw", mDamageDPlusDMinusMasonry3DLaw);
 }
 }  // namespace Kratos.
diff --git a/applications/StructuralMechanicsApplication/structural_mechanics_application.h b/applications/StructuralMechanicsApplication/structural_mechanics_application.h
index a97a63cf37..b5a571dabf 100644
--- a/applications/StructuralMechanicsApplication/structural_mechanics_application.h
+++ b/applications/StructuralMechanicsApplication/structural_mechanics_application.h
@@ -98,10 +98,8 @@
 #include "custom_constitutive/linear_elastic_orthotropic_2D_law.h"
 #include "custom_constitutive/small_strain_j2_plasticity_plane_strain_2d.h"
 #include "custom_constitutive/small_strain_j2_plasticity_3d.h"
-#include "custom_constitutive/small_strain_isotropic_damage_3d.h"
-#include "custom_constitutive/small_strain_isotropic_damage_plane_strain_2d.h"
-#include "custom_constitutive/plane_stress_d_plus_d_minus_damage_masonry_2d.h"
-#include "custom_constitutive/d_plus_d_minus_damage_masonry_3d.h"
+#include "custom_constitutive/linear_isotropic_damage_3D_law.h"
+#include "custom_constitutive/linear_isotropic_damage_plane_strain_2d.h"
 
 // Advanced Constitutive laws
 #include "custom_constitutive/small_strain_isotropic_plasticity_factory.h"
@@ -461,8 +459,8 @@ private:
 
     const SmallStrainJ2Plasticity3D mSmallStrainJ2Plasticity3D;
     const SmallStrainJ2PlasticityPlaneStrain2D mSmallStrainJ2PlasticityPlaneStrain2D;
-    const SmallStrainIsotropicDamage3D mSmallStrainIsotropicDamage3D;
-    const SmallStrainIsotropicDamagePlaneStrain2D mSmallStrainIsotropicDamagePlaneStrain2D;
+    const LinearIsotropicDamage3D mLinearIsotropicDamage3D;
+    const LinearIsotropicDamagePlaneStrain2D mLinearIsotropicDamagePlaneStrain2D;
 
     // Damage and plasticity laws
     const SmallStrainIsotropicPlasticityFactory mSmallStrainIsotropicPlasticityFactory;
@@ -739,8 +737,6 @@ private:
     const GenericSmallStrainDplusDminusDamage<GenericTensionConstitutiveLawIntegratorDplusDminusDamage<VonMisesYieldSurface<VonMisesPlasticPotential<3>>>, GenericCompressionConstitutiveLawIntegratorDplusDminusDamage<MohrCoulombYieldSurface<VonMisesPlasticPotential<3>>>> mSmallStrainDplusDminusDamageVonMisesMohrCoulomb2D;
     const GenericSmallStrainDplusDminusDamage<GenericTensionConstitutiveLawIntegratorDplusDminusDamage<TrescaYieldSurface<VonMisesPlasticPotential<3>>>, GenericCompressionConstitutiveLawIntegratorDplusDminusDamage<MohrCoulombYieldSurface<VonMisesPlasticPotential<3>>>> mSmallStrainDplusDminusDamageTrescaMohrCoulomb2D;
     const GenericSmallStrainDplusDminusDamage<GenericTensionConstitutiveLawIntegratorDplusDminusDamage<DruckerPragerYieldSurface<VonMisesPlasticPotential<3>>>, GenericCompressionConstitutiveLawIntegratorDplusDminusDamage<MohrCoulombYieldSurface<VonMisesPlasticPotential<3>>>> mSmallStrainDplusDminusDamageDruckerPragerMohrCoulomb2D;
-    const DamageDPlusDMinusMasonry2DLaw mDamageDPlusDMinusPlaneStressMasonry2DLaw;
-    const DamageDPlusDMinusMasonry3DLaw mDamageDPlusDMinusMasonry3DLaw;
     ///@}
     ///@name Private Operators
     ///@{
diff --git a/applications/StructuralMechanicsApplication/structural_mechanics_application_variables.cpp b/applications/StructuralMechanicsApplication/structural_mechanics_application_variables.cpp
index 63dd2c3dc0..77fbbee589 100644
--- a/applications/StructuralMechanicsApplication/structural_mechanics_application_variables.cpp
+++ b/applications/StructuralMechanicsApplication/structural_mechanics_application_variables.cpp
@@ -22,7 +22,6 @@ KRATOS_CREATE_3D_VARIABLE_WITH_COMPONENTS(LOCAL_MATERIAL_AXIS_2)
 KRATOS_CREATE_3D_VARIABLE_WITH_COMPONENTS(LOCAL_MATERIAL_AXIS_3)
 KRATOS_CREATE_3D_VARIABLE_WITH_COMPONENTS(CENTER_OF_GRAVITY)
 KRATOS_CREATE_VARIABLE(double, MASS_MOMENT_OF_INERTIA)
-KRATOS_CREATE_VARIABLE(Matrix, ELASTICITY_TENSOR)
 
 // Generalized eigenvalue problem
 KRATOS_CREATE_VARIABLE(int, BUILD_LEVEL)
@@ -188,7 +187,6 @@ KRATOS_CREATE_VARIABLE(double, RESPONSE_VALUE)
 // Constitutive laws variables
 KRATOS_CREATE_VARIABLE(double, YIELD_STRESS_TENSION)
 KRATOS_CREATE_VARIABLE(Vector, PLASTIC_STRAIN_VECTOR)
-KRATOS_CREATE_VARIABLE(Vector, BACK_STRESS_VECTOR)
 KRATOS_CREATE_VARIABLE(Matrix, PLASTIC_DEFORMATION_GRADIENT)
 KRATOS_CREATE_VARIABLE(double, YIELD_STRESS_COMPRESSION)
 KRATOS_CREATE_VARIABLE(double, DILATANCY_ANGLE)
@@ -206,7 +204,6 @@ KRATOS_CREATE_VARIABLE(double, DAMAGE)
 KRATOS_CREATE_VARIABLE(double, THRESHOLD)
 KRATOS_CREATE_VARIABLE(Matrix, INTEGRATED_STRESS_TENSOR)
 KRATOS_CREATE_VARIABLE(Matrix, PLASTIC_STRAIN_TENSOR)
-KRATOS_CREATE_VARIABLE(Matrix, BACK_STRESS_TENSOR)
 KRATOS_CREATE_VARIABLE(Vector, CURVE_FITTING_PARAMETERS)
 KRATOS_CREATE_VARIABLE(Vector, PLASTIC_STRAIN_INDICATORS)
 KRATOS_CREATE_VARIABLE(double, EQUIVALENT_PLASTIC_STRAIN)
@@ -230,19 +227,8 @@ KRATOS_CREATE_VARIABLE(double, THRESHOLD_TENSION)
 KRATOS_CREATE_VARIABLE(double, THRESHOLD_COMPRESSION)
 KRATOS_CREATE_VARIABLE(double, UNIAXIAL_STRESS_TENSION)
 KRATOS_CREATE_VARIABLE(double, UNIAXIAL_STRESS_COMPRESSION)
-KRATOS_CREATE_VARIABLE(double, FRACTURE_ENERGY_COMPRESSION)
-
-// D+D- Damage Constitutive laws variables, additional Masonry 2D & 3D
-KRATOS_CREATE_VARIABLE(double, DAMAGE_ONSET_STRESS_COMPRESSION)
-KRATOS_CREATE_VARIABLE(double, BIAXIAL_COMPRESSION_MULTIPLIER)
-KRATOS_CREATE_VARIABLE(double, FRACTURE_ENERGY_TENSION)
-KRATOS_CREATE_VARIABLE(double, RESIDUAL_STRESS_COMPRESSION)
-KRATOS_CREATE_VARIABLE(double, BEZIER_CONTROLLER_C1)
-KRATOS_CREATE_VARIABLE(double, BEZIER_CONTROLLER_C2)
-KRATOS_CREATE_VARIABLE(double, BEZIER_CONTROLLER_C3)
-KRATOS_CREATE_VARIABLE(double, YIELD_STRAIN_COMPRESSION)
-KRATOS_CREATE_VARIABLE(double, SHEAR_COMPRESSION_REDUCTOR)
-KRATOS_CREATE_VARIABLE(double, TRIAXIAL_COMPRESSION_COEFFICIENT)
+KRATOS_CREATE_VARIABLE(double,FRACTURE_ENERGY_COMPRESSION)
+
 
 // Adjoint Variables
 KRATOS_CREATE_3D_VARIABLE_WITH_COMPONENTS(ADJOINT_DISPLACEMENT)
diff --git a/applications/StructuralMechanicsApplication/structural_mechanics_application_variables.h b/applications/StructuralMechanicsApplication/structural_mechanics_application_variables.h
index 707c1d820a..5214ee1ddf 100644
--- a/applications/StructuralMechanicsApplication/structural_mechanics_application_variables.h
+++ b/applications/StructuralMechanicsApplication/structural_mechanics_application_variables.h
@@ -51,7 +51,6 @@ namespace Kratos
     KRATOS_DEFINE_3D_APPLICATION_VARIABLE_WITH_COMPONENTS(STRUCTURAL_MECHANICS_APPLICATION, LOCAL_MATERIAL_AXIS_3)
     KRATOS_DEFINE_3D_APPLICATION_VARIABLE_WITH_COMPONENTS(STRUCTURAL_MECHANICS_APPLICATION, CENTER_OF_GRAVITY)
     KRATOS_DEFINE_APPLICATION_VARIABLE( STRUCTURAL_MECHANICS_APPLICATION, double, MASS_MOMENT_OF_INERTIA )
-    KRATOS_DEFINE_APPLICATION_VARIABLE( STRUCTURAL_MECHANICS_APPLICATION, Matrix, ELASTICITY_TENSOR )
 
     // Generalized eigenvalue problem
     KRATOS_DEFINE_APPLICATION_VARIABLE( STRUCTURAL_MECHANICS_APPLICATION, int, BUILD_LEVEL )
@@ -215,7 +214,6 @@ namespace Kratos
     // Constitutive laws variables
     KRATOS_DEFINE_APPLICATION_VARIABLE(STRUCTURAL_MECHANICS_APPLICATION, double, YIELD_STRESS_TENSION)
     KRATOS_DEFINE_APPLICATION_VARIABLE(STRUCTURAL_MECHANICS_APPLICATION, Vector, PLASTIC_STRAIN_VECTOR)
-    KRATOS_DEFINE_APPLICATION_VARIABLE(STRUCTURAL_MECHANICS_APPLICATION, Vector, BACK_STRESS_VECTOR)
     KRATOS_DEFINE_APPLICATION_VARIABLE(STRUCTURAL_MECHANICS_APPLICATION, Matrix, PLASTIC_DEFORMATION_GRADIENT)
     KRATOS_DEFINE_APPLICATION_VARIABLE(STRUCTURAL_MECHANICS_APPLICATION, double, YIELD_STRESS_COMPRESSION)
     KRATOS_DEFINE_APPLICATION_VARIABLE(STRUCTURAL_MECHANICS_APPLICATION, double, DILATANCY_ANGLE)
@@ -248,7 +246,6 @@ namespace Kratos
     KRATOS_DEFINE_APPLICATION_VARIABLE(STRUCTURAL_MECHANICS_APPLICATION, bool, CONSIDER_PERTURBATION_THRESHOLD)
     KRATOS_DEFINE_APPLICATION_VARIABLE(STRUCTURAL_MECHANICS_APPLICATION, int, TANGENT_OPERATOR_ESTIMATION)
     KRATOS_DEFINE_APPLICATION_VARIABLE(STRUCTURAL_MECHANICS_APPLICATION, Matrix, TENSION_STRESS_TENSOR)
-    KRATOS_DEFINE_APPLICATION_VARIABLE(STRUCTURAL_MECHANICS_APPLICATION, Matrix, BACK_STRESS_TENSOR)
     KRATOS_DEFINE_APPLICATION_VARIABLE(STRUCTURAL_MECHANICS_APPLICATION, Matrix, COMPRESSION_STRESS_TENSOR)
     KRATOS_DEFINE_APPLICATION_VARIABLE(STRUCTURAL_MECHANICS_APPLICATION, Vector, TENSION_STRESS_VECTOR)
     KRATOS_DEFINE_APPLICATION_VARIABLE(STRUCTURAL_MECHANICS_APPLICATION, Vector, COMPRESSION_STRESS_VECTOR)
@@ -257,18 +254,6 @@ namespace Kratos
     KRATOS_DEFINE_APPLICATION_VARIABLE(STRUCTURAL_MECHANICS_APPLICATION, double, EXPONENTIAL_SATURATION_YIELD_STRESS)
     KRATOS_DEFINE_APPLICATION_VARIABLE(STRUCTURAL_MECHANICS_APPLICATION, double, ACCUMULATED_PLASTIC_STRAIN)
 
-    // D+D- Damage Constitutive laws variables, additional Masonry 2D & 3D
-    KRATOS_DEFINE_APPLICATION_VARIABLE(STRUCTURAL_MECHANICS_APPLICATION, double, DAMAGE_ONSET_STRESS_COMPRESSION)
-    KRATOS_DEFINE_APPLICATION_VARIABLE(STRUCTURAL_MECHANICS_APPLICATION, double, BIAXIAL_COMPRESSION_MULTIPLIER)
-    KRATOS_DEFINE_APPLICATION_VARIABLE(STRUCTURAL_MECHANICS_APPLICATION, double, FRACTURE_ENERGY_TENSION)
-    KRATOS_DEFINE_APPLICATION_VARIABLE(STRUCTURAL_MECHANICS_APPLICATION, double, RESIDUAL_STRESS_COMPRESSION)
-    KRATOS_DEFINE_APPLICATION_VARIABLE(STRUCTURAL_MECHANICS_APPLICATION, double, BEZIER_CONTROLLER_C1)
-    KRATOS_DEFINE_APPLICATION_VARIABLE(STRUCTURAL_MECHANICS_APPLICATION, double, BEZIER_CONTROLLER_C2)
-    KRATOS_DEFINE_APPLICATION_VARIABLE(STRUCTURAL_MECHANICS_APPLICATION, double, BEZIER_CONTROLLER_C3)
-    KRATOS_DEFINE_APPLICATION_VARIABLE(STRUCTURAL_MECHANICS_APPLICATION, double, YIELD_STRAIN_COMPRESSION)
-    KRATOS_DEFINE_APPLICATION_VARIABLE(STRUCTURAL_MECHANICS_APPLICATION, double, SHEAR_COMPRESSION_REDUCTOR)
-    KRATOS_DEFINE_APPLICATION_VARIABLE(STRUCTURAL_MECHANICS_APPLICATION, double, TRIAXIAL_COMPRESSION_COEFFICIENT)
-
     // Adjoint variables
     KRATOS_DEFINE_3D_APPLICATION_VARIABLE_WITH_COMPONENTS( STRUCTURAL_MECHANICS_APPLICATION, ADJOINT_DISPLACEMENT )
     KRATOS_DEFINE_3D_APPLICATION_VARIABLE_WITH_COMPONENTS( STRUCTURAL_MECHANICS_APPLICATION, ADJOINT_ROTATION )
diff --git a/applications/StructuralMechanicsApplication/tests/adjoint_sensitivity_analysis_tests/adjoint_beam_structure_3d2n/Beam_structure.mdpa b/applications/StructuralMechanicsApplication/tests/adjoint_sensitivity_analysis_tests/adjoint_beam_structure_3d2n/Beam_structure.mdpa
index c871a0423a..b95297b97f 100644
--- a/applications/StructuralMechanicsApplication/tests/adjoint_sensitivity_analysis_tests/adjoint_beam_structure_3d2n/Beam_structure.mdpa
+++ b/applications/StructuralMechanicsApplication/tests/adjoint_sensitivity_analysis_tests/adjoint_beam_structure_3d2n/Beam_structure.mdpa
@@ -85,6 +85,9 @@ Begin SubModelPart  ROTATION_support // Group DIRICH_BC // Subtree ROTATION
     End SubModelPartConditions
 End SubModelPart
 
+
+
+
 Begin SubModelPart PointLoad3D_load // Group load // Subtree PointLoad3D
     Begin SubModelPartNodes
         6
@@ -107,47 +110,3 @@ Begin SubModelPart  test_model_part
     Begin SubModelPartConditions
     End SubModelPartConditions
 End SubModelPart
-
-Begin SubModelPart sensitivity_mp // Group Beam // Subtree Parts
-    Begin SubModelPartNodes
-       1
-       2
-       3
-       4
-       5
-       6
-       7
-       8
-       9
-       10
-       11
-    End SubModelPartNodes
-    Begin SubModelPartElements
-         1
-         2
-         3
-         4
-         5
-         6
-         7
-         8
-         9
-         10
-    End SubModelPartElements
-    Begin SubModelPartConditions
-        1
-    End SubModelPartConditions
-
-    Begin SubModelPart sensitivity_mp_1 // Group Beam // Subtree Parts
-        Begin SubModelPartNodes
-        End SubModelPartNodes
-        Begin SubModelPartElements
-             2
-             3
-             4
-             5
-        End SubModelPartElements
-        Begin SubModelPartConditions
-        End SubModelPartConditions
-    End SubModelPart
-End SubModelPart
\ No newline at end of file
diff --git a/applications/StructuralMechanicsApplication/tests/adjoint_sensitivity_analysis_tests/adjoint_beam_structure_3d2n/beam_test_local_stress_adjoint_parameters.json b/applications/StructuralMechanicsApplication/tests/adjoint_sensitivity_analysis_tests/adjoint_beam_structure_3d2n/beam_test_local_stress_adjoint_parameters.json
index f1dbd03a01..4d6e6ca21b 100644
--- a/applications/StructuralMechanicsApplication/tests/adjoint_sensitivity_analysis_tests/adjoint_beam_structure_3d2n/beam_test_local_stress_adjoint_parameters.json
+++ b/applications/StructuralMechanicsApplication/tests/adjoint_sensitivity_analysis_tests/adjoint_beam_structure_3d2n/beam_test_local_stress_adjoint_parameters.json
@@ -16,6 +16,9 @@
         },
         "compute_reactions"			   : false,
         "move_mesh_flag"                    : false,
+        "scheme_settings" : {
+            "scheme_type"              : "adjoint_structural"
+            },
         "response_function_settings" : {
                 "response_type"     : "adjoint_local_stress",
                 "use_kratos"        : true,
@@ -27,7 +30,7 @@
                 "stress_location"   : 1
             },
         "sensitivity_settings" : {
-                "sensitivity_model_part_name" : "sensitivity_mp",
+                "sensitivity_model_part_name" : "Parts_Beam",
                 "nodal_sensitivity_variables"  : ["SHAPE"],
                 "element_sensitivity_variables"  : ["I22"],
                 "condition_sensitivity_variables"  : ["POINT_LOAD"],
@@ -35,7 +38,7 @@
             },
         "echo_level"                   : 0,
         "problem_domain_sub_model_part_list" : ["Parts_Beam"],
-        "processes_sub_model_part_list"      : ["Structure","DISPLACEMENT_support","ROTATION_support","PointLoad3D_load"],
+        "processes_sub_model_part_list"      : ["DISPLACEMENT_support","ROTATION_support"],
         "computing_model_part_name" : "computing_domain",
         "rotation_dofs"                      : true,
         "linear_solver_settings"       : {
@@ -57,7 +60,7 @@
         "process_name"  : "AssignVectorVariableProcess",
         "Parameters"    : {
             "mesh_id"         : 0,
-            "model_part_name" : "Structure.DISPLACEMENT_support",
+            "model_part_name" : "DISPLACEMENT_support",
             "variable_name"   : "ADJOINT_DISPLACEMENT",
             "constrained"     : [true,true,true],
             "value"           : [0.0,0.0,0.0],
@@ -71,7 +74,7 @@
         "process_name"  : "AssignVectorVariableProcess",
         "Parameters"    : {
             "mesh_id"         : 0,
-            "model_part_name" : "Structure.ROTATION_support",
+            "model_part_name" : "ROTATION_support",
             "variable_name"   : "ADJOINT_ROTATION",
             "constrained"     : [true,true,true],
             "value"           : [0.0,0.0,0.0],
@@ -87,7 +90,7 @@
         "process_name"          : "ApplyConstantVectorValueProcess",
         "Parameters"            : {
             "mesh_id"         : 0,
-            "model_part_name" : "Structure.PointLoad3D_load",
+            "model_part_name" : "PointLoad3D_load",
             "variable_name"   : "POINT_LOAD",
             "modulus"          :40,
             "direction"       : [0.0,0.0,1.0]
@@ -107,18 +110,6 @@
                 "list_of_variables": ["DISPLACEMENT", "ROTATION"]
             }
         }
-    },
-    {
-        "python_module"   : "element_sensitivity_domain_integration_process",
-        "kratos_module" : "KratosMultiphysics.StructuralMechanicsApplication",
-        "help"                  : "",
-        "process_name"          : "ElementSensitivityDomainIntegrationProcess",
-        "Parameters"            : {
-            "element_sensitivity_variables"    : ["I22_SENSITIVITY"],
-            "model_part_name"                  : "Structure",
-            "sensitivity_model_part_name"      : "sensitivity_mp",
-            "sensitivity_sub_model_part_list"  : ["sensitivity_mp_1"]
-        }
     }],
     "json_check_process" : [
         {
diff --git a/applications/StructuralMechanicsApplication/tests/adjoint_sensitivity_analysis_tests/adjoint_beam_structure_3d2n/beam_test_nodal_disp_adjoint_parameters.json b/applications/StructuralMechanicsApplication/tests/adjoint_sensitivity_analysis_tests/adjoint_beam_structure_3d2n/beam_test_nodal_disp_adjoint_parameters.json
index b02610d64c..eddc461dcf 100644
--- a/applications/StructuralMechanicsApplication/tests/adjoint_sensitivity_analysis_tests/adjoint_beam_structure_3d2n/beam_test_nodal_disp_adjoint_parameters.json
+++ b/applications/StructuralMechanicsApplication/tests/adjoint_sensitivity_analysis_tests/adjoint_beam_structure_3d2n/beam_test_nodal_disp_adjoint_parameters.json
@@ -16,6 +16,9 @@
         },
         "compute_reactions"			   : false,
         "move_mesh_flag"                    : false,
+        "scheme_settings" : {
+            "scheme_type"              : "adjoint_structural"
+            },
         "response_function_settings" : {
                 "response_type"     : "adjoint_nodal_displacement",
                 "use_kratos"        : true,
@@ -33,7 +36,7 @@
             },
         "echo_level"                   : 0,
         "problem_domain_sub_model_part_list" : ["Parts_Beam"],
-        "processes_sub_model_part_list"      : ["Structure","DISPLACEMENT_support","ROTATION_support","PointLoad3D_load"],
+        "processes_sub_model_part_list"      : ["DISPLACEMENT_support","ROTATION_support"],
         "computing_model_part_name" : "computing_domain",
         "rotation_dofs"                      : true,
         "linear_solver_settings"       : {
@@ -55,7 +58,7 @@
         "process_name"  : "AssignVectorVariableProcess",
         "Parameters"    : {
             "mesh_id"         : 0,
-            "model_part_name" : "Structure.DISPLACEMENT_support",
+            "model_part_name" : "DISPLACEMENT_support",
             "variable_name"   : "ADJOINT_DISPLACEMENT",
             "constrained"     : [true,true,true],
             "value"           : [0.0,0.0,0.0],
@@ -69,7 +72,7 @@
         "process_name"  : "AssignVectorVariableProcess",
         "Parameters"    : {
             "mesh_id"         : 0,
-            "model_part_name" : "Structure.ROTATION_support",
+            "model_part_name" : "ROTATION_support",
             "variable_name"   : "ADJOINT_ROTATION",
             "constrained"     : [true,true,true],
             "value"           : [0.0,0.0,0.0],
@@ -85,7 +88,7 @@
         "process_name"          : "ApplyConstantVectorValueProcess",
         "Parameters"            : {
             "mesh_id"         : 0,
-            "model_part_name" : "Structure.PointLoad3D_load",
+            "model_part_name" : "PointLoad3D_load",
             "variable_name"   : "POINT_LOAD",
             "modulus"          :40,
             "direction"       : [0.0,0.0,1.0]
diff --git a/applications/StructuralMechanicsApplication/tests/adjoint_sensitivity_analysis_tests/adjoint_beam_structure_3d2n/beam_test_parameters.json b/applications/StructuralMechanicsApplication/tests/adjoint_sensitivity_analysis_tests/adjoint_beam_structure_3d2n/beam_test_parameters.json
index 03a77cd920..490d2558d7 100644
--- a/applications/StructuralMechanicsApplication/tests/adjoint_sensitivity_analysis_tests/adjoint_beam_structure_3d2n/beam_test_parameters.json
+++ b/applications/StructuralMechanicsApplication/tests/adjoint_sensitivity_analysis_tests/adjoint_beam_structure_3d2n/beam_test_parameters.json
@@ -35,7 +35,7 @@
             "solver_type" : "ExternalSolversApplication.super_lu"
         },
         "problem_domain_sub_model_part_list" : ["Parts_Beam"],
-        "processes_sub_model_part_list"      : ["Structure","DISPLACEMENT_support", "ROTATION_support","PointLoad3D_load"],
+        "processes_sub_model_part_list"      : ["DISPLACEMENT_support", "ROTATION_support","PointLoad3D_load"],
         "rotation_dofs"                      : true
 
     },
@@ -47,7 +47,7 @@
         "process_name"  : "AssignVectorVariableProcess",
         "Parameters"    : {
             "mesh_id"         : 0,
-            "model_part_name" : "Structure.DISPLACEMENT_support",
+            "model_part_name" : "DISPLACEMENT_support",
             "variable_name"   : "DISPLACEMENT",
             "constrained"     : [true,true,true],
             "value"           : [0.0,0.0,0.0],
@@ -61,7 +61,7 @@
         "process_name"  : "AssignVectorVariableProcess",
         "Parameters"    : {
             "mesh_id"         : 0,
-            "model_part_name" : "Structure.ROTATION_support",
+            "model_part_name" : "ROTATION_support",
             "variable_name"   : "ROTATION",
             "constrained"     : [true,true,true],
             "value"           : [0.0,0.0,0.0],
@@ -95,7 +95,7 @@
         "process_name"          : "ApplyConstantVectorValueProcess",
         "Parameters"            : {
             "mesh_id"         : 0,
-            "model_part_name" : "Structure.PointLoad3D_load",
+            "model_part_name" : "PointLoad3D_load",
             "variable_name"   : "POINT_LOAD",
             "modulus"          :40,
             "direction"       : [0.0,0.0,1.0]
diff --git a/applications/StructuralMechanicsApplication/tests/adjoint_sensitivity_analysis_tests/adjoint_beam_structure_3d2n/beam_test_strain_energy_adjoint_parameters.json b/applications/StructuralMechanicsApplication/tests/adjoint_sensitivity_analysis_tests/adjoint_beam_structure_3d2n/beam_test_strain_energy_adjoint_parameters.json
index 2e66ab08a0..d405d0027d 100644
--- a/applications/StructuralMechanicsApplication/tests/adjoint_sensitivity_analysis_tests/adjoint_beam_structure_3d2n/beam_test_strain_energy_adjoint_parameters.json
+++ b/applications/StructuralMechanicsApplication/tests/adjoint_sensitivity_analysis_tests/adjoint_beam_structure_3d2n/beam_test_strain_energy_adjoint_parameters.json
@@ -13,6 +13,9 @@
         "domain_size"     : 3,
         "compute_reactions"			   : false,
         "move_mesh_flag"                    : false,
+        "scheme_settings" : {
+            "scheme_type"              : "adjoint_structural"
+            },
         "time_stepping"                      : {
             "time_step" : 1.0
         },
@@ -31,7 +34,7 @@
             },
         "echo_level"                   : 0,
         "problem_domain_sub_model_part_list" : ["Parts_Beam"],
-        "processes_sub_model_part_list"      : ["Structure","DISPLACEMENT_support","ROTATION_support","PointLoad3D_load"],
+        "processes_sub_model_part_list"      : ["DISPLACEMENT_support","ROTATION_support"],
         "computing_model_part_name" : "computing_domain",
         "rotation_dofs"                      : true,
         "linear_solver_settings"       : {
@@ -53,7 +56,7 @@
         "process_name"  : "AssignVectorVariableProcess",
         "Parameters"    : {
             "mesh_id"         : 0,
-            "model_part_name" : "Structure.DISPLACEMENT_support",
+            "model_part_name" : "DISPLACEMENT_support",
             "variable_name"   : "ADJOINT_DISPLACEMENT",
             "constrained"     : [true,true,true],
             "value"           : [0.0,0.0,0.0],
@@ -67,7 +70,7 @@
         "process_name"  : "AssignVectorVariableProcess",
         "Parameters"    : {
             "mesh_id"         : 0,
-            "model_part_name" : "Structure.ROTATION_support",
+            "model_part_name" : "ROTATION_support",
             "variable_name"   : "ADJOINT_ROTATION",
             "constrained"     : [true,true,true],
             "value"           : [0.0,0.0,0.0],
@@ -83,7 +86,7 @@
         "process_name"          : "ApplyConstantVectorValueProcess",
         "Parameters"            : {
             "mesh_id"         : 0,
-            "model_part_name" : "Structure.PointLoad3D_load",
+            "model_part_name" : "PointLoad3D_load",
             "variable_name"   : "POINT_LOAD",
             "modulus"          :40,
             "direction"       : [0.0,0.0,1.0]
diff --git a/applications/StructuralMechanicsApplication/tests/adjoint_sensitivity_analysis_tests/adjoint_beam_structure_3d2n/materials_beam.json b/applications/StructuralMechanicsApplication/tests/adjoint_sensitivity_analysis_tests/adjoint_beam_structure_3d2n/materials_beam.json
index 15ca459a61..fce2b4e37e 100644
--- a/applications/StructuralMechanicsApplication/tests/adjoint_sensitivity_analysis_tests/adjoint_beam_structure_3d2n/materials_beam.json
+++ b/applications/StructuralMechanicsApplication/tests/adjoint_sensitivity_analysis_tests/adjoint_beam_structure_3d2n/materials_beam.json
@@ -1,6 +1,6 @@
 {
     "properties": [{
-            "model_part_name": "Structure.Parts_Beam",
+            "model_part_name": "Parts_Beam",
             "properties_id": 1,
             "Material": {
                     "constitutive_law": {
diff --git a/applications/StructuralMechanicsApplication/tests/adjoint_sensitivity_analysis_tests/adjoint_shell_structure_3d3n/linear_shell_test_local_stress_adjoint_parameters.json b/applications/StructuralMechanicsApplication/tests/adjoint_sensitivity_analysis_tests/adjoint_shell_structure_3d3n/linear_shell_test_local_stress_adjoint_parameters.json
index e4f42dafd7..e0d9f035fe 100644
--- a/applications/StructuralMechanicsApplication/tests/adjoint_sensitivity_analysis_tests/adjoint_shell_structure_3d3n/linear_shell_test_local_stress_adjoint_parameters.json
+++ b/applications/StructuralMechanicsApplication/tests/adjoint_sensitivity_analysis_tests/adjoint_shell_structure_3d3n/linear_shell_test_local_stress_adjoint_parameters.json
@@ -16,6 +16,9 @@
         },
         "compute_reactions"			   : false,
         "move_mesh_flag"                    : false,
+        "scheme_settings" : {
+            "scheme_type"              : "adjoint_structural"
+        },
         "response_function_settings" : {
             "response_type"     : "adjoint_local_stress",
             "use_kratos"        : true,
@@ -35,7 +38,7 @@
         },
         "echo_level"                   : 0,
         "problem_domain_sub_model_part_list" : ["Parts_AREAS"],
-        "processes_sub_model_part_list"      : ["DISPLACEMENT_DIR_BC", "PointLoad3D_NODES", "Structure"],
+        "processes_sub_model_part_list"      : ["DISPLACEMENT_DIR_BC"],
         "computing_model_part_name" : "computing_domain",
         "rotation_dofs"                      : true,
         "linear_solver_settings"       : {
diff --git a/applications/StructuralMechanicsApplication/tests/adjoint_sensitivity_analysis_tests/adjoint_shell_structure_3d3n/linear_shell_test_nodal_disp_adjoint_parameters.json b/applications/StructuralMechanicsApplication/tests/adjoint_sensitivity_analysis_tests/adjoint_shell_structure_3d3n/linear_shell_test_nodal_disp_adjoint_parameters.json
index 4c8415e0ec..4d23569729 100644
--- a/applications/StructuralMechanicsApplication/tests/adjoint_sensitivity_analysis_tests/adjoint_shell_structure_3d3n/linear_shell_test_nodal_disp_adjoint_parameters.json
+++ b/applications/StructuralMechanicsApplication/tests/adjoint_sensitivity_analysis_tests/adjoint_shell_structure_3d3n/linear_shell_test_nodal_disp_adjoint_parameters.json
@@ -16,6 +16,9 @@
         },
         "compute_reactions"			   : false,
         "move_mesh_flag"                    : false,
+        "scheme_settings" : {
+            "scheme_type"              : "adjoint_structural"
+        },
         "response_function_settings" : {
             "response_type"     : "adjoint_nodal_displacement",
             "use_kratos"        : true,
@@ -33,7 +36,7 @@
         },
         "echo_level"                   : 0,
         "problem_domain_sub_model_part_list" : ["Parts_AREAS"],
-        "processes_sub_model_part_list"      : ["DISPLACEMENT_DIR_BC", "PointLoad3D_NODES", "Structure"],
+        "processes_sub_model_part_list"      : ["DISPLACEMENT_DIR_BC"],
         "computing_model_part_name" : "computing_domain",
         "rotation_dofs"                      : true,
         "linear_solver_settings"       : {
diff --git a/applications/StructuralMechanicsApplication/tests/adjoint_sensitivity_analysis_tests/adjoint_shell_structure_3d3n/linear_shell_test_parameters.json b/applications/StructuralMechanicsApplication/tests/adjoint_sensitivity_analysis_tests/adjoint_shell_structure_3d3n/linear_shell_test_parameters.json
index 17f3b829d0..1c6b43c4c5 100644
--- a/applications/StructuralMechanicsApplication/tests/adjoint_sensitivity_analysis_tests/adjoint_shell_structure_3d3n/linear_shell_test_parameters.json
+++ b/applications/StructuralMechanicsApplication/tests/adjoint_sensitivity_analysis_tests/adjoint_shell_structure_3d3n/linear_shell_test_parameters.json
@@ -30,7 +30,7 @@
         "residual_absolute_tolerance"        : 1e-9,
         "max_iteration"                      : 10,
         "problem_domain_sub_model_part_list" : ["Parts_AREAS"],
-        "processes_sub_model_part_list"      : ["DISPLACEMENT_DIR_BC","PointLoad3D_NODES", "Structure"],
+        "processes_sub_model_part_list"      : ["DISPLACEMENT_DIR_BC","PointLoad3D_NODES"],
         "linear_solver_settings"       : {
             "solver_type"         : "ExternalSolversApplication.super_lu"
         },
diff --git a/applications/StructuralMechanicsApplication/tests/adjoint_sensitivity_analysis_tests/adjoint_shell_structure_3d3n/linear_shell_test_strain_energy_adjoint_parameters.json b/applications/StructuralMechanicsApplication/tests/adjoint_sensitivity_analysis_tests/adjoint_shell_structure_3d3n/linear_shell_test_strain_energy_adjoint_parameters.json
index d8489f7982..4a819aaf77 100644
--- a/applications/StructuralMechanicsApplication/tests/adjoint_sensitivity_analysis_tests/adjoint_shell_structure_3d3n/linear_shell_test_strain_energy_adjoint_parameters.json
+++ b/applications/StructuralMechanicsApplication/tests/adjoint_sensitivity_analysis_tests/adjoint_shell_structure_3d3n/linear_shell_test_strain_energy_adjoint_parameters.json
@@ -16,6 +16,9 @@
         },
         "compute_reactions"			   : false,
         "move_mesh_flag"                    : false,
+        "scheme_settings" : {
+            "scheme_type"              : "adjoint_structural"
+        },
         "response_function_settings" : {
             "response_type"     : "adjoint_linear_strain_energy",
             "use_kratos"        : true,
@@ -31,7 +34,7 @@
         },
         "echo_level"                   : 0,
         "problem_domain_sub_model_part_list" : ["Parts_AREAS"],
-        "processes_sub_model_part_list"      : ["DISPLACEMENT_DIR_BC", "PointLoad3D_NODES", "Structure"],
+        "processes_sub_model_part_list"      : ["DISPLACEMENT_DIR_BC"],
         "computing_model_part_name" : "computing_domain",
         "rotation_dofs"                      : true,
         "linear_solver_settings"       : {
diff --git a/applications/StructuralMechanicsApplication/tests/adjoint_sensitivity_analysis_tests/adjoint_truss_stucture_3d2n/linear_truss_test_local_stress_adjoint_parameters.json b/applications/StructuralMechanicsApplication/tests/adjoint_sensitivity_analysis_tests/adjoint_truss_stucture_3d2n/linear_truss_test_local_stress_adjoint_parameters.json
index 72d627567d..916ddd7276 100644
--- a/applications/StructuralMechanicsApplication/tests/adjoint_sensitivity_analysis_tests/adjoint_truss_stucture_3d2n/linear_truss_test_local_stress_adjoint_parameters.json
+++ b/applications/StructuralMechanicsApplication/tests/adjoint_sensitivity_analysis_tests/adjoint_truss_stucture_3d2n/linear_truss_test_local_stress_adjoint_parameters.json
@@ -16,6 +16,9 @@
         },
         "compute_reactions"			   : false,
         "move_mesh_flag"                    : false,
+        "scheme_settings" : {
+            "scheme_type"              : "adjoint_structural"
+            },
         "response_function_settings" : {
                 "response_type"     : "adjoint_local_stress",
                 "use_kratos"        : true,
@@ -35,7 +38,7 @@
             },
         "echo_level"                   : 0,
         "problem_domain_sub_model_part_list" : ["Parts_TRUSS"],
-        "processes_sub_model_part_list"      : ["DISPLACEMENT_BC_DIRICHLET_X_Y_Z","DISPLACEMENT_BC_DIRICHLET_Z","PointLoad3D_BC_NEUMANN","Structure"],
+        "processes_sub_model_part_list"      : ["DISPLACEMENT_BC_DIRICHLET_X_Y_Z","DISPLACEMENT_BC_DIRICHLET_Z","PointLoad3D_BC_NEUMANN"],
         "computing_model_part_name" : "computing_domain",
         "rotation_dofs"                      : false,
         "linear_solver_settings"       : {
diff --git a/applications/StructuralMechanicsApplication/tests/adjoint_sensitivity_analysis_tests/adjoint_truss_stucture_3d2n/linear_truss_test_parameters.json b/applications/StructuralMechanicsApplication/tests/adjoint_sensitivity_analysis_tests/adjoint_truss_stucture_3d2n/linear_truss_test_parameters.json
index aa651feeed..dc02d9d979 100644
--- a/applications/StructuralMechanicsApplication/tests/adjoint_sensitivity_analysis_tests/adjoint_truss_stucture_3d2n/linear_truss_test_parameters.json
+++ b/applications/StructuralMechanicsApplication/tests/adjoint_sensitivity_analysis_tests/adjoint_truss_stucture_3d2n/linear_truss_test_parameters.json
@@ -30,7 +30,7 @@
         "residual_absolute_tolerance"        : 1e-9,
         "max_iteration"                      : 10,
         "problem_domain_sub_model_part_list" : ["Parts_TRUSS"],
-        "processes_sub_model_part_list"      : ["DISPLACEMENT_BC_DIRICHLET_X_Y_Z","DISPLACEMENT_BC_DIRICHLET_Z","PointLoad3D_BC_NEUMANN","Structure"],
+        "processes_sub_model_part_list"      : ["DISPLACEMENT_BC_DIRICHLET_X_Y_Z","DISPLACEMENT_BC_DIRICHLET_Z","PointLoad3D_BC_NEUMANN"],
         "rotation_dofs"                      : false
     },
     "processes" : {
diff --git a/applications/StructuralMechanicsApplication/tests/adjoint_sensitivity_analysis_tests/adjoint_truss_stucture_3d2n/nonlinear_truss_test_local_stress_adjoint_parameters.json b/applications/StructuralMechanicsApplication/tests/adjoint_sensitivity_analysis_tests/adjoint_truss_stucture_3d2n/nonlinear_truss_test_local_stress_adjoint_parameters.json
index 33b5fb25ba..7be532eaf6 100644
--- a/applications/StructuralMechanicsApplication/tests/adjoint_sensitivity_analysis_tests/adjoint_truss_stucture_3d2n/nonlinear_truss_test_local_stress_adjoint_parameters.json
+++ b/applications/StructuralMechanicsApplication/tests/adjoint_sensitivity_analysis_tests/adjoint_truss_stucture_3d2n/nonlinear_truss_test_local_stress_adjoint_parameters.json
@@ -16,6 +16,9 @@
         },
         "compute_reactions"			   : false,
         "move_mesh_flag"                    : false,
+        "scheme_settings" : {
+            "scheme_type"              : "adjoint_structural"
+            },
         "response_function_settings" : {
                 "response_type"     : "adjoint_local_stress",
                 "use_kratos"        : true,
@@ -35,7 +38,7 @@
             },
         "echo_level"                   : 0,
         "problem_domain_sub_model_part_list" : ["Parts_TRUSS"],
-        "processes_sub_model_part_list"      : ["DISPLACEMENT_BC_DIRICHLET_X_Y_Z","DISPLACEMENT_BC_DIRICHLET_Z","PointLoad3D_BC_NEUMANN","Structure"],
+        "processes_sub_model_part_list"      : ["DISPLACEMENT_BC_DIRICHLET_X_Y_Z","DISPLACEMENT_BC_DIRICHLET_Z","PointLoad3D_BC_NEUMANN"],
         "computing_model_part_name" : "computing_domain",
         "rotation_dofs"                      : false,
         "linear_solver_settings"       : {
diff --git a/applications/StructuralMechanicsApplication/tests/adjoint_sensitivity_analysis_tests/adjoint_truss_stucture_3d2n/nonlinear_truss_test_parameters.json b/applications/StructuralMechanicsApplication/tests/adjoint_sensitivity_analysis_tests/adjoint_truss_stucture_3d2n/nonlinear_truss_test_parameters.json
index 8888821d24..8c6760d553 100644
--- a/applications/StructuralMechanicsApplication/tests/adjoint_sensitivity_analysis_tests/adjoint_truss_stucture_3d2n/nonlinear_truss_test_parameters.json
+++ b/applications/StructuralMechanicsApplication/tests/adjoint_sensitivity_analysis_tests/adjoint_truss_stucture_3d2n/nonlinear_truss_test_parameters.json
@@ -30,7 +30,7 @@
         "residual_absolute_tolerance"        : 1e-9,
         "max_iteration"                      : 10,
         "problem_domain_sub_model_part_list" : ["Parts_TRUSS"],
-        "processes_sub_model_part_list"      : ["DISPLACEMENT_BC_DIRICHLET_X_Y_Z","DISPLACEMENT_BC_DIRICHLET_Z","PointLoad3D_BC_NEUMANN","Structure"],
+        "processes_sub_model_part_list"      : ["DISPLACEMENT_BC_DIRICHLET_X_Y_Z","DISPLACEMENT_BC_DIRICHLET_Z","PointLoad3D_BC_NEUMANN"],
         "rotation_dofs"                      : false
     },
     "processes" : {
diff --git a/applications/StructuralMechanicsApplication/tests/beam_test/nonlinear_force_3D2NBeamCr_test.mdpa b/applications/StructuralMechanicsApplication/tests/beam_test/nonlinear_force_3D2NBeamCr_test.mdpa
deleted file mode 100644
index ef0705bbcd..0000000000
--- a/applications/StructuralMechanicsApplication/tests/beam_test/nonlinear_force_3D2NBeamCr_test.mdpa
+++ /dev/null
@@ -1,118 +0,0 @@
-Begin ModelPartData
-//  VARIABLE_NAME value
-End ModelPartData
-
-Begin Properties 0
-End Properties
-Begin Nodes
-    1   0.0000000000   0.0000000000   0.0000000000
-    2   0.2943341667   0.2087933333   0.0000000000
-    3   0.5886683333   0.4175866667   0.0000000000
-    4   0.8830025000   0.6263800000   0.0000000000
-    5   1.1773366667   0.8351733333   0.0000000000
-    6   1.4716708333   1.0439666667   0.0000000000
-    7   1.7660050000   1.2527600000   0.0000000000
-    8   2.0603391667   1.4615533333   0.0000000000
-    9   2.3546733333   1.6703466667   0.0000000000
-   10   2.6490075000   1.8791400000   0.0000000000
-   11   2.9433416667   2.0879333333   0.0000000000
-   12   3.2376758333   2.2967266667   0.0000000000
-   13   3.5320100000   2.5055200000   0.0000000000
-End Nodes
-
-
-Begin Elements CrBeamElement3D2N// GUI group identifier: beam
-        1          0          1          2 
-        2          0          2          3 
-        3          0          3          4 
-        4          0          4          5 
-        5          0          5          6 
-        6          0          6          7 
-        7          0          7          8 
-        8          0          8          9 
-        9          0          9         10 
-       10          0         10         11 
-       11          0         11         12 
-       12          0         12         13 
-End Elements
-
-Begin ElementalData LOCAL_AXIS_2 // Groups: beam
-    1 [3]( -0.5785830147,   0.8156235008,  -0.0000000000)
-    2 [3]( -0.5785830147,   0.8156235008,  -0.0000000000)
-    3 [3]( -0.5785830147,   0.8156235008,  -0.0000000000)
-    4 [3]( -0.5785830147,   0.8156235008,  -0.0000000000)
-    5 [3]( -0.5785830147,   0.8156235008,  -0.0000000000)
-    6 [3]( -0.5785830147,   0.8156235008,  -0.0000000000)
-    7 [3]( -0.5785830147,   0.8156235008,  -0.0000000000)
-    8 [3]( -0.5785830147,   0.8156235008,  -0.0000000000)
-    9 [3]( -0.5785830147,   0.8156235008,  -0.0000000000)
-   10 [3]( -0.5785830147,   0.8156235008,  -0.0000000000)
-   11 [3]( -0.5785830147,   0.8156235008,  -0.0000000000)
-   12 [3]( -0.5785830147,   0.8156235008,  -0.0000000000)
-End ElementalData
-
-Begin Conditions PointLoadCondition3D1N// GUI group identifier: neumann
-    1 0 13
-End Conditions
-
-Begin SubModelPart Parts_beam // Group beam // Subtree Parts
-    Begin SubModelPartNodes
-            1
-            2
-            3
-            4
-            5
-            6
-            7
-            8
-            9
-           10
-           11
-           12
-           13
-    End SubModelPartNodes
-    Begin SubModelPartElements
-            1
-            2
-            3
-            4
-            5
-            6
-            7
-            8
-            9
-           10
-           11
-           12
-    End SubModelPartElements
-    Begin SubModelPartConditions
-    End SubModelPartConditions
-End SubModelPart
-Begin SubModelPart DISPLACEMENT_dirichlet // Group dirichlet // Subtree DISPLACEMENT
-    Begin SubModelPartNodes
-            1
-    End SubModelPartNodes
-    Begin SubModelPartElements
-    End SubModelPartElements
-    Begin SubModelPartConditions
-    End SubModelPartConditions
-End SubModelPart
-Begin SubModelPart ROTATION_dirichlet // Group dirichlet // Subtree ROTATION
-    Begin SubModelPartNodes
-            1
-    End SubModelPartNodes
-    Begin SubModelPartElements
-    End SubModelPartElements
-    Begin SubModelPartConditions
-    End SubModelPartConditions
-End SubModelPart
-Begin SubModelPart PointLoad3D_neumann // Group neumann // Subtree PointLoad3D
-    Begin SubModelPartNodes
-           13
-    End SubModelPartNodes
-    Begin SubModelPartElements
-    End SubModelPartElements
-    Begin SubModelPartConditions
-            1
-    End SubModelPartConditions
-End SubModelPart
diff --git a/applications/StructuralMechanicsApplication/tests/beam_test/nonlinear_force_3D2NBeamCr_test_material.json b/applications/StructuralMechanicsApplication/tests/beam_test/nonlinear_force_3D2NBeamCr_test_material.json
deleted file mode 100644
index ec64cc0d30..0000000000
--- a/applications/StructuralMechanicsApplication/tests/beam_test/nonlinear_force_3D2NBeamCr_test_material.json
+++ /dev/null
@@ -1,21 +0,0 @@
-{
-    "properties" : [{
-        "model_part_name" : "Parts_beam",
-        "properties_id"   : 1,
-        "Material"        : {
-            "constitutive_law" : {
-                "name" : "BeamConstitutiveLaw"
-            },
-            "Variables"        : {
-                "DENSITY"           : 7850.0,
-                "YOUNG_MODULUS"     : 206900000000.0,
-                "POISSON_RATIO"     : 0.29,
-                "CROSS_AREA"        : 0.001,
-                "TORSIONAL_INERTIA" : 1e-5,
-                "I22"               : 1e-5,
-                "I33"               : 1e-5
-            },
-            "Tables"           : {}
-        }
-    }]
-}
diff --git a/applications/StructuralMechanicsApplication/tests/beam_test/nonlinear_force_3D2NBeamCr_test_parameters.json b/applications/StructuralMechanicsApplication/tests/beam_test/nonlinear_force_3D2NBeamCr_test_parameters.json
deleted file mode 100644
index e809249c28..0000000000
--- a/applications/StructuralMechanicsApplication/tests/beam_test/nonlinear_force_3D2NBeamCr_test_parameters.json
+++ /dev/null
@@ -1,84 +0,0 @@
-{
-    "problem_data"     : {
-        "problem_name"  : "nonlinear_force_3D2NBeamCr_test",
-        "parallel_type" : "OpenMP",
-        "echo_level"    : 0,
-        "start_time"    : 0.0,
-        "end_time"      : 1.0
-    },
-    "solver_settings"  : {
-        "solver_type"                        : "Static",
-        "model_part_name"                    : "Structure",
-        "domain_size"                        : 3,
-        "echo_level"                         : 0,
-        "analysis_type"                      : "non_linear",
-        "model_import_settings"              : {
-            "input_type"     : "mdpa",
-            "input_filename" : "beam_test/nonlinear_force_3D2NBeamCr_test"
-        },
-        "material_import_settings"           : {
-            "materials_filename" : "beam_test/nonlinear_force_3D2NBeamCr_test_material.json"
-        },
-        "time_stepping"                      : {
-            "time_step" : 0.1
-        },
-        "line_search"                        : false,
-        "convergence_criterion"              : "residual_criterion",
-        "displacement_relative_tolerance"    : 1e-7,
-        "displacement_absolute_tolerance"    : 1e-7,
-        "residual_relative_tolerance"        : 1e-7,
-        "residual_absolute_tolerance"        : 1e-7,
-        "max_iteration"                      : 100,
-        "problem_domain_sub_model_part_list" : ["Parts_beam"],
-        "processes_sub_model_part_list"      : ["DISPLACEMENT_dirichlet","ROTATION_dirichlet","PointLoad3D_neumann", "Structure"],
-        "rotation_dofs"                      : true
-    },
-    "processes"        : {
-        "constraints_process_list" : [{
-            "python_module" : "assign_vector_variable_process",
-            "kratos_module" : "KratosMultiphysics",
-            "Parameters"    : {
-                "model_part_name" : "Structure.DISPLACEMENT_dirichlet",
-                "variable_name"   : "DISPLACEMENT",
-                "constrained"     : [true,true,true],
-                "value"           : [0.0,0.0,0.0],
-                "interval"        : [0.0,"End"]
-            }
-        },{
-            "python_module" : "assign_vector_variable_process",
-            "kratos_module" : "KratosMultiphysics",
-            "Parameters"    : {
-                "model_part_name" : "Structure.ROTATION_dirichlet",
-                "variable_name"   : "ROTATION",
-                "constrained"     : [true,true,true],
-                "value"           : [0.0,0.0,0.0],
-                "interval"        : [0.0,"End"]
-            }
-        }],
-        "loads_process_list"       : [{
-            "python_module" : "assign_vector_by_direction_to_condition_process",
-            "kratos_module" : "KratosMultiphysics",
-            "check"         : "DirectorVectorNonZero direction",
-            "Parameters"    : {
-                "model_part_name" : "Structure.PointLoad3D_neumann",
-                "variable_name"   : "POINT_LOAD",
-                "modulus"         : "50000.0*t",
-                "direction"       : [0.0,1.0,0.0],
-                "interval"        : [0.0,"End"]
-            }
-        }],
-        "list_other_processes"     : [{
-            "python_module"   : "from_json_check_result_process",
-            "kratos_module" : "KratosMultiphysics",
-            "help"                  : "",
-            "process_name"          : "FromJsonCheckResultProcess",
-            "Parameters"            : {
-                "check_variables"  : ["DISPLACEMENT","REACTION"],
-                "gauss_points_check_variables" : ["FORCE","MOMENT"],
-                "input_file_name"  : "beam_test/nonlinear_force_3D2NBeamCr_test_results.json",
-                "model_part_name"  : "Structure",
-                "time_frequency"   : 0.01
-            }
-        }]
-    }
-}
diff --git a/applications/StructuralMechanicsApplication/tests/beam_test/nonlinear_force_3D2NBeamCr_test_results.json b/applications/StructuralMechanicsApplication/tests/beam_test/nonlinear_force_3D2NBeamCr_test_results.json
deleted file mode 100644
index 8bcf2d1723..0000000000
--- a/applications/StructuralMechanicsApplication/tests/beam_test/nonlinear_force_3D2NBeamCr_test_results.json
+++ /dev/null
@@ -1 +0,0 @@
-{"TIME": [0.1, 0.2, 0.30000000000000004, 0.4, 0.5, 0.6, 0.7, 0.7999999999999999, 0.8999999999999999, 0.9999999999999999, 1.0999999999999999], "NODE_1": {"DISPLACEMENT_X": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "DISPLACEMENT_Y": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "DISPLACEMENT_Z": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "REACTION_X": [1.609669197932817e-08, -8.83937900653109e-09, -1.0117219062522054e-08, -1.0313669918105006e-08, -1.5921614249236882e-08, 6.479240255430341e-09, 8.956703823059797e-09, 1.4471879694610834e-08, 1.6538251657038927e-08, 9.487848728895187e-09, -4.6540662879124284e-08], "REACTION_Y": [-4999.999999948372, -9999.999999993888, -14999.999999962056, -19999.999999968248, -25000.000000011052, -30000.000000000422, -34999.99999999839, -40000.00000003478, -45000.00000000826, -49999.99999999146, -54999.999999973516], "REACTION_Z": [-0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0]}, "NODE_2": {"DISPLACEMENT_X": [-0.00030603665965512705, -0.0006070977605888424, -0.0009031746379462435, -0.0011942740760273274, -0.0014804167768684734, -0.0017616358667343786, -0.0020379754590669446, -0.0023094892879389553, -0.00257623942204721, -0.0028382950657784138, -0.0030957314509203835], "DISPLACEMENT_Y": [0.0004394696409333546, 0.0008706369164464512, 0.0012935612041925428, 0.0017083216540419762, 0.002115014790913369, 0.0025137522254066575, 0.0029046584931641194, 0.003287869037349464, 0.003663528342983689, 0.004031788227102994, 0.004392806284805246], "DISPLACEMENT_Z": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "REACTION_X": [-1.8813352653523907e-08, -1.7133970686700195e-08, 3.8220605347305536e-08, 5.376386980060488e-08, -1.355147105641663e-08, -1.3626049621962011e-08, -1.0350049706175923e-08, -6.055415724404156e-08, -4.6158675104379654e-08, -4.557296051643789e-08, 1.9226717995479703e-08], "REACTION_Y": [-1.481839717598632e-08, 2.3690517991781235e-08, -7.01948010828346e-08, -4.8585206968709826e-08, 2.2359017748385668e-08, 9.509676601737738e-09, -6.03176886215806e-09, 1.629086909815669e-08, 2.3195752874016762e-08, 1.8131686374545097e-08, -2.7008354663848877e-08], "REACTION_Z": [-0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0]}, "NODE_3": {"DISPLACEMENT_X": [-0.0011984264030613983, -0.0023803665498575814, -0.003545579385411732, -0.004693892496748288, -0.005825196562121929, -0.006939439797898313, -0.008036622493816089, -0.009116791709569937, -0.010180036189242085, -0.011226481535368234, -0.012256285671533189], "DISPLACEMENT_Y": [0.0017005220302681618, 0.0033656116425260876, 0.004995621672616396, 0.0065909822402024035, 0.00815219058104865, 0.009679801410038007, 0.011174417891556947, 0.012636683266880836, 0.014067273165101228, 0.01546688860493789, 0.0168362496793083], "DISPLACEMENT_Z": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "REACTION_X": [-1.9045273802476004e-08, 2.1684172679670155e-08, 5.929905455559492e-09, -6.338996172416955e-08, 8.540519047528505e-08, 3.9090082282200456e-09, 7.228663889691234e-08, 1.3347744243219495e-08, 5.8305886341258883e-08, -4.230969352647662e-09, -1.0051735443994403e-08], "REACTION_Y": [-2.5247572921216488e-08, -1.704574970062822e-08, 7.108610589057207e-09, 3.961395123042166e-08, -7.083872333168983e-08, -2.2126187104731798e-08, 7.989001460373402e-09, 7.113703759387136e-08, -4.4652551878243685e-08, -8.200004231184721e-09, 3.95521055907011e-08], "REACTION_Z": [-0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0]}, "NODE_4": {"DISPLACEMENT_X": [-0.0026255109584231305, -0.005220188523973168, -0.007783082571103468, -0.010313412223074697, -0.012810554413568112, -0.015274032131332224, -0.017703502587649803, -0.02009874550635627, -0.022459651698111253, -0.024786212045592976, -0.027078506994861574], "DISPLACEMENT_Y": [0.0037065616762492026, 0.007329713783520681, 0.010870441269798251, 0.01432990224657443, 0.0177094038125007, 0.021010379259357774, 0.02423436682317733, 0.027382990080113526, 0.03045794003309415, 0.03346095889120829, 0.03639382550868813], "DISPLACEMENT_Z": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "REACTION_X": [-1.8445462046656758e-08, 4.310459189582616e-08, -8.7019543570932e-08, 6.134541763458401e-08, -1.7101956473197788e-07, 2.7681380743160844e-08, -1.1649899533949792e-07, 3.2228854252025485e-08, -6.477057468146086e-08, 2.8667272999882698e-08, 6.338450475595891e-08], "REACTION_Y": [1.3354110706131905e-08, -6.817208486609161e-08, 6.62912498228252e-08, -1.4497345546260476e-08, 1.1786323739215732e-07, 2.7110218070447445e-08, 4.3211912270635366e-08, -1.076841726899147e-08, 3.4349795896559954e-08, 2.2329913917928934e-08, -1.0993244359269738e-07], "REACTION_Z": [-0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0]}, "NODE_5": {"DISPLACEMENT_X": [-0.004535155184312548, -0.009025067441173757, -0.013467390985250365, -0.017860106106868764, -0.02220150049463417, -0.026490149471802393, -0.030724895634770693, -0.03490482831035487, -0.03902926317867928, -0.043097722342693344, -0.047109915065090255], "DISPLACEMENT_Y": [0.006381535051064463, 0.012609868310165357, 0.01868701300725785, 0.024615292660592158, 0.030397295773935518, 0.03603583328719515, 0.04153389906032137, 0.04689463355280607, 0.052121290762230765, 0.057217208404621474, 0.06218578125571289], "DISPLACEMENT_Z": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "REACTION_X": [3.328295861138031e-09, -9.746690921019763e-08, 1.0523763194214553e-07, -7.595190254505724e-08, 1.6280318959616125e-07, -3.3669493859633803e-09, 3.3545802580192685e-08, 2.1758751245215535e-08, 3.8686266634613276e-08, -8.767528925091028e-10, -1.0786970960907638e-07], "REACTION_Y": [2.6476300263311714e-08, 8.644747140351683e-08, -5.487891030497849e-08, 8.280039764940739e-08, -1.368389348499477e-07, 1.5064870240166783e-08, -1.0717485565692186e-08, -7.243943400681019e-08, 5.972833605483174e-08, -7.808557711541653e-08, 1.4124816516414285e-07], "REACTION_Z": [-0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0]}, "NODE_6": {"DISPLACEMENT_X": [-0.006874797967512046, -0.013691841719488989, -0.02044654955709357, -0.027134885538670064, -0.03375333266792927, -0.040298863616935944, -0.04676890984005967, -0.053161329822023255, -0.059474377090416065, -0.06570666851473243, -0.07185715331312273], "DISPLACEMENT_Y": [0.009649877739136803, 0.019054932258979983, 0.02821862259080002, 0.03714489996456811, 0.04583813350393607, 0.05430304063051645, 0.06254462260847504, 0.07056810546810054, 0.0783788863860868, 0.08598248546973901, 0.09338450279006971], "DISPLACEMENT_Z": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "REACTION_X": [-9.740688255988061e-08, 6.081518222345039e-08, -4.2989086068701e-08, 1.7475031199865043e-08, -1.4248143997974694e-08, -9.806535672396421e-08, 1.8579157767817378e-08, -4.0578015614300966e-08, 2.7026544557884336e-08, 1.989974407479167e-08, 1.3066892279312015e-07], "REACTION_Y": [1.525240804767236e-07, -2.529486664570868e-08, 2.7215719455853105e-08, -1.2515010894276202e-07, 6.618211045861244e-08, -5.249603418633342e-09, -9.93022695183754e-08, 4.351022653281689e-08, -6.675691111013293e-08, 4.016328603029251e-08, -1.0110670700669289e-07], "REACTION_Z": [-0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0]}, "NODE_7": {"DISPLACEMENT_X": [-0.00959150210492359, -0.019115889542873913, -0.028565414717217935, -0.03793316189640763, -0.04721301177498247, -0.05639960146311989, -0.06548828126233497, -0.07447506942076905, -0.0833566058941727, -0.09213010597527843, -0.10079331449988614], "DISPLACEMENT_Y": [0.013436461150122304, 0.026515487984007543, 0.039242396504211664, 0.05162322439939721, 0.06366461936490175, 0.0753737347089379, 0.08675813286504513, 0.09782569714180418, 0.10858455179944332, 0.11904299034806327, 0.1292094118103675], "DISPLACEMENT_Z": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "REACTION_X": [-1.21549419418443e-08, 1.8480932340025902e-08, -7.115158950909972e-08, 3.001332515850663e-08, -9.530231181997806e-08, 1.5681871445849538e-07, -6.470145308412611e-08, 2.831075107678771e-08, -8.337883627973497e-08, -4.256799002178013e-08, -6.199115887284279e-09], "REACTION_Y": [-1.0058101906906813e-08, -2.8798240236938e-08, -6.464688340201974e-09, 6.445043254643679e-08, 4.885441740043461e-08, -1.1589145287871361e-07, 9.410723578184843e-08, 1.1772499419748783e-08, 5.10990503244102e-08, 5.972106009721756e-08, 4.2826286517083645e-08], "REACTION_Z": [-0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0]}, "NODE_8": {"DISPLACEMENT_X": [-0.012632003295030081, -0.025191326913765, -0.03766610435686517, -0.050045653515235364, -0.06232043244855471, -0.07448198769086446, -0.08652289708291054, -0.09843670890607445, -0.11021787885916882, -0.1218617061879522, -0.13336427005603102], "DISPLACEMENT_Y": [0.017666538838951685, 0.03484363343963942, 0.05153884047395985, 0.06776071629352373, 0.08351865938853043, 0.09882276333138348, 0.11368368105746225, 0.1281125009250188, 0.14212063465502137, 0.15571971697715795, 0.1689215165951351], "DISPLACEMENT_Z": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "REACTION_X": [-9.356926966574974e-08, -7.768539944663644e-08, 4.0347913454752415e-08, -3.095374268013984e-08, 7.194284989964217e-08, -1.2773671187460423e-07, 1.137450453825295e-07, -3.982495400123298e-08, 1.0862277122214437e-07, 9.045834303833544e-08, -8.545976015739143e-08], "REACTION_Y": [1.1886368156410754e-07, 1.246698957402259e-07, 1.550142769701779e-08, -4.678440745919943e-09, -8.48558556754142e-08, 2.1175219444558024e-07, -4.7264620661735535e-08, 3.42406565323472e-08, -1.617736415937543e-07, -7.773633114993572e-08, 2.763408701866865e-08], "REACTION_Z": [-0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0]}, "NODE_9": {"DISPLACEMENT_X": [-0.01594275833085238, -0.0318111994889202, -0.047588427225478125, -0.06325914485442138, -0.07880960234674332, -0.09422753224696598, -0.10950207719192076, -0.12462371151791198, -0.13958415913134947, -0.15437630950609027, -0.16899413336972596], "DISPLACEMENT_Y": [0.022265692507247872, 0.0438927699993157, 0.06489137004438461, 0.08527295471661571, 0.10505009905431223, 0.12423629379190565, 0.1428457634936323, 0.1608933006621927, 0.17839411593552704, 0.19536370411532047, 0.21181772548488362], "DISPLACEMENT_Z": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "REACTION_X": [1.0689745977288112e-08, 1.4087527233641595e-07, 7.500148058170453e-08, -5.532638169825077e-08, 4.536559572443366e-09, 6.785012374166399e-08, -7.660855771973729e-08, 1.7240381566807628e-08, -1.0971052688546479e-07, -7.10751919541508e-08, 1.8600985640659928e-08], "REACTION_Y": [6.733989721396938e-08, -1.8335049389861524e-07, -5.167930794414133e-08, 5.88697730563581e-08, 8.480856195092201e-08, -1.9269282347522676e-07, 1.5643308870494366e-08, -5.430774763226509e-08, 1.6140984371304512e-07, -9.611540008336306e-09, -3.7325662560760975e-08], "REACTION_Z": [-0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0]}, "NODE_10": {"DISPLACEMENT_X": [-0.019469992613978953, -0.03886766909335148, -0.05817029470544933, -0.07735720469166524, -0.09640974293147933, -0.1153111849759012, -0.13404664913823114, -0.15260299895843335, -0.17096873995920414, -0.1891339132083021, -0.20708998780910517], "DISPLACEMENT_Y": [0.02715977773040768, 0.05351738822153346, 0.07908583472118592, 0.10387981202445036, 0.1279154336378639, 0.15120997752894724, 0.1737816519062508, 0.19564938175480037, 0.21683261625496883, 0.2373511567342096, 0.2572250044314339], "DISPLACEMENT_Z": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "REACTION_X": [-3.3805463317548856e-08, -5.2995346777606755e-08, -5.4771589930169284e-08, 7.045127858873457e-08, -3.989589458797127e-08, -2.8181602829135954e-08, -3.078093868680298e-08, 4.284083843231201e-08, 7.588459993712604e-08, -8.018105290830135e-09, 2.7572241378948092e-08], "REACTION_Y": [2.0197148842271417e-08, 1.1343763617333025e-07, 3.747663868125528e-08, -9.631912689656019e-08, 2.593515091575682e-08, 6.01867213845253e-08, 1.949956640601158e-09, -8.860661182552576e-08, -7.345806807279587e-08, 3.218156052753329e-08, -2.6193447411060333e-10], "REACTION_Z": [-0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0]}, "NODE_11": {"DISPLACEMENT_X": [-0.023159747118732088, -0.04625219582805491, -0.06924811794042877, -0.0921208702341926, -0.11484632499299112, -0.1374027798341993, -0.15977085152706116, -0.18193335804625596, -0.20387519261304354, -0.22558319297172424, -0.24704600865521772], "DISPLACEMENT_Y": [0.0322748694425418, 0.06357285192177727, 0.09391003694948238, 0.1233046073257605, 0.15177649904110144, 0.17934708449863404, 0.20603888085505437, 0.23187528437475333, 0.256880330943202, 0.28107848228611587, 0.30449443697849277], "DISPLACEMENT_Z": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "REACTION_X": [-1.1624251783359796e-08, 2.8330759960226715e-08, 1.4124452718533576e-09, -6.375194061547518e-08, 1.1584779713302851e-07, 5.498441169038415e-08, 4.8112269723787904e-08, -5.0767994252964854e-08, 2.0925654098391533e-08, -4.380126483738422e-09, 2.964588929899037e-08], "REACTION_Y": [-8.049573807511479e-08, -1.1311021808069199e-07, 5.453694029711187e-08, 1.0084477253258228e-08, -1.5642945072613657e-07, 1.323132892139256e-08, -8.010829333215952e-09, 1.0929943528026342e-07, -3.7180143408477306e-09, 5.086621968075633e-08, -7.447670213878155e-08], "REACTION_Z": [-0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0]}, "NODE_12": {"DISPLACEMENT_X": [-0.026957924890993353, -0.05385571660145609, -0.08065719317055729, -0.10732930387536975, -0.1338420519100233, -0.16016839082033868, -0.1862841004829285, -0.21216764787505288, -0.2378000372868771, -0.26316465401592765, -0.28824710498127953], "DISPLACEMENT_Y": [0.03753720725559549, 0.07391518097316974, 0.10915324719562115, 0.1432732516739414, 0.17629914827543822, 0.20825661574489893, 0.2391727049970478, 0.26907551801799645, 0.29799391854255325, 0.32595727394521024, 0.352995227220796], "DISPLACEMENT_Z": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "REACTION_X": [-2.0863035388174467e-07, -1.334992703050375e-07, 1.7626916815061122e-08, 1.0732037480920553e-07, -8.119604899547994e-08, -1.179778337245807e-07, 5.901893018744886e-08, 7.4323907028883696e-09, -1.196276571135968e-07, 3.2821844797581434e-08, 5.784386303275824e-10], "REACTION_Y": [2.685774234123528e-07, 1.3554017641581595e-07, -6.26459950581193e-08, -2.7281203074380755e-08, 1.0794246918521821e-07, 1.1327210813760757e-07, -3.15194483846426e-08, 1.3948010746389627e-08, 8.855568012222648e-08, -1.335865817964077e-08, 5.621404852718115e-08], "REACTION_Z": [-0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0]}, "NODE_13": {"DISPLACEMENT_X": [-0.030810337207144996, -0.061568820995915145, -0.09223207824888256, -0.12276042947867681, -0.15311780379828932, -0.18327162187592658, -0.2131926537910455, -0.2428548580755941, -0.2722352075258213, -0.30131350664729567, -0.33007220488157474], "DISPLACEMENT_Y": [0.04287314064604016, 0.08440083315414064, 0.12460571617179146, 0.1635133872974998, 0.20115191780015748, 0.23755140087792886, 0.27274353602895435, 0.30676125080200367, 0.33963836011638443, 0.3714092624773233, 0.4021086717483571], "DISPLACEMENT_Z": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "REACTION_X": [4.833805178350303e-07, 7.432936399709433e-08, -1.7727870726957917e-08, -4.068169801030308e-08, -9.400537237524986e-09, 7.123162504285574e-08, -5.530455382540822e-08, 1.4093529898673296e-08, 7.76562956161797e-08, -4.612957127392292e-09, -3.355671651661396e-08], "REACTION_Y": [-5.88341208640486e-07, -5.4125848691910505e-08, -2.128217602148652e-10, 2.8940121410414577e-08, -1.3929820852354169e-08, -1.137450453825295e-07, 3.833702066913247e-08, -3.929744707420468e-08, -5.971378413960338e-08, -4.493631422519684e-08, 1.615990186110139e-08], "REACTION_Z": [-0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0]}, "ELEMENT_1": {"FORCE_X": {"0": [2898.963481316728, 5809.793049611307, 8732.145102416653, 11665.680458516697, 14610.0655608951, 17564.97348948838, 20530.084796187708, 23505.088175488276, 26489.68098650865, 29483.569641561302, 32486.469876010044], "1": [2898.963481316728, 5809.793049611307, 8732.145102416653, 11665.680458516697, 14610.0655608951, 17564.97348948838, 20530.084796187708, 23505.088175488276, 26489.68098650865, 29483.569641561302, 32486.469876010044], "2": [2898.963481316728, 5809.793049611307, 8732.145102416653, 11665.680458516697, 14610.0655608951, 17564.97348948838, 20530.084796187708, 23505.088175488276, 26489.68098650865, 29483.569641561302, 32486.469876010044]}, "FORCE_Y": {"0": [4073.8201642944255, 8139.183295066629, 12196.296236437696, 16245.365474462851, 20286.596171976453, 24320.191327867684, 28346.35105510405, 32365.27197020991, 36377.14668622828, 40382.163400938734, 44380.50557045219], "1": [4073.8201642944255, 8139.183295066629, 12196.296236437696, 16245.365474462851, 20286.596171976453, 24320.191327867684, 28346.35105510405, 32365.27197020991, 36377.14668622828, 40382.163400938734, 44380.50557045219], "2": [4073.8201642944255, 8139.183295066629, 12196.296236437696, 16245.365474462851, 20286.596171976453, 24320.191327867684, 28346.35105510405, 32365.27197020991, 36377.14668622828, 40382.163400938734, 44380.50557045219]}, "FORCE_Z": {"0": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "1": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "2": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]}, "MOMENT_X": {"0": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "1": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "2": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]}, "MOMENT_Y": {"0": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "1": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "2": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]}, "MOMENT_Z": {"0": [-17138.46315169237, -33970.09411842876, -50496.302607126854, -66719.29194875194, -82641.968969817, -98267.85736460611, -113601.01544642137, -128645.95890565135, -143407.58898257534, -157891.1262756338, -172102.05025056977], "1": [-16770.92798913691, -33235.7764460652, -49395.93638687358, -65253.59248560313, -80811.63303275773, -96073.56338330862, -111043.42377300735, -125725.71213146405, -140125.31230062566, -154247.42788012707, -168097.5217658124], "2": [-16403.392826581454, -32501.458773701648, -48295.57016662031, -63787.893022454315, -78981.29709569846, -93879.26940201112, -108485.83209959333, -122805.46535727676, -136843.035618676, -150603.72948462033, -164092.993281055]}}, "ELEMENT_2": {"FORCE_X": {"0": [2910.346522186052, 5854.802217353525, 8832.24877318671, 11841.587422986833, 14881.742391693451, 17951.6637301356, 21050.32958493428, 24176.74795316468, 27329.957974769353, 30509.03081510888, 33713.07018720398], "1": [2910.346522186052, 5854.802217353525, 8832.24877318671, 11841.587422986833, 14881.742391693451, 17951.6637301356, 21050.32958493428, 24176.74795316468, 27329.957974769353, 30509.03081510888, 33713.07018720398], "2": [2910.346522186052, 5854.802217353525, 8832.24877318671, 11841.587422986833, 14881.742391693451, 17951.6637301356, 21050.32958493428, 24176.74795316468, 27329.957974769353, 30509.03081510888, 33713.07018720398]}, "FORCE_Y": {"0": [4065.695897026921, 8106.866905396101, 12124.00023382379, 16117.593102312874, 20088.149331250374, 24036.176267487597, 27962.182044611618, 31866.673168724155, 35750.15241426243, 39613.1170118708, 43456.05710797628], "1": [4065.695897026921, 8106.866905396101, 12124.00023382379, 16117.593102312874, 20088.149331250374, 24036.176267487597, 27962.182044611618, 31866.673168724155, 35750.15241426243, 39613.1170118708, 43456.05710797628], "2": [4065.695897026921, 8106.866905396101, 12124.00023382379, 16117.593102312874, 20088.149331250374, 24036.176267487597, 27962.182044611618, 31866.673168724155, 35750.15241426243, 39613.1170118708, 43456.05710797628]}, "FORCE_Z": {"0": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "1": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "2": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]}, "MOMENT_X": {"0": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "1": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "2": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]}, "MOMENT_Y": {"0": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "1": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "2": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]}, "MOMENT_Z": {"0": [-15669.055442865287, -31035.738856790016, -46101.35983939351, -60868.02081837534, -75338.52749100521, -89516.30270064996, -103405.30462992954, -117009.94994124872, -130335.04227603746, -143385.70633740208, -156167.32762598575], "1": [-15302.253221789417, -30304.336612250863, -45007.51573241891, -59413.84807744384, -73526.09382337611, -87347.62998058766, -100882.3688336786, -114134.6812994038, -127109.32561535109, -139811.38158569825, -152246.19045568554], "2": [-14935.451000713549, -29572.93436771171, -43913.671625444316, -57959.675336512344, -71713.66015574701, -85178.95726052536, -98359.43303742766, -111259.41265755889, -123883.6089546647, -136237.05683399443, -148325.05328538534]}}, "ELEMENT_3": {"FORCE_X": {"0": [2920.6683243328703, 5895.5105940254, 8922.554352420408, 11999.867634431645, 15125.564641093133, 18297.810319051874, 21514.82393548683, 24774.881746352727, 28076.31885438309, 31417.530356469815, 34796.971871634014], "1": [2920.6683243328703, 5895.5105940254, 8922.554352420408, 11999.867634431645, 15125.564641093133, 18297.810319051874, 21514.82393548683, 24774.881746352727, 28076.31885438309, 31417.530356469815, 34796.971871634014], "2": [2920.6683243328703, 5895.5105940254, 8922.554352420408, 11999.867634431645, 15125.564641093133, 18297.810319051874, 21514.82393548683, 24774.881746352727, 28076.31885438309, 31417.530356469815, 34796.971871634014]}, "FORCE_Y": {"0": [4058.287389606859, 8077.311113574343, 12057.695625871513, 16000.09927202182, 19905.207716251298, 23773.72788260237, 27606.382430475947, 31403.90476171806, 35167.03455478086, 38896.51380309849, 42593.083338020406], "1": [4058.287389606859, 8077.311113574343, 12057.695625871513, 16000.09927202182, 19905.207716251298, 23773.72788260237, 27606.382430475947, 31403.90476171806, 35167.03455478086, 38896.51380309849, 42593.083338020406], "2": [4058.287389606859, 8077.311113574343, 12057.695625871513, 16000.09927202182, 19905.207716251298, 23773.72788260237, 27606.382430475947, 31403.90476171806, 35167.03455478086, 38896.51380309849, 42593.083338020406]}, "FORCE_Z": {"0": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "1": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "2": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]}, "MOMENT_X": {"0": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "1": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "2": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]}, "MOMENT_Y": {"0": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "1": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "2": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]}, "MOMENT_Z": {"0": [-14202.514926818181, -28112.796261333762, -41731.96503027879, -55061.92936068555, -68105.29643277796, -80865.28773266595, -93345.65848332288, -105550.62188661241, -117484.77859300752, -129153.05162983108, -140560.6268660646], "1": [-13836.381074131412, -27384.060399504393, -40644.10254207288, -53618.356125788574, -66309.36637742819, -78720.29092486939, -90854.81972546119, -102717.09975752434, -114311.66489203472, -125643.37117738629, -136717.3376170568], "2": [-13470.247221444642, -26655.324537675024, -39556.24005386696, -52174.7828908916, -64513.436322078414, -76575.29411707283, -88363.98096759949, -99883.57762843625, -111138.55119106192, -122133.6907249415, -132874.04836804897]}}, "ELEMENT_4": {"FORCE_X": {"0": [2929.9364064020256, 5931.977372877728, 9003.258615901967, 12140.980630086335, 15342.416732248137, 18604.919459218458, 21925.925467414614, 25302.959081470417, 28733.634648956453, 32215.657847528953, 35746.82609052756], "1": [2929.9364064020256, 5931.977372877728, 9003.258615901967, 12140.980630086335, 15342.416732248137, 18604.919459218458, 21925.925467414614, 25302.959081470417, 28733.634648956453, 32215.657847528953, 35746.82609052756], "2": [2929.9364064020256, 5931.977372877728, 9003.258615901967, 12140.980630086335, 15342.416732248137, 18604.919459218458, 21925.925467414614, 25302.959081470417, 28733.634648956453, 32215.657847528953, 35746.82609052756]}, "FORCE_Y": {"0": [4051.601245397017, 8050.567957523991, 11997.555345614219, 15893.287554765835, 19738.54728054663, 23534.1660532328, 27281.015235235114, 30979.997765467753, 34632.04065087164, 38238.08819983276, 41799.09597269235], "1": [4051.601245397017, 8050.567957523991, 11997.555345614219, 15893.287554765835, 19738.54728054663, 23534.1660532328, 27281.015235235114, 30979.997765467753, 34632.04065087164, 38238.08819983276, 41799.09597269235], "2": [4051.601245397017, 8050.567957523991, 11997.555345614219, 15893.287554765835, 19738.54728054663, 23534.1660532328, 27281.015235235114, 30979.997765467753, 34632.04065087164, 38238.08819983276, 41799.09597269235]}, "FORCE_Z": {"0": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "1": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "2": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]}, "MOMENT_X": {"0": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "1": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "2": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]}, "MOMENT_Y": {"0": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "1": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "2": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]}, "MOMENT_Z": {"0": [-12738.582715498216, -25200.265456376692, -37385.94059706702, -49297.27229187865, -60936.611137825734, -72306.91193903556, -83411.6554402231, -94254.77466031339, -104840.5862438077, -115173.72706737503, -125259.09618779662], "1": [-12373.052062401555, -24473.942236897827, -36303.50362847742, -47863.33492776482, -59155.716008929274, -70183.52656879263, -80950.16867071284, -91459.49382129565, -101715.73499752367, -111723.44386226738, -121487.433256549], "2": [-12007.521409304894, -23747.61901741896, -35221.066659887816, -46429.39756365099, -57374.820880032814, -68060.1411985497, -78488.68190120258, -88664.21298227791, -98590.88375123963, -108273.16065715972, -117715.77032530139]}}, "ELEMENT_5": {"FORCE_X": {"0": [2938.1575453214455, 5964.256094380537, 9074.540001260828, 12265.344059878831, 15533.104110537115, 18874.365394652403, 22285.788862144345, 25764.155643609054, 29306.36990283868, 32909.46027757825, 36570.580106385394], "1": [2938.1575453214455, 5964.256094380537, 9074.540001260828, 12265.344059878831, 15533.104110537115, 18874.365394652403, 22285.788862144345, 25764.155643609054, 29306.36990283868, 32909.46027757825, 36570.580106385394], "2": [2938.1575453214455, 5964.256094380537, 9074.540001260828, 12265.344059878831, 15533.104110537115, 18874.365394652403, 22285.788862144345, 25764.155643609054, 29306.36990283868, 32909.46027757825, 36570.580106385394]}, "FORCE_Y": {"0": [4045.643366023135, 8026.6835783469105, 11943.73157043666, 15797.510411373665, 19588.8406207429, 23318.626271554123, 26987.84198715379, 30597.5208866919, 34148.7435151906, 37642.62776330754, 41080.31975902493], "1": [4045.643366023135, 8026.6835783469105, 11943.73157043666, 15797.510411373665, 19588.8406207429, 23318.626271554123, 26987.84198715379, 30597.5208866919, 34148.7435151906, 37642.62776330754, 41080.31975902493], "2": [4045.643366023135, 8026.6835783469105, 11943.73157043666, 15797.510411373665, 19588.8406207429, 23318.626271554123, 26987.84198715379, 30597.5208866919, 34148.7435151906, 37642.62776330754, 41080.31975902493]}, "FORCE_Z": {"0": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "1": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "2": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]}, "MOMENT_X": {"0": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "1": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "2": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]}, "MOMENT_Y": {"0": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "1": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "2": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]}, "MOMENT_Z": {"0": [-11276.997601258994, -22297.12731712693, -33061.04841116137, -43570.1632636602, -53826.5361609183, -63832.8149348495, -73592.15629817088, -83108.15549231449, -92384.7806621367, -101426.31219662374, -110237.28712913691], "1": [-10912.00444648572, -21572.958836312402, -31983.467131028556, -42144.86632779667, -52059.146570704805, -61728.87404139318, -71157.1174646675, -80347.3788413679, -89303.52881933111, -98029.74694119871, -106530.46686422656], "2": [-10547.011291712444, -20848.790355497877, -30905.885850895742, -40719.56939193314, -50291.75698049131, -59624.93314793686, -68722.07863116413, -77586.60219042131, -86222.27697652552, -94633.18168577368, -102823.64659931621]}}, "ELEMENT_6": {"FORCE_X": {"0": [2945.337770309616, 5992.394550739274, 9136.55813246685, 12373.332206196192, 15698.349692427697, 19107.383174302013, 22596.35269946886, 26161.331232900688, 29798.54803760597, 33504.39025609125, 37275.40295036712], "1": [2945.337770309616, 5992.394550739274, 9136.55813246685, 12373.332206196192, 15698.349692427697, 19107.383174302013, 22596.35269946886, 26161.331232900688, 29798.54803760597, 33504.39025609125, 37275.40295036712], "2": [2945.337770309616, 5992.394550739274, 9136.55813246685, 12373.332206196192, 15698.349692427697, 19107.383174302013, 22596.35269946886, 26161.331232900688, 29798.54803760597, 33504.39025609125, 37275.40295036712]}, "FORCE_Y": {"0": [4040.4189651876927, 8005.698441610366, 11896.356814944915, 15713.072585422831, 19456.665101423467, 23128.076187461716, 26728.35282156009, 30258.630966184235, 33720.1206200265, 37114.09211191571, 40441.86363850806], "1": [4040.4189651876927, 8005.698441610366, 11896.356814944915, 15713.072585422831, 19456.665101423467, 23128.076187461716, 26728.35282156009, 30258.630966184235, 33720.1206200265, 37114.09211191571, 40441.86363850806], "2": [4040.4189651876927, 8005.698441610366, 11896.356814944915, 15713.072585422831, 19456.665101423467, 23128.076187461716, 26728.35282156009, 30258.630966184235, 33720.1206200265, 37114.09211191571, 40441.86363850806]}, "FORCE_Z": {"0": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "1": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "2": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]}, "MOMENT_X": {"0": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "1": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "2": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]}, "MOMENT_Y": {"0": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "1": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "2": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]}, "MOMENT_Z": {"0": [-9817.496308557282, -19402.346577465065, -28754.997189972375, -37876.59300431216, -46768.901842802996, -55434.24153802388, -63875.410338926624, -72095.62126840753, -80098.44083231463, -87887.73231478676, -95467.60375850544], "1": [-9452.974480368048, -18680.071280258147, -27681.689809174997, -36458.913552568614, -45013.436295306215, -53347.49082158105, -61463.78088018945, -69365.41699733774, -77055.85653091392, -84538.84819922064, -91818.3811826142], "2": [-9088.452652178814, -17957.79598305123, -26608.38242837762, -35041.234100825066, -43257.970747809435, -51260.74010513822, -59052.151421452276, -66635.21272626796, -74013.27222951321, -81189.96408365451, -88169.15860672297]}}, "ELEMENT_7": {"FORCE_X": {"0": [2951.482385651735, 6016.434760274774, 9189.45350404899, 12465.274881116444, 15838.79115139832, 19305.063126970737, 22859.329509692678, 26497.01335282628, 30213.72599483222, 34005.2687989461, 37867.633019506866], "1": [2951.482385651735, 6016.434760274774, 9189.45350404899, 12465.274881116444, 15838.79115139832, 19305.063126970737, 22859.329509692678, 26497.01335282628, 30213.72599483222, 34005.2687989461, 37867.633019506866], "2": [2951.482385651735, 6016.434760274774, 9189.45350404899, 12465.274881116444, 15838.79115139832, 19305.063126970737, 22859.329509692678, 26497.01335282628, 30213.72599483222, 34005.2687989461, 37867.633019506866]}, "FORCE_Y": {"0": [4035.932571630036, 7987.647511353431, 11855.544874590849, 15640.234080570654, 19342.51004379205, 22963.330280526734, 26503.793204601272, 29965.117773889404, 33348.624578555224, 36655.71843010856, 39887.87245718211], "1": [4035.932571630036, 7987.647511353431, 11855.544874590849, 15640.234080570654, 19342.51004379205, 22963.330280526734, 26503.793204601272, 29965.117773889404, 33348.624578555224, 36655.71843010856, 39887.87245718211], "2": [4035.932571630036, 7987.647511353431, 11855.544874590849, 15640.234080570654, 19342.51004379205, 22963.330280526734, 26503.793204601272, 29965.117773889404, 33348.624578555224, 36655.71843010856, 39887.87245718211]}, "FORCE_Z": {"0": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "1": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "2": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]}, "MOMENT_X": {"0": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "1": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "2": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]}, "MOMENT_Y": {"0": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "1": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "2": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]}, "MOMENT_Z": {"0": [-8359.81374193627, -16514.873862508055, -24465.449508575835, -32212.446273646492, -39757.33803760907, -47102.1010351073, -54249.150892472164, -61201.2831829873, -67961.61787352561, -74533.54788691936, -80920.69187753736], "1": [-7995.696660062789, -15794.22703916686, -23395.82396958022, -30801.337898211423, -38012.1708749121, -45030.21268150942, -51857.779822230834, -58497.5579107828, -64952.547818948005, -71226.01580576229, -77321.44772422937], "2": [-7631.579578189308, -15073.580215825663, -22326.1984305846, -29390.229522776353, -36267.00371221513, -42958.32432791155, -49466.408751989504, -55793.8326385783, -61943.477764370415, -67918.48372460522, -73722.20357092137]}}, "ELEMENT_8": {"FORCE_X": {"0": [2956.595937964866, 6036.412842451885, 9233.347069093023, 12541.456336149497, 15954.978524527745, 19468.34629406606, 23076.19791249171, 26773.384705001514, 30554.9755356969, 34416.258716955046, 38352.74172550411], "1": [2956.595937964866, 6036.412842451885, 9233.347069093023, 12541.456336149497, 15954.978524527745, 19468.34629406606, 23076.19791249171, 26773.384705001514, 30554.9755356969, 34416.258716955046, 38352.74172550411], "2": [2956.595937964866, 6036.412842451885, 9233.347069093023, 12541.456336149497, 15954.978524527745, 19468.34629406606, 23076.19791249171, 26773.384705001514, 30554.9755356969, 34416.258716955046, 38352.74172550411]}, "FORCE_Y": {"0": [4032.1880490851972, 7972.560443196349, 11821.39171003024, 15579.212851625554, 19246.783119649805, 22825.06282167256, 26315.18744451972, 29718.44329489485, 33036.24480140439, 36270.11354564799, 39421.65905895468], "1": [4032.1880490851972, 7972.560443196349, 11821.39171003024, 15579.212851625554, 19246.783119649805, 22825.06282167256, 26315.18744451972, 29718.44329489485, 33036.24480140439, 36270.11354564799, 39421.65905895468], "2": [4032.1880490851972, 7972.560443196349, 11821.39171003024, 15579.212851625554, 19246.783119649805, 22825.06282167256, 26315.18744451972, 29718.44329489485, 33036.24480140439, 36270.11354564799, 39421.65905895468]}, "FORCE_Z": {"0": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "1": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "2": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]}, "MOMENT_X": {"0": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "1": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "2": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]}, "MOMENT_Y": {"0": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "1": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "2": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]}, "MOMENT_Z": {"0": [-6903.683231749481, -13633.647657401913, -20190.028477562482, -26573.51777100114, -32785.30532008581, -38827.02130895067, -44700.6815498938, -50408.635726425986, -55953.51898853805, -61338.207102345455, -66565.77524734807], "1": [-6539.903967321753, -12914.361922334601, -19123.48406354943, -25167.914394669384, -31048.774090657862, -36767.60664358775, -42326.325418041684, -47727.16408649197, -52972.63026727453, -58065.46256124672, -63008.59107708941], "2": [-6176.124702894025, -12195.076187267292, -18056.939649536376, -23762.311018337627, -29312.242861229908, -34708.19197822483, -39951.96928618957, -45045.69244655795, -49991.741546011006, -54792.718020147986, -59451.406906830765]}}, "ELEMENT_9": {"FORCE_X": {"0": [2960.6822124682067, 6052.358961331844, 9268.339972641987, 12602.11448064526, 16047.372453747948, 19598.02107364334, 23248.196915720306, 26992.27429990856, 30824.870276246515, 34740.84669971874, 38735.3098235443], "1": [2960.6822124682067, 6052.358961331844, 9268.339972641987, 12602.11448064526, 16047.372453747948, 19598.02107364334, 23248.196915720306, 26992.27429990856, 30824.870276246515, 34740.84669971874, 38735.3098235443], "2": [2960.6822124682067, 6052.358961331844, 9268.339972641987, 12602.11448064526, 16047.372453747948, 19598.02107364334, 23248.196915720306, 26992.27429990856, 30824.870276246515, 34740.84669971874, 38735.3098235443]}, "FORCE_Y": {"0": [4029.188606960715, 7960.461732499009, 11793.97617976933, 15530.187074566351, 19169.815785809595, 22713.8189194107, 26163.35872998071, 29519.775201398603, 32784.55996688684, 35959.33217272548, 39045.81632559563], "1": [4029.188606960715, 7960.461732499009, 11793.97617976933, 15530.187074566351, 19169.815785809595, 22713.8189194107, 26163.35872998071, 29519.775201398603, 32784.55996688684, 35959.33217272548, 39045.81632559563], "2": [4029.188606960715, 7960.461732499009, 11793.97617976933, 15530.187074566351, 19169.815785809595, 22713.8189194107, 26163.35872998071, 29519.775201398603, 32784.55996688684, 35959.33217272548, 39045.81632559563]}, "FORCE_Z": {"0": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "1": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "2": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]}, "MOMENT_X": {"0": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "1": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "2": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]}, "MOMENT_Y": {"0": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "1": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "2": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]}, "MOMENT_Z": {"0": [-5448.836772886052, -10757.596209435082, -15926.32411342459, -20955.52710764589, -25846.12396855034, -30599.3984580185, -35216.95420019909, -39700.6720139585, -44052.66998363676, -48275.26644151601, -52370.945942899896], "1": [-5085.328107396747, -10039.401966670122, -14862.252991321337, -19554.34657331179, -24116.53630529407, -28550.019603184868, -32856.29524605428, -37037.12322130703, -41094.487142517486, -45030.55940397261, -48847.66914924158], "2": [-4721.8194419074425, -9321.207723905163, -13798.181869218084, -18153.166038977688, -22386.9486420378, -26500.640748351238, -30495.636291909464, -34373.574428655564, -38136.30430139821, -41785.852366429215, -45324.39235558326]}}, "ELEMENT_10": {"FORCE_X": {"0": [2963.7442580291818, 6064.297334715186, 9294.513420724563, 12647.440380287248, 16116.34297408671, 19694.72087217314, 23376.321951261714, 27155.151390860516, 31025.477080731365, 34981.83183872404, 39019.01291154478], "1": [2963.7442580291818, 6064.297334715186, 9294.513420724563, 12647.440380287248, 16116.34297408671, 19694.72087217314, 23376.321951261714, 27155.151390860516, 31025.477080731365, 34981.83183872404, 39019.01291154478], "2": [2963.7442580291818, 6064.297334715186, 9294.513420724563, 12647.440380287248, 16116.34297408671, 19694.72087217314, 23376.321951261714, 27155.151390860516, 31025.477080731365, 34981.83183872404, 39019.01291154478]}, "FORCE_Y": {"0": [4026.9367969316877, 7951.370814222892, 11773.360618287106, 15493.296995318193, 19111.867754651612, 22630.023633881006, 26048.945696441293, 29370.014517677144, 32594.781356663912, 35724.94144046887, 38762.30941347392], "1": [4026.9367969316877, 7951.370814222892, 11773.360618287106, 15493.296995318193, 19111.867754651612, 22630.023633881006, 26048.945696441293, 29370.014517677144, 32594.781356663912, 35724.94144046887, 38762.30941347392], "2": [4026.9367969316877, 7951.370814222892, 11773.360618287106, 15493.296995318193, 19111.867754651612, 22630.023633881006, 26048.945696441293, 29370.014517677144, 32594.781356663912, 35724.94144046887, 38762.30941347392]}, "FORCE_Z": {"0": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "1": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "2": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]}, "MOMENT_X": {"0": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "1": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "2": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]}, "MOMENT_Y": {"0": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "1": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "2": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]}, "MOMENT_Z": {"0": [-3995.00526119011, -7885.639381231686, -11671.899459107346, -15354.132998806292, -18933.001074744367, -22409.44260467331, -25784.64014998527, -29059.987559829846, -32237.059677185716, -35317.584242107645, -38303.41605635472], "1": [-3631.6997459810823, -7168.26528130346, -10609.688171091128, -13956.280492987931, -17208.641170722163, -20367.623315815847, -23434.30296221472, -26409.9494836432, -29295.997894099626, -32094.023155332437, -34805.71655078777], "2": [-3268.394230772055, -6450.891181375235, -9547.476883074909, -12558.427987169569, -15484.28126669996, -18325.804026958383, -21083.96577444417, -23759.911407456555, -26354.936111013532, -28870.46206855723, -31308.017045220822]}}, "ELEMENT_11": {"FORCE_X": {"0": [2965.784356326703, 6072.246142893339, 9311.928434483849, 12677.57768734375, 16162.168382076181, 19758.92213017953, 23461.321767423582, 27263.120982754164, 31158.35002906114, 35141.31804584933, 39206.61249839077], "1": [2965.784356326703, 6072.246142893339, 9311.928434483849, 12677.57768734375, 16162.168382076181, 19758.92213017953, 23461.321767423582, 27263.120982754164, 31158.35002906114, 35141.31804584933, 39206.61249839077], "2": [2965.784356326703, 6072.246142893339, 9311.928434483849, 12677.57768734375, 16162.168382076181, 19758.92213017953, 23461.321767423582, 27263.120982754164, 31158.35002906114, 35141.31804584933, 39206.61249839077]}, "FORCE_Y": {"0": [4025.434529995418, 7945.302184860956, 11759.59135728177, 15468.646485406218, 19073.130665021545, 22573.989379371527, 25972.415776390837, 29269.81781146422, 32467.78748273093, 35568.07229353779, 38572.54901136757], "1": [4025.434529995418, 7945.302184860956, 11759.59135728177, 15468.646485406218, 19073.130665021545, 22573.989379371527, 25972.415776390837, 29269.81781146422, 32467.78748273093, 35568.07229353779, 38572.54901136757], "2": [4025.434529995418, 7945.302184860956, 11759.59135728177, 15468.646485406218, 19073.130665021545, 22573.989379371527, 25972.415776390837, 29269.81781146422, 32467.78748273093, 35568.07229353779, 38572.54901136757]}, "FORCE_Z": {"0": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "1": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "2": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]}, "MOMENT_X": {"0": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "1": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "2": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]}, "MOMENT_Y": {"0": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "1": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "2": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]}, "MOMENT_Z": {"0": [-2541.9187296194555, -5016.690466872876, -7424.296502392874, -9764.946816524509, -12039.05611462208, -14247.220570956237, -16390.195557230374, -18468.874563512458, -20484.26945620463, -22437.492162255552, -24329.737823318457], "1": [-2178.7487436145643, -4299.86385228174, -6363.327409737267, -8369.318151703796, -10318.190866554425, -12210.456403805325, -14046.762527793115, -15827.875795746098, -17554.66458446717, -19228.08334274396, -20849.158106969557], "2": [-1815.5787576096732, -3583.0372376906057, -5302.358317081659, -6973.689486883082, -8597.32561848677, -10173.692236654413, -11703.329498355855, -13186.877027979737, -14625.059712729708, -16018.674523232366, -17368.578390620656]}}, "ELEMENT_12": {"FORCE_X": {"0": [2966.8040200977184, 6076.217501966251, 9320.625731947765, 12692.622310613579, 16185.034534513916, 19790.943070278685, 23503.69646304386, 27316.92104307476, 31224.526794584726, 35220.70973403892, 39299.95131849845], "1": [2966.8040200977184, 6076.217501966251, 9320.625731947765, 12692.622310613579, 16185.034534513916, 19790.943070278685, 23503.69646304386, 27316.92104307476, 31224.526794584726, 35220.70973403892, 39299.95131849845], "2": [2966.8040200977184, 6076.217501966251, 9320.625731947765, 12692.622310613579, 16185.034534513916, 19790.943070278685, 23503.69646304386, 27316.92104307476, 31224.526794584726, 35220.70973403892, 39299.95131849845]}, "FORCE_Y": {"0": [4024.683080434069, 7942.265473870964, 11752.699091757899, 15456.304177866912, 19053.73079080591, 22545.921411286763, 25934.07512213666, 29219.61369602825, 32404.149830255592, 35489.457667647286, 38477.445679540266], "1": [4024.683080434069, 7942.265473870964, 11752.699091757899, 15456.304177866912, 19053.73079080591, 22545.921411286763, 25934.07512213666, 29219.61369602825, 32404.149830255592, 35489.457667647286, 38477.445679540266], "2": [4024.683080434069, 7942.265473870964, 11752.699091757899, 15456.304177866912, 19053.73079080591, 22545.921411286763, 25934.07512213666, 29219.61369602825, 32404.149830255592, 35489.457667647286, 38477.445679540266]}, "FORCE_Z": {"0": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "1": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "2": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]}, "MOMENT_X": {"0": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "1": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "2": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]}, "MOMENT_Y": {"0": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "1": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "2": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]}, "MOMENT_Z": {"0": [-1089.30657874809, -2149.6579673302876, -3181.0419183139043, -4183.545616545518, -5157.345277831548, -6102.696052119789, -7019.922351695232, -7909.408695151972, -8771.591130742354, -9606.949277779659, -10415.999005717169], "1": [-726.2043858287226, -1433.1053115588338, -2120.694612208629, -2789.0304110274365, -3438.2301852213022, -4068.4640347544932, -4679.948234459549, -5272.939130103614, -5847.7274205007525, -6404.6328518548335, -6943.999337142682], "2": [-363.1021929093553, -716.5526557873802, -1060.3473061033542, -1394.5152055093554, -1719.1150926110572, -2034.2320173891974, -2339.9741172238655, -2636.4695650552567, -2923.8637102591483, -3202.316425930009, -3471.999668568195]}}}
\ No newline at end of file
diff --git a/applications/StructuralMechanicsApplication/tests/cpp_tests/test_complex_orientation_mpc.cpp b/applications/StructuralMechanicsApplication/tests/cpp_tests/test_complex_orientation_mpc.cpp
index f292d3031b..5f385a5658 100644
--- a/applications/StructuralMechanicsApplication/tests/cpp_tests/test_complex_orientation_mpc.cpp
+++ b/applications/StructuralMechanicsApplication/tests/cpp_tests/test_complex_orientation_mpc.cpp
@@ -17,7 +17,7 @@
 // Project includes
 #include "containers/model.h"
 #include "testing/testing.h"
-// #include "includes/gid_io.h"
+#include "includes/gid_io.h"
 #include "utilities/variable_utils.h"
 #include "spaces/ublas_space.h"
 
@@ -63,21 +63,21 @@ namespace Kratos
         typedef SolvingStrategy<SparseSpaceType, LocalSpaceType, LinearSolverType> SolvingStrategyType;
         typedef ResidualBasedLinearStrategy< SparseSpaceType, LocalSpaceType, LinearSolverType > ResidualBasedLinearStrategyType;
 
-//         void ComplexOrientationMPCGiDIODebug(ModelPart& rModelPart)
-//         {
-//             GidIO<> gid_io("TEST_COMPLEX_MPC", GiD_PostBinary, SingleFile, WriteUndeformed,  WriteElementsOnly);
-//             const int nl_iter = rModelPart.GetProcessInfo()[NL_ITERATION_NUMBER];
-//             const double label = static_cast<double>(nl_iter);
-//
-//             gid_io.InitializeMesh(label);
-//             gid_io.WriteMesh(rModelPart.GetMesh());
-//             gid_io.FinalizeMesh();
-//             gid_io.WriteNodalResults(DISPLACEMENT, rModelPart.Nodes(), label, 0);
-//             gid_io.WriteNodalResults(LAGRANGE_DISPLACEMENT, rModelPart.Nodes(), label, 0);
-//             gid_io.WriteNodalResults(FORCE_RESIDUAL, rModelPart.Nodes(), label, 0);
-//             gid_io.WriteNodalResults(REACTION, rModelPart.Nodes(), label, 0);
-//             gid_io.InitializeResults(label, rModelPart.GetMesh());
-//         }
+        void ComplexOrientationMPCGiDIODebug(ModelPart& rModelPart)
+        {
+            GidIO<> gid_io("TEST_COMPLEX_MPC", GiD_PostBinary, SingleFile, WriteUndeformed,  WriteElementsOnly);
+            const int nl_iter = rModelPart.GetProcessInfo()[NL_ITERATION_NUMBER];
+            const double label = static_cast<double>(nl_iter);
+
+            gid_io.InitializeMesh(label);
+            gid_io.WriteMesh(rModelPart.GetMesh());
+            gid_io.FinalizeMesh();
+            gid_io.WriteNodalResults(DISPLACEMENT, rModelPart.Nodes(), label, 0);
+            gid_io.WriteNodalResults(LAGRANGE_DISPLACEMENT, rModelPart.Nodes(), label, 0);
+            gid_io.WriteNodalResults(FORCE_RESIDUAL, rModelPart.Nodes(), label, 0);
+            gid_io.WriteNodalResults(REACTION, rModelPart.Nodes(), label, 0);
+            gid_io.InitializeResults(label, rModelPart.GetMesh());
+        }
 
         void CreateComplexOrientationMPCGeometry(ModelPart& rModelPart)
         {
@@ -160,8 +160,7 @@ namespace Kratos
             pstrategy->SetEchoLevel(0);
             pstrategy->Solve();
 
-//             // DEBUG ONLY
-//             ComplexOrientationMPCGiDIODebug(r_model_part);
+            ComplexOrientationMPCGiDIODebug(r_model_part);
 
             KRATOS_CHECK_LESS_EQUAL(std::abs(r_model_part.Nodes()[2].FastGetSolutionStepValue(DISPLACEMENT_X) + 5.3651e-7), 1.0e-4);
             KRATOS_CHECK_LESS_EQUAL(std::abs(r_model_part.Nodes()[2].FastGetSolutionStepValue(DISPLACEMENT_Y) + 5.3651e-7), 1.0e-4);
diff --git a/applications/StructuralMechanicsApplication/tests/cpp_tests/test_constitutive_law_utilities.cpp b/applications/StructuralMechanicsApplication/tests/cpp_tests/test_constitutive_law_utilities.cpp
index b06f0b4f71..0b96e781e3 100644
--- a/applications/StructuralMechanicsApplication/tests/cpp_tests/test_constitutive_law_utilities.cpp
+++ b/applications/StructuralMechanicsApplication/tests/cpp_tests/test_constitutive_law_utilities.cpp
@@ -16,9 +16,6 @@
 // Project includes
 #include "testing/testing.h"
 #include "utilities/math_utils.h"
-#include "includes/node.h"
-#include "containers/model.h"
-#include "geometries/triangle_2d_3.h"
 #include "custom_utilities/constitutive_law_utilities.h"
 
 namespace Kratos
@@ -29,9 +26,6 @@ namespace Testing
     // Tolerance
     static constexpr double tolerance = 1.0e-6;
 
-    // NodeType
-    typedef Node<3> NodeType;
-
 /**
 * Check the correct calculation of the CL utilities principal stress
 */
@@ -116,7 +110,6 @@ KRATOS_TEST_CASE_IN_SUITE(ConstitutiveLawUtilitiesHenckyAndBiot, KratosStructura
     KRATOS_CHECK_LESS_EQUAL((0.0 - strain_vector[2])/(strain_vector[2] + 1.0e-12), tolerance);
     KRATOS_CHECK_LESS_EQUAL((-0.097729 - strain_vector[3])/strain_vector[3], tolerance);
 }
-
 /**
 * Check the correct calculation of the CL utilities Hencky and Biot strains
 */
@@ -155,7 +148,6 @@ KRATOS_TEST_CASE_IN_SUITE(ConstitutiveLawUtilitiesAlmansiAndGreen, KratosStructu
     KRATOS_CHECK_LESS_EQUAL((0.0 - strain_vector[2])/(strain_vector[2] + 1.0e-12), tolerance);
     KRATOS_CHECK_LESS_EQUAL((-0.0458716 - strain_vector[3])/strain_vector[3], tolerance);
 }
-
 /**
 * Check the correct calculation of the CL utilities Hencky and Biot strains
 */
@@ -180,11 +172,11 @@ KRATOS_TEST_CASE_IN_SUITE(ConstitutiveLawUtilitiesPolarDecomposition, KratosStru
 //     KRATOS_WATCH(R)
 //     KRATOS_WATCH(U)
 //     KRATOS_WATCH(prod(R, U))
-
+    
     // Reference solutions
     Matrix R_ref = ZeroMatrix(3, 3);
     Matrix U_ref = ZeroMatrix(3, 3);
-
+    
     R_ref(0, 0) = 0.850651;
     R_ref(0, 1) = 0.525731;
     R_ref(1, 0) = -0.525731;
@@ -195,44 +187,9 @@ KRATOS_TEST_CASE_IN_SUITE(ConstitutiveLawUtilitiesPolarDecomposition, KratosStru
     U_ref(1, 0) = 0.493239;
     U_ref(1, 1) = 0.798078;
     U_ref(2, 2) = 1.0;
-
+    
     KRATOS_CHECK_LESS_EQUAL(norm_frobenius(R-R_ref), tolerance);
     KRATOS_CHECK_LESS_EQUAL(norm_frobenius(U-U_ref), tolerance);
 }
-/**
-* Check the correct calculation of the CL utilities Hencky and Biot strains
-*/
-KRATOS_TEST_CASE_IN_SUITE(CalculateCharacteristicLength, KratosStructuralMechanicsFastSuite)
-{
-    // Model part
-    Model current_model;
-    ModelPart& this_model_part = current_model.CreateModelPart("Main");
-
-    // First we create the nodes
-    NodeType::Pointer p_node_1 = this_model_part.CreateNewNode(1, 0.0 , 0.0 , 0.0);
-    NodeType::Pointer p_node_2 = this_model_part.CreateNewNode(2, 1.0 , 0.0 , 0.0);
-    NodeType::Pointer p_node_3 = this_model_part.CreateNewNode(3, 1.0 , 1.0 , 0.0);
-
-    // Now we create the "conditions"
-    std::vector<NodeType::Pointer> element_nodes (3);
-    element_nodes[0] = p_node_1;
-    element_nodes[1] = p_node_2;
-    element_nodes[2] = p_node_3;
-    Triangle2D3 <NodeType> triangle( PointerVector<NodeType>{element_nodes} );
-
-    array_1d<double, 3> delta_disp = ZeroVector(3);
-    delta_disp[0] = 1.0e-2;
-    p_node_1->Coordinates() += delta_disp;
-
-    // Compute CalculateCharacteristicLength
-    const double length = ConstitutiveLawUtilities<3>::CalculateCharacteristicLength(triangle);
-
-    KRATOS_CHECK_NEAR(length,  0.743871, tolerance);
-
-    // Compute CalculateCharacteristicLengthOnReferenceConfiguration
-    const double length_origin = ConstitutiveLawUtilities<3>::CalculateCharacteristicLengthOnReferenceConfiguration(triangle);
-
-    KRATOS_CHECK_NEAR(length_origin,  0.745356, tolerance);
-}
 } // namespace Testing
 } // namespace Kratos
diff --git a/applications/StructuralMechanicsApplication/tests/cpp_tests/test_d+d-damage_law_masonry_2d.cpp b/applications/StructuralMechanicsApplication/tests/cpp_tests/test_d+d-damage_law_masonry_2d.cpp
deleted file mode 100644
index 89808a79be..0000000000
--- a/applications/StructuralMechanicsApplication/tests/cpp_tests/test_d+d-damage_law_masonry_2d.cpp
+++ /dev/null
@@ -1,252 +0,0 @@
-// KRATOS  ___|  |                   |                   |
-//       \___ \  __|  __| |   |  __| __| |   |  __| _` | |
-//             | |   |    |   | (    |   |   | |   (   | |
-//       _____/ \__|_|   \__,_|\___|\__|\__,_|_|  \__,_|_| MECHANICS
-//
-//  License:         BSD License
-//                     license: structural_mechanics_application/license.txt
-//
-//  Main authors:    Philip Kalkbrenner
-//					 Alejandro Cornejo
-//
-
-// System includes
-
-// External includes
-
-// Project includes
-#include "includes/process_info.h"
-#include "testing/testing.h"
-#include "containers/model.h"
-
-// Application includes
-
-// Constitutive law
-#include "custom_constitutive/plane_stress_d_plus_d_minus_damage_masonry_2d.h"
-#include "includes/model_part.h"
-#include "geometries/triangle_2d_3.h"
-#include "structural_mechanics_application_variables.h"
-
-namespace Kratos
-{
-namespace Testing
-{
-// We test the d+ d- damage Constitutive Law (for masonry) 2D...
-typedef Node<3> NodeType;
-
-/**
-    * Check the correct calculation of the integrated stress with the CL's
-    */
-KRATOS_TEST_CASE_IN_SUITE(DPlusDMinusMasonry2DPureTensionTest, KratosStructuralMechanicsFastSuite)
-{
-    ConstitutiveLaw::Parameters cl_parameters;
-    Properties material_properties;
-    ProcessInfo process_info;
-    Vector stress_vector, strain_vector;
-
-    Model current_model;
-    ModelPart& test_model_part = current_model.CreateModelPart("Main");
-
-    NodeType::Pointer p_node_1 = test_model_part.CreateNewNode(1, 0.0, 0.0, 0.0);
-    NodeType::Pointer p_node_2 = test_model_part.CreateNewNode(2, 1.0, 0.5, 0.0);
-    NodeType::Pointer p_node_3 = test_model_part.CreateNewNode(3, 0.0, 1.0, 0.0);
-
-    Triangle2D3<NodeType> Geom = Triangle2D3<NodeType>(p_node_1, p_node_2, p_node_3);
-
-    stress_vector = ZeroVector(3);
-    strain_vector = ZeroVector(3);
-    strain_vector[0] = 0.000787;
-    strain_vector[1] = 0.0;
-    strain_vector[2] = 0.0;
-
-    material_properties.SetValue(YOUNG_MODULUS, 3718.0e+6);
-    material_properties.SetValue(POISSON_RATIO, 0.2);
-    material_properties.SetValue(YIELD_STRESS_TENSION, 1.559e+6);
-    material_properties.SetValue(FRACTURE_ENERGY_TENSION, 10.0e+2);
-    material_properties.SetValue(DAMAGE_ONSET_STRESS_COMPRESSION, 10.0e+6);
-    material_properties.SetValue(YIELD_STRESS_COMPRESSION, 17.99e+6);
-    material_properties.SetValue(YIELD_STRAIN_COMPRESSION, 0.02);
-    material_properties.SetValue(RESIDUAL_STRESS_COMPRESSION, 2.00e+6);
-    material_properties.SetValue(BIAXIAL_COMPRESSION_MULTIPLIER, 1.20);
-    material_properties.SetValue(FRACTURE_ENERGY_COMPRESSION, 8.0e+5);
-    material_properties.SetValue(SHEAR_COMPRESSION_REDUCTOR, 0.16);
-    material_properties.SetValue(BEZIER_CONTROLLER_C1, 0.65);
-    material_properties.SetValue(BEZIER_CONTROLLER_C2,  0.45);
-    material_properties.SetValue(BEZIER_CONTROLLER_C3, 1.5);
-    material_properties.SetValue(DELAY_TIME, 1.0);
-
-    Flags cl_options;
-    cl_options.Set(ConstitutiveLaw::COMPUTE_STRESS, true);
-    cl_options.Set(ConstitutiveLaw::USE_ELEMENT_PROVIDED_STRAIN, true);
-    cl_options.Set(ConstitutiveLaw::COMPUTE_CONSTITUTIVE_TENSOR, false);
-
-    //process_info.SetValue(DELTA_TIME, 0.1);
-
-    cl_parameters.SetElementGeometry(Geom);
-    cl_parameters.SetMaterialProperties(material_properties);
-    cl_parameters.SetStrainVector(strain_vector);
-    cl_parameters.SetStressVector(stress_vector);
-    cl_parameters.SetProcessInfo(process_info);
-    cl_parameters.SetOptions(cl_options);
-    Matrix const_matrix;
-    cl_parameters.SetConstitutiveMatrix(const_matrix);
-
-    // Create the CL
-    DamageDPlusDMinusMasonry2DLaw masonry2d_cl = DamageDPlusDMinusMasonry2DLaw();
-
-    std::vector<double> masonry2d_res;
-    masonry2d_res = {926316.0, 185263.0, 0};
-
-    Vector test_masonry2d_stress;
-    masonry2d_cl.CalculateMaterialResponseCauchy(cl_parameters);
-    test_masonry2d_stress = cl_parameters.GetStressVector();
-
-    // Check the results
-    for (int comp = 0; comp < 3; comp++) {
-        // KRATOS_CHECK_NEAR(test_masonry2d_stress[comp], masonry2d_res[comp], 0.0001e6);
-    }
-}
-
-KRATOS_TEST_CASE_IN_SUITE(DPlusDMinusMasonry2DPureCompressionTest, KratosStructuralMechanicsFastSuite)
-{
-    ConstitutiveLaw::Parameters cl_parameters;
-    Properties material_properties;
-    ProcessInfo process_info;
-    Vector stress_vector, strain_vector;
-
-    Model current_model;
-    ModelPart& test_model_part = current_model.CreateModelPart("Main");
-
-    NodeType::Pointer p_node_1 = test_model_part.CreateNewNode(1, 0.0, 0.0, 0.0);
-    NodeType::Pointer p_node_2 = test_model_part.CreateNewNode(2, 1.0, 0.5, 0.0);
-    NodeType::Pointer p_node_3 = test_model_part.CreateNewNode(3, 0.0, 1.0, 0.0);
-
-    Triangle2D3<NodeType> Geom = Triangle2D3<NodeType>(p_node_1, p_node_2, p_node_3);
-
-    stress_vector = ZeroVector(3);
-    strain_vector = ZeroVector(3);
-    strain_vector[0] = -0.02227;
-    strain_vector[1] = 0.0;
-    strain_vector[2] = 0.0;
- 
-    material_properties.SetValue(YOUNG_MODULUS, 3718.0e+6);
-    material_properties.SetValue(POISSON_RATIO, 0.2);
-    material_properties.SetValue(YIELD_STRESS_TENSION, 1.559e+6);
-    material_properties.SetValue(FRACTURE_ENERGY_TENSION, 10.0e+2);
-    material_properties.SetValue(DAMAGE_ONSET_STRESS_COMPRESSION, 10.0e+6);
-    material_properties.SetValue(YIELD_STRESS_COMPRESSION, 17.99e+6);
-    material_properties.SetValue(YIELD_STRAIN_COMPRESSION, 0.02);
-    material_properties.SetValue(RESIDUAL_STRESS_COMPRESSION, 2.00e+6);
-    material_properties.SetValue(BIAXIAL_COMPRESSION_MULTIPLIER, 1.20);
-    material_properties.SetValue(FRACTURE_ENERGY_COMPRESSION, 8.0e+5);
-    material_properties.SetValue(SHEAR_COMPRESSION_REDUCTOR, 0.16);
-    material_properties.SetValue(BEZIER_CONTROLLER_C1, 0.65);
-    material_properties.SetValue(BEZIER_CONTROLLER_C2,  0.45);
-    material_properties.SetValue(BEZIER_CONTROLLER_C3, 1.5);
-    material_properties.SetValue(DELAY_TIME, 1.0);
-
-    Flags cl_options;
-    cl_options.Set(ConstitutiveLaw::COMPUTE_STRESS, true);
-    cl_options.Set(ConstitutiveLaw::USE_ELEMENT_PROVIDED_STRAIN, true);
-    cl_options.Set(ConstitutiveLaw::COMPUTE_CONSTITUTIVE_TENSOR, false);
-
-    //process_info.SetValue(DELTA_TIME, 0.1);
-
-    cl_parameters.SetElementGeometry(Geom);
-    cl_parameters.SetMaterialProperties(material_properties);
-    cl_parameters.SetStrainVector(strain_vector);
-    cl_parameters.SetStressVector(stress_vector);
-    cl_parameters.SetProcessInfo(process_info);
-    cl_parameters.SetOptions(cl_options);
-    Matrix const_matrix;
-    cl_parameters.SetConstitutiveMatrix(const_matrix);
-
-    // Create the CL
-    DamageDPlusDMinusMasonry2DLaw masonry2d_cl = DamageDPlusDMinusMasonry2DLaw();
-
-    std::vector<double> masonry2d_res;
-    masonry2d_res = {-2.06954e+07,  -4.13908e+06, 0};
-
-    Vector test_masonry2d_stress;
-    masonry2d_cl.CalculateMaterialResponseCauchy(cl_parameters);
-    test_masonry2d_stress = cl_parameters.GetStressVector();
-
-    // Check the results
-    for (int comp = 0; comp < 3; comp++) {
-        KRATOS_CHECK_NEAR(test_masonry2d_stress[comp], masonry2d_res[comp], 0.0001e6);
-    }
-}
-
-KRATOS_TEST_CASE_IN_SUITE(DPlusDMinusMasonry2DPMixedStateTest, KratosStructuralMechanicsFastSuite)
-{
-    ConstitutiveLaw::Parameters cl_parameters;
-    Properties material_properties;
-    ProcessInfo process_info;
-    Vector stress_vector, strain_vector;
-
-    Model current_model;
-    ModelPart& test_model_part = current_model.CreateModelPart("Main");
-
-    NodeType::Pointer p_node_1 = test_model_part.CreateNewNode(1, 0.0, 0.0, 0.0);
-    NodeType::Pointer p_node_2 = test_model_part.CreateNewNode(2, 1.0, 0.5, 0.0);
-    NodeType::Pointer p_node_3 = test_model_part.CreateNewNode(3, 0.0, 1.0, 0.0);
-
-    Triangle2D3<NodeType> Geom = Triangle2D3<NodeType>(p_node_1, p_node_2, p_node_3);
-
-    stress_vector = ZeroVector(3);
-    strain_vector = ZeroVector(3);
-    strain_vector[0] = 0.0;
-    strain_vector[1] = 0.0;
-    strain_vector[2] = -0.005218;
- 
-    material_properties.SetValue(YOUNG_MODULUS, 3718.0e+6);
-    material_properties.SetValue(POISSON_RATIO, 0.2);
-    material_properties.SetValue(YIELD_STRESS_TENSION, 1.559e+6);
-    material_properties.SetValue(FRACTURE_ENERGY_TENSION, 10.0e+3);
-    material_properties.SetValue(DAMAGE_ONSET_STRESS_COMPRESSION, 10.0e+6);
-    material_properties.SetValue(YIELD_STRESS_COMPRESSION, 17.99e+6);
-    material_properties.SetValue(YIELD_STRAIN_COMPRESSION, 0.02);
-    material_properties.SetValue(RESIDUAL_STRESS_COMPRESSION, 2.00e+6);
-    material_properties.SetValue(BIAXIAL_COMPRESSION_MULTIPLIER, 1.20);
-    material_properties.SetValue(FRACTURE_ENERGY_COMPRESSION, 8.0e+5);
-    material_properties.SetValue(SHEAR_COMPRESSION_REDUCTOR, 0.16);
-    material_properties.SetValue(BEZIER_CONTROLLER_C1, 0.65);
-    material_properties.SetValue(BEZIER_CONTROLLER_C2,  0.45);
-    material_properties.SetValue(BEZIER_CONTROLLER_C3, 1.5);
-    material_properties.SetValue(DELAY_TIME, 1.0);
-
-    Flags cl_options;
-    cl_options.Set(ConstitutiveLaw::COMPUTE_STRESS, true);
-    cl_options.Set(ConstitutiveLaw::USE_ELEMENT_PROVIDED_STRAIN, true);
-    cl_options.Set(ConstitutiveLaw::COMPUTE_CONSTITUTIVE_TENSOR, false);
-
-    //process_info.SetValue(DELTA_TIME, 0.1);
-
-    cl_parameters.SetElementGeometry(Geom);
-    cl_parameters.SetMaterialProperties(material_properties);
-    cl_parameters.SetStrainVector(strain_vector);
-    cl_parameters.SetStressVector(stress_vector);
-    cl_parameters.SetProcessInfo(process_info);
-    cl_parameters.SetOptions(cl_options);
-    Matrix const_matrix;
-    cl_parameters.SetConstitutiveMatrix(const_matrix);
-
-    // Create the CL
-    DamageDPlusDMinusMasonry2DLaw masonry2d_cl = DamageDPlusDMinusMasonry2DLaw();
-
-    std::vector<double> masonry2d_res;
-    masonry2d_res = {-1.57685e+06, -1.57685e+06, -5.93494e+06};
-
-    Vector test_masonry2d_stress;
-    masonry2d_cl.CalculateMaterialResponseCauchy(cl_parameters);
-    test_masonry2d_stress = cl_parameters.GetStressVector();
-
-    // Check the results
-    for (int comp = 0; comp < 3; comp++) {
-        KRATOS_CHECK_NEAR(test_masonry2d_stress[comp], masonry2d_res[comp], 0.0001e6);
-    }
-}
-
-
-} // namespace Testing
-} // namespace Kratos
diff --git a/applications/StructuralMechanicsApplication/tests/cpp_tests/test_d+d-damage_law_masonry_3d.cpp b/applications/StructuralMechanicsApplication/tests/cpp_tests/test_d+d-damage_law_masonry_3d.cpp
deleted file mode 100644
index 36d3141953..0000000000
--- a/applications/StructuralMechanicsApplication/tests/cpp_tests/test_d+d-damage_law_masonry_3d.cpp
+++ /dev/null
@@ -1,267 +0,0 @@
-// KRATOS  ___|  |                   |                   |
-//       \___ \  __|  __| |   |  __| __| |   |  __| _` | |
-//             | |   |    |   | (    |   |   | |   (   | |
-//       _____/ \__|_|   \__,_|\___|\__|\__,_|_|  \__,_|_| MECHANICS
-//
-//  License:         BSD License
-//                     license: structural_mechanics_application/license.txt
-//
-//  Main authors:    Philip Kalkbrenner
-//                   Alejandro Cornejo
-//
-
-// System includes
-
-// External includes
-
-// Project includes
-#include "includes/process_info.h"
-#include "testing/testing.h"
-#include "containers/model.h"
-
-// Application includes
-
-// Constitutive law
-#include "custom_constitutive/d_plus_d_minus_damage_masonry_3d.h"
-#include "includes/model_part.h"
-#include "geometries/tetrahedra_3d_4.h"
-#include "structural_mechanics_application_variables.h"
-
-namespace Kratos
-{
-namespace Testing
-{
-// We test the d+ d- damage Constitutive Law (for masonry) 2D...
-typedef Node<3> NodeType;
-
-/**
-* Check the correct calculation of the integrated stress with the CL's
-*/
-
-KRATOS_TEST_CASE_IN_SUITE(DPlusDMinusMasonry3DPureCompression, KratosStructuralMechanicsFastSuite)
-{
-    ConstitutiveLaw::Parameters cl_parameters;
-    Properties material_properties;
-    ProcessInfo process_info;
-    Vector stress_vector, strain_vector;
-
-    Model current_model;
-    ModelPart& test_model_part = current_model.CreateModelPart("Main");
-
-    NodeType::Pointer p_node_1 = test_model_part.CreateNewNode(1, 1.0, 0.0, 0.0);
-    NodeType::Pointer p_node_2 = test_model_part.CreateNewNode(2, 0.5, 0.5, 0.0);
-    NodeType::Pointer p_node_3 = test_model_part.CreateNewNode(3, 0.5, 0.1666666667, 0.5);
-    NodeType::Pointer p_node_4 = test_model_part.CreateNewNode(4, 0.0, 0.0, 0.0);
-
-    Tetrahedra3D4<NodeType> Geom = Tetrahedra3D4<NodeType>(p_node_1, p_node_2, p_node_3, p_node_4);
-
-    stress_vector = ZeroVector(6);
-    strain_vector = ZeroVector(6);
-    strain_vector[0] = 0.0;
-    strain_vector[1] = 0.0;
-    strain_vector[2] = -0.014644;
-    strain_vector[3] = 0.0;
-    strain_vector[4] = 0.0;
-    strain_vector[5] = 0.0;
-
-    material_properties.SetValue(YOUNG_MODULUS, 3718.0e+6);
-    material_properties.SetValue(POISSON_RATIO, 0.2);
-    material_properties.SetValue(YIELD_STRESS_TENSION, 1.559e+6);
-    material_properties.SetValue(FRACTURE_ENERGY_TENSION, 5.0e+3);
-    material_properties.SetValue(DAMAGE_ONSET_STRESS_COMPRESSION, 10.0e+6);
-    material_properties.SetValue(YIELD_STRESS_COMPRESSION, 17.99e+6);
-    material_properties.SetValue(YIELD_STRAIN_COMPRESSION, 0.02);
-    material_properties.SetValue(RESIDUAL_STRESS_COMPRESSION, 2.00e+6);
-    material_properties.SetValue(BIAXIAL_COMPRESSION_MULTIPLIER, 1.20);
-    material_properties.SetValue(FRACTURE_ENERGY_COMPRESSION, 6.0e+5);
-    material_properties.SetValue(SHEAR_COMPRESSION_REDUCTOR, 0.16);
-    material_properties.SetValue(BEZIER_CONTROLLER_C1, 0.65);
-    material_properties.SetValue(BEZIER_CONTROLLER_C2,  0.55);
-    material_properties.SetValue(BEZIER_CONTROLLER_C3, 1.5);
-    material_properties.SetValue(TRIAXIAL_COMPRESSION_COEFFICIENT, 0.66);
-    material_properties.SetValue(DELAY_TIME, 1.0);
-
-    Flags cl_options;
-    cl_options.Set(ConstitutiveLaw::COMPUTE_STRESS, true);
-    cl_options.Set(ConstitutiveLaw::USE_ELEMENT_PROVIDED_STRAIN, true);
-    cl_options.Set(ConstitutiveLaw::COMPUTE_CONSTITUTIVE_TENSOR, false);
-
-    //process_info.SetValue(DELTA_TIME, 0.1);
-
-    cl_parameters.SetElementGeometry(Geom);
-    cl_parameters.SetMaterialProperties(material_properties);
-    cl_parameters.SetStrainVector(strain_vector);
-    cl_parameters.SetStressVector(stress_vector);
-    cl_parameters.SetProcessInfo(process_info);
-    cl_parameters.SetOptions(cl_options);
-    Matrix const_matrix(6,6);
-    cl_parameters.SetConstitutiveMatrix(const_matrix);
-
-    // Create the CL
-    DamageDPlusDMinusMasonry3DLaw masonry3d_cl = DamageDPlusDMinusMasonry3DLaw();
-
-    std::vector<double> masonry3d_res;
-    masonry3d_res = {-2.87488e+06,  -2.87488e+06, -1.14995e+07, 0.0, 0.0, 0.0};
-
-    Vector test_masonry3d_stress;
-    masonry3d_cl.CalculateMaterialResponseCauchy(cl_parameters);
-    test_masonry3d_stress = cl_parameters.GetStressVector();
-
-    // Check the results
-    for (int comp = 0; comp < 6; comp++) {
-        KRATOS_CHECK_NEAR(test_masonry3d_stress[comp], masonry3d_res[comp], 0.0001e6);
-    }
-}
-
-KRATOS_TEST_CASE_IN_SUITE(DPlusDMinusMasonry3DPureTension, KratosStructuralMechanicsFastSuite)
-{
-    ConstitutiveLaw::Parameters cl_parameters;
-    Properties material_properties;
-    ProcessInfo process_info;
-    Vector stress_vector, strain_vector;
-
-    Model current_model;
-    ModelPart& test_model_part = current_model.CreateModelPart("Main");
-
-    NodeType::Pointer p_node_1 = test_model_part.CreateNewNode(1, 1.0, 0.0, 0.0);
-    NodeType::Pointer p_node_2 = test_model_part.CreateNewNode(2, 0.5, 0.5, 0.0);
-    NodeType::Pointer p_node_3 = test_model_part.CreateNewNode(3, 0.5, 0.1666666667, 0.5);
-    NodeType::Pointer p_node_4 = test_model_part.CreateNewNode(4, 0.0, 0.0, 0.0);
-
-    Tetrahedra3D4<NodeType> Geom = Tetrahedra3D4<NodeType>(p_node_1, p_node_2, p_node_3, p_node_4);
-
-    stress_vector = ZeroVector(6);
-    strain_vector = ZeroVector(6);
-    strain_vector[0] = 0.0;
-    strain_vector[1] = 0.0;
-    strain_vector[2] = 0.000728;
-    strain_vector[3] = 0.0;
-    strain_vector[4] = 0.0;
-    strain_vector[5] = 0.0;
-
-    material_properties.SetValue(YOUNG_MODULUS, 3718.0e+6);
-    material_properties.SetValue(POISSON_RATIO, 0.2);
-    material_properties.SetValue(YIELD_STRESS_TENSION, 1.559e+6);
-    material_properties.SetValue(FRACTURE_ENERGY_TENSION, 5.0e+3);
-    material_properties.SetValue(DAMAGE_ONSET_STRESS_COMPRESSION, 10.0e+6);
-    material_properties.SetValue(YIELD_STRESS_COMPRESSION, 17.99e+6);
-    material_properties.SetValue(YIELD_STRAIN_COMPRESSION, 0.02);
-    material_properties.SetValue(RESIDUAL_STRESS_COMPRESSION, 2.00e+6);
-    material_properties.SetValue(BIAXIAL_COMPRESSION_MULTIPLIER, 1.20);
-    material_properties.SetValue(FRACTURE_ENERGY_COMPRESSION, 6.0e+5);
-    material_properties.SetValue(SHEAR_COMPRESSION_REDUCTOR, 0.16);
-    material_properties.SetValue(BEZIER_CONTROLLER_C1, 0.65);
-    material_properties.SetValue(BEZIER_CONTROLLER_C2,  0.55);
-    material_properties.SetValue(BEZIER_CONTROLLER_C3, 1.5);
-    material_properties.SetValue(TRIAXIAL_COMPRESSION_COEFFICIENT, 0.66);
-    material_properties.SetValue(DELAY_TIME, 1.0);
-
-    Flags cl_options;
-    cl_options.Set(ConstitutiveLaw::COMPUTE_STRESS, true);
-    cl_options.Set(ConstitutiveLaw::USE_ELEMENT_PROVIDED_STRAIN, true);
-    cl_options.Set(ConstitutiveLaw::COMPUTE_CONSTITUTIVE_TENSOR, false);
-
-    //process_info.SetValue(DELTA_TIME, 0.1);
-
-    cl_parameters.SetElementGeometry(Geom);
-    cl_parameters.SetMaterialProperties(material_properties);
-    cl_parameters.SetStrainVector(strain_vector);
-    cl_parameters.SetStressVector(stress_vector);
-    cl_parameters.SetProcessInfo(process_info);
-    cl_parameters.SetOptions(cl_options);
-    Matrix const_matrix(6,6);
-    cl_parameters.SetConstitutiveMatrix(const_matrix);
-
-    // Create the CL
-    DamageDPlusDMinusMasonry3DLaw masonry3d_cl = DamageDPlusDMinusMasonry3DLaw();
-
-    std::vector<double> masonry3d_res;
-    masonry3d_res = {371694.0,  371694.0, 1.48677e+06, 0.0, 0.0, 0.0};
-
-    Vector test_masonry3d_stress;
-    masonry3d_cl.CalculateMaterialResponseCauchy(cl_parameters);
-    test_masonry3d_stress = cl_parameters.GetStressVector();
-
-    // Check the results
-    for (int comp = 0; comp < 6; comp++) {
-        KRATOS_CHECK_NEAR(test_masonry3d_stress[comp], masonry3d_res[comp], 0.0001e6);
-    }
-}
-
-KRATOS_TEST_CASE_IN_SUITE(DPlusDMinusMasonry3DMixedState, KratosStructuralMechanicsFastSuite)
-{
-    ConstitutiveLaw::Parameters cl_parameters;
-    Properties material_properties;
-    ProcessInfo process_info;
-    Vector stress_vector, strain_vector;
-
-    Model current_model;
-    ModelPart& test_model_part = current_model.CreateModelPart("Main");
-
-    NodeType::Pointer p_node_1 = test_model_part.CreateNewNode(1, 1.0, 0.0, 0.0);
-    NodeType::Pointer p_node_2 = test_model_part.CreateNewNode(2, 0.5, 0.5, 0.0);
-    NodeType::Pointer p_node_3 = test_model_part.CreateNewNode(3, 0.5, 0.1666666667, 0.5);
-    NodeType::Pointer p_node_4 = test_model_part.CreateNewNode(4, 0.0, 0.0, 0.0);
-
-    Tetrahedra3D4<NodeType> Geom = Tetrahedra3D4<NodeType>(p_node_1, p_node_2, p_node_3, p_node_4);
-
-    stress_vector = ZeroVector(6);
-    strain_vector = ZeroVector(6);
-    strain_vector[0] = 0.0;
-    strain_vector[1] = 0.0;
-    strain_vector[2] = 0.0;
-    strain_vector[3] = 0.0;
-    strain_vector[4] = 0.0019998;
-    strain_vector[5] = 0.0019998;
-
-
-    material_properties.SetValue(YOUNG_MODULUS, 3718.0e+6);
-    material_properties.SetValue(POISSON_RATIO, 0.2);
-    material_properties.SetValue(YIELD_STRESS_TENSION, 1.559e+6);
-    material_properties.SetValue(FRACTURE_ENERGY_TENSION, 5.0e+3);
-    material_properties.SetValue(DAMAGE_ONSET_STRESS_COMPRESSION, 10.0e+6);
-    material_properties.SetValue(YIELD_STRESS_COMPRESSION, 17.99e+6);
-    material_properties.SetValue(YIELD_STRAIN_COMPRESSION, 0.02);
-    material_properties.SetValue(RESIDUAL_STRESS_COMPRESSION, 2.00e+6);
-    material_properties.SetValue(BIAXIAL_COMPRESSION_MULTIPLIER, 1.20);
-    material_properties.SetValue(FRACTURE_ENERGY_COMPRESSION, 6.0e+5);
-    material_properties.SetValue(SHEAR_COMPRESSION_REDUCTOR, 0.16);
-    material_properties.SetValue(BEZIER_CONTROLLER_C1, 0.65);
-    material_properties.SetValue(BEZIER_CONTROLLER_C2,  0.55);
-    material_properties.SetValue(BEZIER_CONTROLLER_C3, 1.5);
-    material_properties.SetValue(TRIAXIAL_COMPRESSION_COEFFICIENT, 0.66);
-    material_properties.SetValue(DELAY_TIME, 1.0);
-
-    Flags cl_options;
-    cl_options.Set(ConstitutiveLaw::COMPUTE_STRESS, true);
-    cl_options.Set(ConstitutiveLaw::USE_ELEMENT_PROVIDED_STRAIN, true);
-    cl_options.Set(ConstitutiveLaw::COMPUTE_CONSTITUTIVE_TENSOR, false);
-
-    //process_info.SetValue(DELTA_TIME, 0.1);
-
-    cl_parameters.SetElementGeometry(Geom);
-    cl_parameters.SetMaterialProperties(material_properties);
-    cl_parameters.SetStrainVector(strain_vector);
-    cl_parameters.SetStressVector(stress_vector);
-    cl_parameters.SetProcessInfo(process_info);
-    cl_parameters.SetOptions(cl_options);
-    Matrix const_matrix(6,6);
-    cl_parameters.SetConstitutiveMatrix(const_matrix);
-
-    // Create the CL
-    DamageDPlusDMinusMasonry3DLaw masonry3d_cl = DamageDPlusDMinusMasonry3DLaw();
-
-    std::vector<double> masonry3d_res;
-    masonry3d_res = {-1.16725e+06, -1.79269e-26, -1.16725e+06, -1.44655e-10, 2.55053e+06, 3.71778e+06};
-
-    Vector test_masonry3d_stress;
-    masonry3d_cl.CalculateMaterialResponseCauchy(cl_parameters);
-    test_masonry3d_stress = cl_parameters.GetStressVector();
-
-    // Check the results
-    for (int comp = 0; comp < 6; comp++) {
-        KRATOS_CHECK_NEAR(test_masonry3d_stress[comp], masonry3d_res[comp], 0.0001e6);
-    }
-}
-} // namespace Testing
-} // namespace Kratos
diff --git a/applications/StructuralMechanicsApplication/tests/cpp_tests/test_kinematic_plasticity_constitutive_laws_3d.cpp b/applications/StructuralMechanicsApplication/tests/cpp_tests/test_kinematic_plasticity_constitutive_laws_3d.cpp
deleted file mode 100644
index 2a2197d6ea..0000000000
--- a/applications/StructuralMechanicsApplication/tests/cpp_tests/test_kinematic_plasticity_constitutive_laws_3d.cpp
+++ /dev/null
@@ -1,124 +0,0 @@
-// KRATOS  ___|  |                   |                   |
-//       \___ \  __|  __| |   |  __| __| |   |  __| _` | |
-//             | |   |    |   | (    |   |   | |   (   | |
-//       _____/ \__|_|   \__,_|\___|\__|\__,_|_|  \__,_|_| MECHANICS
-//
-//  License:         BSD License
-//                     license: structural_mechanics_application/license.txt
-//
-//  Main authors:    Alejandro Cornejo
-//
-
-// System includes
-
-// External includes
-
-// Project includes
-#include "includes/process_info.h"
-#include "testing/testing.h"
-#include "containers/model.h"
-
-// Application includes
-
-// Integrator
-#include "custom_constitutive/constitutive_laws_integrators/generic_constitutive_law_integrator_kinematic_plasticity.h"
-
-// Yield surfaces
-#include "custom_constitutive/yield_surfaces/generic_yield_surface.h"
-#include "custom_constitutive/yield_surfaces/von_mises_yield_surface.h"
-
-// Plastic potentials
-#include "custom_constitutive/plastic_potentials/generic_plastic_potential.h"
-#include "custom_constitutive/plastic_potentials/von_mises_plastic_potential.h"
-
-// Constitutive law
-#include "custom_constitutive/generic_small_strain_kinematic_plasticity.h"
-#include "includes/model_part.h"
-#include "geometries/tetrahedra_3d_4.h"
-
-namespace Kratos
-{
-namespace Testing
-{
-// We test the associated plasticity Constitutive laws...
-typedef Node<3> NodeType;
-
-/**
-* Check the correct calculation of the integrated stress with the CL's in small strain
-*/
-KRATOS_TEST_CASE_IN_SUITE(ConstitutiveLawIntegrateStressPlasticitySmallStrainKinematic, KratosStructuralMechanicsFastSuite)
-{
-    typedef GenericSmallStrainKinematicPlasticity <GenericConstitutiveLawIntegratorKinematicPlasticity<VonMisesYieldSurface<VonMisesPlasticPotential<6>>>> VM;
-
-    ConstitutiveLaw::Parameters cl_parameters;
-    Properties material_properties;
-    Vector stress_vector, strain_vector;
-
-    Model current_model;
-    ModelPart& r_test_model_part = current_model.CreateModelPart("Main");
-
-    NodeType::Pointer p_node_1 = r_test_model_part.CreateNewNode(1, 0.0, 0.0, 0.0);
-    NodeType::Pointer p_node_2 = r_test_model_part.CreateNewNode(2, 1.0, 0.0, 0.0);
-    NodeType::Pointer p_node_3 = r_test_model_part.CreateNewNode(3, 0.0, 1.0, 0.0);
-    NodeType::Pointer p_node_4 = r_test_model_part.CreateNewNode(4, 0.0, 0.0, 1.0);
-
-    Tetrahedra3D4<NodeType> Geom = Tetrahedra3D4<NodeType>(p_node_1, p_node_2, p_node_3, p_node_4);
-
-    stress_vector = ZeroVector(6);
-    strain_vector = ZeroVector(6);
-    strain_vector[0] = 0.0;
-    strain_vector[1] = 0.0;
-    strain_vector[2] = -1.1e-04;
-    strain_vector[3] = 0.0;
-    strain_vector[4] = 0.0;
-    strain_vector[5] = 0.0;
-
-    material_properties.SetValue(YOUNG_MODULUS, 206900000000.0);
-    material_properties.SetValue(POISSON_RATIO, 0.29);
-    material_properties.SetValue(YIELD_STRESS, 1.5e6);
-    material_properties.SetValue(FRICTION_ANGLE, 32.0);
-    material_properties.SetValue(DILATANCY_ANGLE, 16.0);
-    material_properties.SetValue(SOFTENING_TYPE, 1);
-    material_properties.SetValue(FRACTURE_ENERGY, 1.5e2);
-    material_properties.SetValue(HARDENING_CURVE, 3);
-    material_properties.SetValue(KINEMATIC_HARDENING_TYPE, 1);
-    Vector kin_hard_parameters = ZeroVector(3);
-    kin_hard_parameters[0] = 15.0e9;
-    material_properties.SetValue(KINEMATIC_PLASTICITY_PARAMETERS, kin_hard_parameters);
-
-    // Set constitutive law flags:
-    Flags& r_constitutive_law_options=cl_parameters.GetOptions();
-    r_constitutive_law_options.Set(ConstitutiveLaw::USE_ELEMENT_PROVIDED_STRAIN, true);
-    r_constitutive_law_options.Set(ConstitutiveLaw::COMPUTE_STRESS, true);
-    r_constitutive_law_options.Set(ConstitutiveLaw::COMPUTE_CONSTITUTIVE_TENSOR, false);
-
-    cl_parameters.SetElementGeometry(Geom);
-    cl_parameters.SetProcessInfo(r_test_model_part.GetProcessInfo());
-    cl_parameters.SetMaterialProperties(material_properties);
-    cl_parameters.SetStrainVector(strain_vector);
-    cl_parameters.SetStressVector(stress_vector);
-    Matrix const_matrix;
-    cl_parameters.SetConstitutiveMatrix(const_matrix);
-
-    // Create the CL
-    VM VonMisesCL = VM();
-    std::vector<double> VMres = {-1.72469e+07,-1.72469e+07,-1.96943e+07,0,0,0};
-
-    double plastic_dissipation;
-    Vector TestMC, TestVM, TestDP, TestT;
-
-    VonMisesCL.CalculateMaterialResponseCauchy(cl_parameters);
-    VonMisesCL.FinalizeMaterialResponseCauchy(cl_parameters);
-    TestVM = cl_parameters.GetStressVector();
-    VonMisesCL.GetValue(PLASTIC_DISSIPATION, plastic_dissipation);
-    KRATOS_WARNING_IF("TestPlasticity", plastic_dissipation < 1.0e-12) << "VonMises:: This test is not in plastic range" << std::endl;
-
-    // Check the results
-    const double tolerance = 1.0e-4;
-    for (std::size_t comp = 0; comp < 6; ++comp){
-        KRATOS_CHECK_LESS_EQUAL(std::abs((VMres[comp] - TestVM[comp]) / VMres[comp]), tolerance);
-    }
-}
-
-} // namespace Testing
-} // namespace Kratos
diff --git a/applications/StructuralMechanicsApplication/tests/cpp_tests/test_prism_neighbours_process.cpp b/applications/StructuralMechanicsApplication/tests/cpp_tests/test_prism_neighbours_process.cpp
index 436981e6b9..f1ab2e0b10 100644
--- a/applications/StructuralMechanicsApplication/tests/cpp_tests/test_prism_neighbours_process.cpp
+++ b/applications/StructuralMechanicsApplication/tests/cpp_tests/test_prism_neighbours_process.cpp
@@ -46,7 +46,7 @@ namespace Kratos
             const std::size_t NumberNeighbours
             )
         {
-            Properties::Pointer p_elem_prop = ThisModelPart.CreateNewProperties(0);
+            Properties::Pointer p_elem_prop = ThisModelPart.pGetProperties(0);
 
             // First we create the nodes
             NodeType::Pointer p_node_1  = ThisModelPart.CreateNewNode( 1,  0.0 ,  0.0 , 0.0);
diff --git a/applications/StructuralMechanicsApplication/tests/cpp_tests/test_shell_to_solid_shell_process.cpp b/applications/StructuralMechanicsApplication/tests/cpp_tests/test_shell_to_solid_shell_process.cpp
index d998bc6b77..7c261b1f5b 100644
--- a/applications/StructuralMechanicsApplication/tests/cpp_tests/test_shell_to_solid_shell_process.cpp
+++ b/applications/StructuralMechanicsApplication/tests/cpp_tests/test_shell_to_solid_shell_process.cpp
@@ -48,7 +48,7 @@ namespace Kratos
 
         void ShellToSolidShellProcessCreateModelPart(ModelPart& ThisModelPart)
         {
-            Properties::Pointer p_elem_prop = ThisModelPart.CreateNewProperties(0);
+            Properties::Pointer p_elem_prop = ThisModelPart.pGetProperties(0);
 
             p_elem_prop->SetValue(THICKNESS, 0.2);
 
diff --git a/applications/StructuralMechanicsApplication/tests/cpp_tests/test_solid_shell_thickness_compute_process.cpp b/applications/StructuralMechanicsApplication/tests/cpp_tests/test_solid_shell_thickness_compute_process.cpp
index 0fe3563a77..258214a3cf 100644
--- a/applications/StructuralMechanicsApplication/tests/cpp_tests/test_solid_shell_thickness_compute_process.cpp
+++ b/applications/StructuralMechanicsApplication/tests/cpp_tests/test_solid_shell_thickness_compute_process.cpp
@@ -31,7 +31,7 @@ namespace Kratos
 
         void SolidShellProcessCreateModelPart(ModelPart& ThisModelPart)
         {
-            Properties::Pointer p_elem_prop = ThisModelPart.CreateNewProperties(0);
+            Properties::Pointer p_elem_prop = ThisModelPart.pGetProperties(0);
 
             // First we create the nodes
             NodeType::Pointer p_node_1 = ThisModelPart.CreateNewNode(1, 0.0 , 0.0 , 0.0);
diff --git a/applications/StructuralMechanicsApplication/tests/cpp_tests/test_solid_static_sensitivity.cpp b/applications/StructuralMechanicsApplication/tests/cpp_tests/test_solid_static_sensitivity.cpp
index a4c2376ce1..dc4706f72b 100644
--- a/applications/StructuralMechanicsApplication/tests/cpp_tests/test_solid_static_sensitivity.cpp
+++ b/applications/StructuralMechanicsApplication/tests/cpp_tests/test_solid_static_sensitivity.cpp
@@ -97,7 +97,8 @@ KRATOS_TEST_CASE_IN_SUITE(TotalLagrangian2D3_StaticSensitivity, KratosStructural
     smtsss::PrimalTestSolver solver{&primal_model_part, response_node_id};
     const double delta = 1e-7;
     const double response_value0 = solver.CalculateResponseValue();
-    ModelPart& adjoint_model_part = CreateStructuralMechanicsAdjointTestModelPart(&primal_model_part);
+    ModelPart& adjoint_model_part =
+        CreateStructuralMechanicsAdjointTestModelPart(&primal_model_part);
     smtsss::AdjointTestSolver adjoint_solver{&adjoint_model_part, response_node_id};
     for (unsigned i_node : {1, 2, 3})
     {
@@ -204,4 +205,4 @@ SolvingStrategyType::Pointer AdjointTestSolver::CreateAdjointSolvingStrategy(
 
 } // namespace smtsss
 } // namespace
-} // namespace Kratos
+} // namespace Kratos
\ No newline at end of file
diff --git a/applications/StructuralMechanicsApplication/tests/cpp_tests/test_solid_transient_sensitivity.cpp b/applications/StructuralMechanicsApplication/tests/cpp_tests/test_solid_transient_sensitivity.cpp
index 857ccfba3a..9dabe2f193 100644
--- a/applications/StructuralMechanicsApplication/tests/cpp_tests/test_solid_transient_sensitivity.cpp
+++ b/applications/StructuralMechanicsApplication/tests/cpp_tests/test_solid_transient_sensitivity.cpp
@@ -68,7 +68,7 @@ struct AdjointTestSolver
 
 namespace Testing
 {
-KRATOS_TEST_CASE_IN_SUITE(TotalLagrangian2D3_TransientSensitivity, KratosStructuralMechanicsFastSuite)
+KRATOS_DISABLED_TEST_CASE_IN_SUITE(TotalLagrangian2D3_TransientSensitivity, KratosStructuralMechanicsFastSuite)
 {
     Model this_model;
     auto model_part_factory = [&this_model]() -> ModelPart& {
@@ -134,7 +134,7 @@ SolvingStrategyType::Pointer CreatePrimalSolvingStrategy(ModelPart* pModelPart)
     SchemeType::Pointer p_scheme =
         Kratos::make_shared<ResidualBasedBossakDisplacementScheme<SparseSpaceType, LocalSpaceType>>(0.0);
     ConvergenceCriteriaType::Pointer p_conv_criteria =
-        Kratos::make_shared<ResidualCriteria<SparseSpaceType, LocalSpaceType>>(1e-12, 1e-14);
+        Kratos::make_shared<ResidualCriteria<SparseSpaceType, LocalSpaceType>>(1e-24, 1e-25);
     return Kratos::make_shared<ResidualBasedNewtonRaphsonStrategy<SparseSpaceType, LocalSpaceType, LinearSolverType>>(
         *pModelPart, p_scheme, p_linear_solver, p_conv_criteria, 30, true, false, true);
 }
diff --git a/applications/StructuralMechanicsApplication/tests/cpp_tests/test_spr_error_process.cpp b/applications/StructuralMechanicsApplication/tests/cpp_tests/test_spr_error_process.cpp
index 51a630b82f..81fb03f5f7 100644
--- a/applications/StructuralMechanicsApplication/tests/cpp_tests/test_spr_error_process.cpp
+++ b/applications/StructuralMechanicsApplication/tests/cpp_tests/test_spr_error_process.cpp
@@ -33,7 +33,7 @@ namespace Kratos
         
         void Create2DGeometry(ModelPart& ThisModelPart, const std::string& ElementName)
         {
-            Properties::Pointer p_elem_prop = ThisModelPart.CreateNewProperties(0);
+            Properties::Pointer p_elem_prop = ThisModelPart.pGetProperties(0);
 
             // First we create the nodes
             NodeType::Pointer p_node_1 = ThisModelPart.CreateNewNode(1, 0.0 , 0.0 , 0.0);
@@ -76,7 +76,7 @@ namespace Kratos
 
         void Create3DGeometry(ModelPart& ThisModelPart, const std::string& ElementName)
         {
-            Properties::Pointer p_elem_prop = ThisModelPart.CreateNewProperties(0);
+            Properties::Pointer p_elem_prop = ThisModelPart.pGetProperties(0);
 
             // First we create the nodes
             NodeType::Pointer p_node_1 = ThisModelPart.CreateNewNode(1 , 0.0 , 1.0 , 1.0);
@@ -209,8 +209,6 @@ namespace Kratos
             process_info[STEP] = 1;
             process_info[NL_ITERATION_NUMBER] = 1;
             
-            Testing::Create2DGeometry(this_model_part, "SmallDisplacementElement2D3N");
-
             // In case the StructuralMechanicsApplciation is not compiled we skip the test
             Properties::Pointer p_elem_prop = this_model_part.pGetProperties(0);
             if (!KratosComponents<ConstitutiveLaw>::Has("LinearElasticPlaneStrain2DLaw"))
@@ -221,6 +219,8 @@ namespace Kratos
             p_elem_prop->SetValue(YOUNG_MODULUS, 1.0);
             p_elem_prop->SetValue(POISSON_RATIO, 0.0);
 
+            Testing::Create2DGeometry(this_model_part, "SmallDisplacementElement2D3N");
+
             for (auto& node : this_model_part.Nodes()) {
                 if (node.X() > 0.9) {
                     node.FastGetSolutionStepValue(DISPLACEMENT_X) += 0.1;
@@ -257,9 +257,7 @@ namespace Kratos
             auto& process_info = this_model_part.GetProcessInfo();
             process_info[STEP] = 1;
             process_info[NL_ITERATION_NUMBER] = 1;
-
-            Testing::Create3DGeometry(this_model_part, "SmallDisplacementElement3D4N");
-
+            
             // In case the StructuralMechanicsApplciation is not compiled we skip the test
             Properties::Pointer p_elem_prop = this_model_part.pGetProperties(0);
             if (!KratosComponents<ConstitutiveLaw>::Has("LinearElastic3DLaw"))
@@ -270,6 +268,8 @@ namespace Kratos
             p_elem_prop->SetValue(YOUNG_MODULUS, 1.0);
             p_elem_prop->SetValue(POISSON_RATIO, 0.0);
 
+            Testing::Create3DGeometry(this_model_part, "SmallDisplacementElement3D4N");
+
             for (auto& node : this_model_part.Nodes()) {
                 if (node.X() > 0.9) {
                     node.FastGetSolutionStepValue(DISPLACEMENT_X) += 0.1;
diff --git a/applications/StructuralMechanicsApplication/tests/cpp_tests/test_tangent_tensor_numerical_derivation_utility.cpp b/applications/StructuralMechanicsApplication/tests/cpp_tests/test_tangent_tensor_numerical_derivation_utility.cpp
index 1af457de4a..770f67e51f 100644
--- a/applications/StructuralMechanicsApplication/tests/cpp_tests/test_tangent_tensor_numerical_derivation_utility.cpp
+++ b/applications/StructuralMechanicsApplication/tests/cpp_tests/test_tangent_tensor_numerical_derivation_utility.cpp
@@ -414,11 +414,11 @@ KRATOS_TEST_CASE_IN_SUITE(LinearElasticCasePertubationTensorUtility, KratosStruc
     ModelPart& r_model_part = this_model.CreateModelPart("Main");
 
     ConstitutiveLaw::Parameters cl_configuration_values;
-    Properties::Pointer p_material_properties = r_model_part.CreateNewProperties(1);
+    Properties material_properties = r_model_part.GetProperties(1);
     Vector stress_vector, strain_vector;
     Matrix tangent_moduli, deformation_gradient_F;
     double det_deformation_gradient_F;
-    SettingBasicCase(r_model_part, cl_configuration_values, *p_material_properties, stress_vector, strain_vector, tangent_moduli, deformation_gradient_F, det_deformation_gradient_F);
+    SettingBasicCase(r_model_part, cl_configuration_values, material_properties, stress_vector, strain_vector, tangent_moduli, deformation_gradient_F, det_deformation_gradient_F);
 
     auto p_constitutive_law = KratosComponents<ConstitutiveLaw>().Get("LinearElastic3DLaw").Clone();
     p_constitutive_law->CalculateMaterialResponse(cl_configuration_values, ConstitutiveLaw::StressMeasure::StressMeasure_Cauchy);
@@ -449,11 +449,11 @@ KRATOS_TEST_CASE_IN_SUITE(HyperElasticCasePertubationTensorUtility, KratosStruct
     ModelPart& r_model_part = this_model.CreateModelPart("Main");
 
     ConstitutiveLaw::Parameters cl_configuration_values;
-    Properties::Pointer p_material_properties = r_model_part.CreateNewProperties(1);
+    Properties material_properties = r_model_part.GetProperties(1);
     Vector stress_vector, strain_vector;
     Matrix tangent_moduli, deformation_gradient_F;
     double det_deformation_gradient_F;
-    SettingBasicCase(r_model_part, cl_configuration_values, *p_material_properties, stress_vector, strain_vector, tangent_moduli, deformation_gradient_F, det_deformation_gradient_F, false);
+    SettingBasicCase(r_model_part, cl_configuration_values, material_properties, stress_vector, strain_vector, tangent_moduli, deformation_gradient_F, det_deformation_gradient_F, false);
 
     auto p_constitutive_law = KratosComponents<ConstitutiveLaw>().Get("KirchhoffSaintVenant3DLaw").Clone();
     p_constitutive_law->CalculateMaterialResponse(cl_configuration_values, ConstitutiveLaw::StressMeasure::StressMeasure_PK2);
@@ -484,11 +484,11 @@ KRATOS_TEST_CASE_IN_SUITE(QuadraticLinearElasticCasePertubationTensorUtility, Kr
     ModelPart& r_model_part = this_model.CreateModelPart("Main");
 
     ConstitutiveLaw::Parameters cl_configuration_values;
-    Properties::Pointer p_material_properties = r_model_part.CreateNewProperties(1);
+    Properties material_properties = r_model_part.GetProperties(1);
     Vector stress_vector, strain_vector;
     Matrix tangent_moduli, deformation_gradient_F;
     double det_deformation_gradient_F;
-    SettingBasicCase(r_model_part, cl_configuration_values, *p_material_properties, stress_vector, strain_vector, tangent_moduli, deformation_gradient_F, det_deformation_gradient_F);
+    SettingBasicCase(r_model_part, cl_configuration_values, material_properties, stress_vector, strain_vector, tangent_moduli, deformation_gradient_F, det_deformation_gradient_F);
 
     auto p_constitutive_law = KratosComponents<ConstitutiveLaw>().Get("LinearElastic3DLaw").Clone();
     p_constitutive_law->CalculateMaterialResponse(cl_configuration_values, ConstitutiveLaw::StressMeasure::StressMeasure_PK2);
@@ -505,11 +505,11 @@ KRATOS_TEST_CASE_IN_SUITE(QuadraticKirchhoffHyperElasticCasePertubationTensorUti
     ModelPart& r_model_part = this_model.CreateModelPart("Main");
 
     ConstitutiveLaw::Parameters cl_configuration_values;
-    Properties::Pointer p_material_properties = r_model_part.CreateNewProperties(1);
+    Properties material_properties = r_model_part.GetProperties(1);
     Vector stress_vector, strain_vector;
     Matrix tangent_moduli, deformation_gradient_F;
     double det_deformation_gradient_F;
-    SettingBasicCase(r_model_part, cl_configuration_values, *p_material_properties, stress_vector, strain_vector, tangent_moduli, deformation_gradient_F, det_deformation_gradient_F, false);
+    SettingBasicCase(r_model_part, cl_configuration_values, material_properties, stress_vector, strain_vector, tangent_moduli, deformation_gradient_F, det_deformation_gradient_F, false);
 
     auto p_constitutive_law = KratosComponents<ConstitutiveLaw>().Get("KirchhoffSaintVenant3DLaw").Clone();
     p_constitutive_law->CalculateMaterialResponse(cl_configuration_values, ConstitutiveLaw::StressMeasure::StressMeasure_PK2);
@@ -528,15 +528,15 @@ KRATOS_TEST_CASE_IN_SUITE(QuadraticSmallStrainIsotropicPlasticity3DVonMisesVonMi
     r_model_part.AddNodalSolutionStepVariable(DISPLACEMENT);
 
     ConstitutiveLaw::Parameters cl_configuration_values;
-    Properties::Pointer p_material_properties = r_model_part.CreateNewProperties(1);
+    Properties& r_material_properties = r_model_part.GetProperties(1);
     Vector stress_vector, strain_vector;
     Matrix tangent_moduli, deformation_gradient_F;
     double det_deformation_gradient_F;
-    SettingBasicCase(r_model_part, cl_configuration_values, *p_material_properties, stress_vector, strain_vector, tangent_moduli, deformation_gradient_F, det_deformation_gradient_F, true, 2);
+    SettingBasicCase(r_model_part, cl_configuration_values, r_material_properties, stress_vector, strain_vector, tangent_moduli, deformation_gradient_F, det_deformation_gradient_F, true, 2);
 
     // Creating constitutive law
     auto p_constitutive_law = KratosComponents<ConstitutiveLaw>().Get("SmallStrainIsotropicPlasticity3DVonMisesVonMises").Clone();
-    p_material_properties->SetValue(CONSTITUTIVE_LAW, p_constitutive_law);
+    r_material_properties.SetValue(CONSTITUTIVE_LAW, p_constitutive_law);
 
     // Creating geometry
     Create3DGeometryHexahedra(r_model_part);
@@ -564,15 +564,15 @@ KRATOS_TEST_CASE_IN_SUITE(QuadraticSmallStrainIsotropicPlasticity3DVonMisesVonMi
     r_model_part.AddNodalSolutionStepVariable(DISPLACEMENT);
 
     ConstitutiveLaw::Parameters cl_configuration_values;
-    Properties::Pointer p_material_properties = r_model_part.CreateNewProperties(1);
+    Properties& r_material_properties = r_model_part.GetProperties(1);
     Vector stress_vector, strain_vector;
     Matrix tangent_moduli, deformation_gradient_F;
     double det_deformation_gradient_F;
-    SettingBasicCase(r_model_part, cl_configuration_values, *p_material_properties, stress_vector, strain_vector, tangent_moduli, deformation_gradient_F, det_deformation_gradient_F, true, 2);
+    SettingBasicCase(r_model_part, cl_configuration_values, r_material_properties, stress_vector, strain_vector, tangent_moduli, deformation_gradient_F, det_deformation_gradient_F, true, 2);
 
     // Creating constitutive law
     auto p_constitutive_law = KratosComponents<ConstitutiveLaw>().Get("SmallStrainIsotropicPlasticity3DVonMisesVonMises").Clone();
-    p_material_properties->SetValue(CONSTITUTIVE_LAW, p_constitutive_law);
+    r_material_properties.SetValue(CONSTITUTIVE_LAW, p_constitutive_law);
 
     // Creating geometry
     Create3DGeometryHexahedra(r_model_part);
diff --git a/applications/StructuralMechanicsApplication/tests/cpp_tests/test_total_lagrangian_element_matrices.cpp b/applications/StructuralMechanicsApplication/tests/cpp_tests/test_total_lagrangian_element_matrices.cpp
index 8ce8ff493f..01ae249f77 100644
--- a/applications/StructuralMechanicsApplication/tests/cpp_tests/test_total_lagrangian_element_matrices.cpp
+++ b/applications/StructuralMechanicsApplication/tests/cpp_tests/test_total_lagrangian_element_matrices.cpp
@@ -124,7 +124,7 @@ void CreateTotalLagrangianTestModelPart(std::string const& rElementName, ModelPa
     std::vector<ModelPart::IndexType> node_ids(r_elem.GetGeometry().PointsNumber());
     for (std::size_t i = 0; i < r_elem.GetGeometry().PointsNumber(); ++i)
         node_ids.at(i) = i + 1;
-    auto p_prop = rModelPart.CreateNewProperties(1);
+    auto p_prop = rModelPart.pGetProperties(1);
     rModelPart.CreateNewElement(rElementName, 1, node_ids, p_prop);
     rModelPart.SetBufferSize(2);
     for (auto& r_node : rModelPart.Nodes())
diff --git a/applications/StructuralMechanicsApplication/tests/mesh_moving_test/simple_mesh_moving_test.mdpa b/applications/StructuralMechanicsApplication/tests/mesh_moving_test/simple_mesh_moving_test.mdpa
index 7330873a76..161a12c1fd 100644
--- a/applications/StructuralMechanicsApplication/tests/mesh_moving_test/simple_mesh_moving_test.mdpa
+++ b/applications/StructuralMechanicsApplication/tests/mesh_moving_test/simple_mesh_moving_test.mdpa
@@ -4,6 +4,8 @@ End ModelPartData
 
 Begin Properties 0
 End Properties
+Begin Properties 1
+End Properties
 
 Begin Nodes
     1        0.00000        1.00000        0.00000
@@ -18,10 +20,10 @@ Begin Nodes
 End Nodes
 
 Begin Elements TotalLagrangianElement2D4N
-         1          0          8          7          4          5
-         2          0          9          8          5          6
-         3          0          2          3          6          5
-         4          0          2          5          4          1
+         1          1          8          7          4          5
+         2          1          9          8          5          6
+         3          1          2          3          6          5
+         4          1          2          5          4          1
 End Elements
 
 Begin SubModelPart Parts_All// Group plate // Subtree Parts
diff --git a/applications/StructuralMechanicsApplication/tests/rayleigh_process_test/test_rayleigh_parameters.json b/applications/StructuralMechanicsApplication/tests/rayleigh_process_test/test_rayleigh_parameters.json
index 9b53f8adbf..7df5eabf3e 100755
--- a/applications/StructuralMechanicsApplication/tests/rayleigh_process_test/test_rayleigh_parameters.json
+++ b/applications/StructuralMechanicsApplication/tests/rayleigh_process_test/test_rayleigh_parameters.json
@@ -2,7 +2,7 @@
     "problem_data"     : {
         "problem_name"  : "test_rayleigh",
         "parallel_type" : "OpenMP",
-        "echo_level"    : 0,
+        "echo_level"    : 1,
         "start_time"    : 0.0,
         "end_time"      : 0.01
     },
@@ -32,7 +32,7 @@
         "residual_absolute_tolerance"        : 1e-9,
         "max_iteration"                      : 10,
         "problem_domain_sub_model_part_list" : ["Parts_Parts_Auto1"],
-        "processes_sub_model_part_list"      : ["DISPLACEMENT_Displacement_Auto1","SelfWeight2D_Self_weight_Auto1", "Structure"],
+        "processes_sub_model_part_list"      : ["DISPLACEMENT_Displacement_Auto1","SelfWeight2D_Self_weight_Auto1"],
         "rotation_dofs"                      : false
     },
     "processes"        : {
diff --git a/applications/StructuralMechanicsApplication/tests/rigid_test/test_block_mpc_parameters.json b/applications/StructuralMechanicsApplication/tests/rigid_test/test_block_mpc_parameters.json
index 8c89da75de..9dc886775e 100755
--- a/applications/StructuralMechanicsApplication/tests/rigid_test/test_block_mpc_parameters.json
+++ b/applications/StructuralMechanicsApplication/tests/rigid_test/test_block_mpc_parameters.json
@@ -31,7 +31,7 @@
         "residual_absolute_tolerance"        : 1e-9,
         "max_iteration"                      : 10,
         "problem_domain_sub_model_part_list" : ["Parts_Parts_Auto1"],
-        "processes_sub_model_part_list"      : ["DISPLACEMENT_Displacement_Auto2", "GENERIC_Add_SubModelPart_Auto1"],
+        "processes_sub_model_part_list"      : ["DISPLACEMENT_Displacement_Auto2"],
         "rotation_dofs"                      : false
     },
     "processes"        : {
diff --git a/applications/StructuralMechanicsApplication/tests/rigid_test/test_elimination_mpc_parameters.json b/applications/StructuralMechanicsApplication/tests/rigid_test/test_elimination_mpc_parameters.json
index 1330395bf5..3af5a64ca9 100755
--- a/applications/StructuralMechanicsApplication/tests/rigid_test/test_elimination_mpc_parameters.json
+++ b/applications/StructuralMechanicsApplication/tests/rigid_test/test_elimination_mpc_parameters.json
@@ -31,7 +31,7 @@
         "residual_absolute_tolerance"        : 1e-9,
         "max_iteration"                      : 10,
         "problem_domain_sub_model_part_list" : ["Parts_Parts_Auto1"],
-        "processes_sub_model_part_list"      : ["DISPLACEMENT_Displacement_Auto2", "GENERIC_Add_SubModelPart_Auto1"],
+        "processes_sub_model_part_list"      : ["DISPLACEMENT_Displacement_Auto2"],
         "rotation_dofs"                      : false
     },
     "processes"        : {
diff --git a/applications/StructuralMechanicsApplication/tests/rve_test/smallest_rve_test.mdpa b/applications/StructuralMechanicsApplication/tests/rve_test/smallest_rve_test.mdpa
deleted file mode 100644
index d02a017d45..0000000000
--- a/applications/StructuralMechanicsApplication/tests/rve_test/smallest_rve_test.mdpa
+++ /dev/null
@@ -1,610 +0,0 @@
-Begin ModelPartData
-//  VARIABLE_NAME value
-End ModelPartData
-
-Begin Properties 0
-End Properties
-Begin Nodes
-    1  -0.7071067812  -0.7071067812   1.0000000000
-    2  -0.7071067812  -0.2357022604   1.0000000000
-    3  -0.2357022604  -0.7071067812   1.0000000000
-    4  -0.7071067812  -0.7071067812   0.5000000000
-    5  -0.2146867282  -0.1554551834   0.6680018479
-    6  -0.7071067812   0.0000000000   0.5669872981
-    7   0.0000000000  -0.7071067812   0.5669872981
-    8  -0.2740940793  -0.0000000000   1.0000000000
-    9  -0.2907096381  -0.4476661842   0.2980875789
-   10   0.0366110126  -0.2699803041   1.0000000000
-   11  -0.7071067812   0.2357022604   1.0000000000
-   12   0.2357022604  -0.7071067812   1.0000000000
-   13  -0.7071067812  -0.7071067812   0.0000000000
-   14   0.0548863115   0.0400783868   0.7247641248
-   15  -0.7071067812  -0.2357022604   0.0000000000
-   16  -0.2357022604  -0.7071067812   0.0000000000
-   17  -0.2707661082   0.1674484160   0.3988068501
-   18   0.3428987960  -0.3468033165   0.6791327011
-   19   0.3299831646  -0.1414213562   1.0000000000
-   20   0.1271659777   0.2057333979   1.0000000000
-   21  -0.2179948211   0.3729959054   0.6369647559
-   22   0.1520723948   0.0311980207   0.3650679501
-   23  -0.2740940793  -0.0000000000   0.0000000000
-   24   0.3539851244  -0.3652450475   0.3035546737
-   25   0.0366110126  -0.2699803041   0.0000000000
-   26  -0.7071067812   0.2357022604   0.0000000000
-   27   0.2357022604  -0.7071067812   0.0000000000
-   28  -0.4053904292   0.5183630981   0.3789966115
-   29  -0.7071067812   0.7071067812   1.0000000000
-   30   0.7071067812  -0.7071067812   1.0000000000
-   31  -0.2357022604   0.7071067812   1.0000000000
-   32   0.7071067812  -0.2357022604   1.0000000000
-   33  -0.7071067812   0.7071067812   0.5000000000
-   34   0.7071067812  -0.7071067812   0.5000000000
-   35   0.0300628587   0.4294817421   0.3189346214
-   36   0.3236912739   0.3671459506   0.6299826832
-   37   0.3299831646  -0.1414213562   0.0000000000
-   38   0.1271659777   0.2057333979   0.0000000000
-   39   0.7071067812   0.0000000000   0.5669872981
-   40   0.0000000000   0.7071067812   0.5669872981
-   41   0.7071067812   0.2357022604   1.0000000000
-   42   0.2357022604   0.7071067812   1.0000000000
-   43   0.4099045831   0.3743992117   0.2498083941
-   44  -0.7071067812   0.7071067812   0.0000000000
-   45   0.7071067812  -0.7071067812   0.0000000000
-   46  -0.2357022604   0.7071067812   0.0000000000
-   47   0.7071067812  -0.2357022604   0.0000000000
-   48   0.7071067812   0.2357022604   0.0000000000
-   49   0.2357022604   0.7071067812   0.0000000000
-   50   0.7071067812   0.7071067812   1.0000000000
-   51   0.7071067812   0.7071067812   0.5000000000
-   52   0.7071067812   0.7071067812   0.0000000000
-End Nodes
-
-
-Begin Elements SmallDisplacementElement3D4N// GUI group identifier: Parts Auto1
-        1          0         37         38         25         22 
-        2          0         25         37         22         24 
-        3          0         25         37         24         27 
-        4          0         19         10         20         14 
-        5          0         19         10         14         18 
-        6          0         19         10         18         12 
-        7          0         24         25         27          7 
-        8          0         10         18         12          7 
-        9          0         37         38         22         48 
-       10          0         20         19         14         41 
-       11          0         18         12          7         34 
-       12          0         37         22         24         39 
-       13          0         14         19         18         39 
-       14          0         22         25         24          7 
-       15          0         10         14         18          7 
-       16          0         37         24         27         47 
-       17          0         37         24         47         39 
-       18          0         18         19         12         32 
-       19          0         18         19         32         39 
-       20          0          8         20         10         14 
-       21          0         23         25         38         22 
-       22          0         47         48         37         39 
-       23          0         32         19         41         39 
-       24          0         10          8         14          5 
-       25          0         10          8          5          3 
-       26          0         14         10          5          7 
-       27          0         23         25         22          9 
-       28          0         23         25          9         16 
-       29          0         25         22          9          7 
-       30          0          5         10          3          7 
-       31          0          3          5          7          4 
-       32          0         25          9         16         27 
-       33          0         26         15         23          6 
-       34          0         12          7          3         10 
-       35          0         31         40         42         20 
-       36          0         11          8          2          6 
-       37          0         27         24          7         34 
-       38          0          8         20         14         21 
-       39          0          8         20         21         31 
-       40          0         20         14         21         36 
-       41          0         21         20         36         40 
-       42          0         36         21         40         35 
-       43          0         21         40         35         28 
-       44          0         21         40         28         33 
-       45          0         35         21         28         17 
-       46          0         21         28         17          6 
-       47          0         35         21         17         22 
-       48          0         40         35         28         46 
-       49          0         20         14         36         41 
-       50          0         28         35         17         46 
-       51          0         36         21         35         22 
-       52          0         40         36         35         49 
-       53          0         14         21         36         22 
-       54          0         36         14         22         39 
-       55          0         14         21         22          5 
-       56          0         22         14          5          7 
-       57          0         14         22         39         18 
-       58          0         14         22         18          7 
-       59          0         17         35         22         38 
-       60          0         35         22         38         43 
-       61          0         38         35         43         49 
-       62          0         38         35         49         46 
-       63          0         17         35         38         46 
-       64          0         22         38         43         48 
-       65          0         38         43         48         49 
-       66          0         35         22         43         36 
-       67          0         43         35         36         49 
-       68          0         35         49         46         40 
-       69          0         22         43         36         39 
-       70          0         43         36         39         51 
-       71          0         38         23         22         17 
-       72          0         38         23         17         46 
-       73          0         23         22         17          9 
-       74          0         17         23          9          6 
-       75          0         22         17          9          5 
-       76          0         17          9          5          6 
-       77          0          9         22          5          7 
-       78          0          5          9          7          4 
-       79          0         28         40         46         33 
-       80          0         46         28         33         26 
-       81          0         43         36         51         49 
-       82          0         17         23          6         26 
-       83          0         17         23         26         46 
-       84          0         21         17         22          5 
-       85          0          8         14          5         21 
-       86          0         43         22         48         39 
-       87          0         48         43         39         51 
-       88          0         24         27         47         45 
-       89          0         24         27         45         34 
-       90          0         47         24         45         34 
-       91          0         12         18         32         30 
-       92          0         12         18         30         34 
-       93          0         18         32         30         34 
-       94          0         21         20         40         31 
-       95          0         40         21         31         33 
-       96          0         14         19         39         41 
-       97          0         36         14         39         41 
-       98          0         17         28         46         26 
-       99          0         43         48         49         52 
-      100          0         43         48         52         51 
-      101          0         17         28         26          6 
-      102          0         28         21         33          6 
-      103          0         49         43         52         51 
-      104          0         39         36         41         51 
-      105          0         25          9         27          7 
-      106          0         36         20         41         42 
-      107          0         36         20         42         40 
-      108          0         42         36         40         51 
-      109          0          9          5          6          4 
-      110          0         11          8          6         21 
-      111          0          8          2          6          5 
-      112          0          8          2          5          3 
-      113          0         17         21          6          5 
-      114          0         29         31         11         33 
-      115          0         44         26         46         33 
-      116          0         15         13         16          4 
-      117          0          2          3          1          4 
-      118          0         41         42         50         36 
-      119          0         42         50         36         51 
-      120          0          9         16         27          7 
-      121          0          9         16          7          4 
-      122          0          5          8         21          6 
-      123          0         24         22          7         18 
-      124          0          7         24         18         34 
-      125          0         24         18         34         39 
-      126          0         24         22         18         39 
-      127          0         11          8         21         31 
-      128          0         50         41         36         51 
-      129          0         22         37         48         39 
-      130          0         32         18         39         34 
-      131          0          9         23         16         15 
-      132          0          9         23         15          6 
-      133          0         28         33         26          6 
-      134          0          2          6          5          4 
-      135          0         36         40         51         49 
-      136          0         47         24         34         39 
-      137          0          2          5          3          4 
-      138          0         16          9         15          4 
-      139          0          6         11         21         33 
-      140          0         15          9          6          4 
-      141          0         21         11         31         33 
-End Elements
-
-Begin Conditions SurfaceLoadCondition3D3N// GUI group identifier: Pressure on surfaces Auto2
-    1 0 44 26 46
-    2 0 16 27 25
-    3 0 48 52 49
-    4 0 15 13 16
-    5 0 45 47 27
-    6 0 49 46 38
-    7 0 26 15 23
-    8 0 47 48 37
-    9 0 25 27 37
-    10 0 38 46 23
-    11 0 23 15 16
-    12 0 37 48 38
-    13 0 16 25 23
-    14 0 23 25 38
-    15 0 23 46 26
-    16 0 49 38 48
-    17 0 37 38 25
-    18 0 37 27 47
-    19 0 44 26 33
-    20 0 15 13 4
-    21 0 2 11 6
-    22 0 26 15 6
-    23 0 1 2 4
-    24 0 11 29 33
-    25 0 6 11 33
-    26 0 2 6 4
-    27 0 6 15 4
-    28 0 26 6 33
-    29 0 13 16 4
-    30 0 27 45 34
-    31 0 12 3 7
-    32 0 16 27 7
-    33 0 30 12 34
-    34 0 3 1 4
-    35 0 7 3 4
-    36 0 12 7 34
-    37 0 7 27 34
-    38 0 16 7 4
-    39 0 45 47 34
-    40 0 48 52 51
-    41 0 41 32 39
-    42 0 47 48 39
-    43 0 50 41 51
-    44 0 32 30 34
-    45 0 39 32 34
-    46 0 41 39 51
-    47 0 39 48 51
-    48 0 47 39 34
-    49 0 52 49 51
-    50 0 46 44 33
-    51 0 31 42 40
-    52 0 49 46 40
-    53 0 29 31 33
-    54 0 42 50 51
-    55 0 40 42 51
-    56 0 31 40 33
-    57 0 40 46 33
-    58 0 49 40 51
-    59 0 29 11 31
-    60 0 3 12 10
-    61 0 41 50 42
-    62 0 2 1 3
-    63 0 30 32 12
-    64 0 42 31 20
-    65 0 11 2 8
-    66 0 32 41 19
-    67 0 10 12 19
-    68 0 20 31 8
-    69 0 8 2 3
-    70 0 19 41 20
-    71 0 3 10 8
-    72 0 8 10 20
-    73 0 8 31 11
-    74 0 42 20 41
-    75 0 19 20 10
-    76 0 19 12 32
-End Conditions
-
-Begin SubModelPart Parts_Parts_Auto1 // Group Parts Auto1 // Subtree Parts
-    Begin SubModelPartNodes
-            1
-            2
-            3
-            4
-            5
-            6
-            7
-            8
-            9
-           10
-           11
-           12
-           13
-           14
-           15
-           16
-           17
-           18
-           19
-           20
-           21
-           22
-           23
-           24
-           25
-           26
-           27
-           28
-           29
-           30
-           31
-           32
-           33
-           34
-           35
-           36
-           37
-           38
-           39
-           40
-           41
-           42
-           43
-           44
-           45
-           46
-           47
-           48
-           49
-           50
-           51
-           52
-    End SubModelPartNodes
-    Begin SubModelPartElements
-            1
-            2
-            3
-            4
-            5
-            6
-            7
-            8
-            9
-           10
-           11
-           12
-           13
-           14
-           15
-           16
-           17
-           18
-           19
-           20
-           21
-           22
-           23
-           24
-           25
-           26
-           27
-           28
-           29
-           30
-           31
-           32
-           33
-           34
-           35
-           36
-           37
-           38
-           39
-           40
-           41
-           42
-           43
-           44
-           45
-           46
-           47
-           48
-           49
-           50
-           51
-           52
-           53
-           54
-           55
-           56
-           57
-           58
-           59
-           60
-           61
-           62
-           63
-           64
-           65
-           66
-           67
-           68
-           69
-           70
-           71
-           72
-           73
-           74
-           75
-           76
-           77
-           78
-           79
-           80
-           81
-           82
-           83
-           84
-           85
-           86
-           87
-           88
-           89
-           90
-           91
-           92
-           93
-           94
-           95
-           96
-           97
-           98
-           99
-          100
-          101
-          102
-          103
-          104
-          105
-          106
-          107
-          108
-          109
-          110
-          111
-          112
-          113
-          114
-          115
-          116
-          117
-          118
-          119
-          120
-          121
-          122
-          123
-          124
-          125
-          126
-          127
-          128
-          129
-          130
-          131
-          132
-          133
-          134
-          135
-          136
-          137
-          138
-          139
-          140
-          141
-    End SubModelPartElements
-    Begin SubModelPartConditions
-    End SubModelPartConditions
-End SubModelPart
-Begin SubModelPart SurfacePressure3D_Pressure_on_surfaces_Auto2 // Group Pressure on surfaces Auto2 // Subtree SurfacePressure3D
-    Begin SubModelPartNodes
-            1
-            2
-            3
-            4
-            6
-            7
-            8
-           10
-           11
-           12
-           13
-           15
-           16
-           19
-           20
-           23
-           25
-           26
-           27
-           29
-           30
-           31
-           32
-           33
-           34
-           37
-           38
-           39
-           40
-           41
-           42
-           44
-           45
-           46
-           47
-           48
-           49
-           50
-           51
-           52
-    End SubModelPartNodes
-    Begin SubModelPartElements
-    End SubModelPartElements
-    Begin SubModelPartConditions
-            1
-            2
-            3
-            4
-            5
-            6
-            7
-            8
-            9
-           10
-           11
-           12
-           13
-           14
-           15
-           16
-           17
-           18
-           19
-           20
-           21
-           22
-           23
-           24
-           25
-           26
-           27
-           28
-           29
-           30
-           31
-           32
-           33
-           34
-           35
-           36
-           37
-           38
-           39
-           40
-           41
-           42
-           43
-           44
-           45
-           46
-           47
-           48
-           49
-           50
-           51
-           52
-           53
-           54
-           55
-           56
-           57
-           58
-           59
-           60
-           61
-           62
-           63
-           64
-           65
-           66
-           67
-           68
-           69
-           70
-           71
-           72
-           73
-           74
-           75
-           76
-    End SubModelPartConditions
-End SubModelPart
diff --git a/applications/StructuralMechanicsApplication/tests/rve_test/smallest_rve_test_materials.json b/applications/StructuralMechanicsApplication/tests/rve_test/smallest_rve_test_materials.json
deleted file mode 100644
index 04860dbfb0..0000000000
--- a/applications/StructuralMechanicsApplication/tests/rve_test/smallest_rve_test_materials.json
+++ /dev/null
@@ -1,17 +0,0 @@
-{
-    "properties" : [{
-        "model_part_name" : "Structure.Parts_Parts_Auto1",
-        "properties_id"   : 1,
-        "Material"        : {
-            "constitutive_law" : {
-                "name" : "LinearElastic3DLaw"
-            },
-            "Variables"        : {
-                "DENSITY"       : 0.0,
-                "YOUNG_MODULUS" : 1000000.0,
-                "POISSON_RATIO" : 0.3
-            },
-            "Tables"           : {}
-        }
-    }]
-}
diff --git a/applications/StructuralMechanicsApplication/tests/rve_test/smallest_rve_test_parameters.json b/applications/StructuralMechanicsApplication/tests/rve_test/smallest_rve_test_parameters.json
deleted file mode 100644
index 24164dcf09..0000000000
--- a/applications/StructuralMechanicsApplication/tests/rve_test/smallest_rve_test_parameters.json
+++ /dev/null
@@ -1,37 +0,0 @@
-{
-    "problem_data"     : {
-        "problem_name"  : "smallest_rve_test",
-        "parallel_type" : "OpenMP",
-        "echo_level"    : 0,
-        "start_time"    : 0.0,
-        "end_time"      : 1.0
-    },
-    "rve_settings"     : {
-        "boundary_mp_name"  : "Structure.SurfacePressure3D_Pressure_on_surfaces_Auto2",
-        "averaging_mp_name" : "Structure.computing_domain",
-        "print_rve_post"    : false,
-        "perturbation"      : 1e-6
-    },
-    "solver_settings"  : {
-        "solver_type"                        : "static",
-        "model_part_name"                    : "Structure",
-        "block_builder"                      : true,
-        "multi_point_constraints_used"       : true,
-        "domain_size"                        : 3,
-        "echo_level"                         : 0,
-        "analysis_type"                      : "linear",
-        "model_import_settings"              : {
-            "input_type"     : "mdpa",
-            "input_filename" : "rve_test/smallest_rve_test"
-        },
-        "material_import_settings"           : {
-            "materials_filename" : "rve_test/smallest_rve_test_materials.json"
-        },
-        "time_stepping"                      : {
-            "time_step" : 1.1
-        },
-        "problem_domain_sub_model_part_list" : ["Parts_Parts_Auto1"],
-        "processes_sub_model_part_list"      : ["SurfacePressure3D_Pressure_on_surfaces_Auto2"]
-    },
-    "output_processes" : { }
-}
diff --git a/applications/StructuralMechanicsApplication/tests/shell_test/Shell_T3andQ4_linear_static_struct_scordelis_lo_roof_parameters.json b/applications/StructuralMechanicsApplication/tests/shell_test/Shell_T3andQ4_linear_static_struct_scordelis_lo_roof_parameters.json
index 07e9f3a1e0..d960cfb029 100644
--- a/applications/StructuralMechanicsApplication/tests/shell_test/Shell_T3andQ4_linear_static_struct_scordelis_lo_roof_parameters.json
+++ b/applications/StructuralMechanicsApplication/tests/shell_test/Shell_T3andQ4_linear_static_struct_scordelis_lo_roof_parameters.json
@@ -4,7 +4,7 @@
         "parallel_type"   : "OpenMP",
         "start_time"      : 0.0,
         "end_time"        : 1.0,
-        "echo_level"      : 0
+        "echo_level"      : 1
     },
     "solver_settings"          : {
         "solver_type"                        : "Static",
diff --git a/applications/StructuralMechanicsApplication/tests/shell_test/Shell_T3andQ4_linear_static_unstruct_scordelis_lo_roof_parameters.json b/applications/StructuralMechanicsApplication/tests/shell_test/Shell_T3andQ4_linear_static_unstruct_scordelis_lo_roof_parameters.json
index 36c1181b9f..534df16aa5 100644
--- a/applications/StructuralMechanicsApplication/tests/shell_test/Shell_T3andQ4_linear_static_unstruct_scordelis_lo_roof_parameters.json
+++ b/applications/StructuralMechanicsApplication/tests/shell_test/Shell_T3andQ4_linear_static_unstruct_scordelis_lo_roof_parameters.json
@@ -4,7 +4,7 @@
         "parallel_type"   : "OpenMP",
         "start_time"      : 0.0,
         "end_time"        : 1.0,
-        "echo_level"      : 0
+        "echo_level"      : 1
     },
     "solver_settings"          : {
         "solver_type"                        : "Static",
diff --git a/applications/StructuralMechanicsApplication/tests/structural_mechanics_test_factory.py b/applications/StructuralMechanicsApplication/tests/structural_mechanics_test_factory.py
index 9ac0f033e4..c3861a6807 100644
--- a/applications/StructuralMechanicsApplication/tests/structural_mechanics_test_factory.py
+++ b/applications/StructuralMechanicsApplication/tests/structural_mechanics_test_factory.py
@@ -7,10 +7,29 @@ from KratosMultiphysics.StructuralMechanicsApplication.structural_mechanics_anal
 # Import KratosUnittest
 import KratosMultiphysics.KratosUnittest as KratosUnittest
 
+# Other imports
+import os
+
+# This utility will control the execution scope in case we need to access files or we depend
+# on specific relative locations of the files.
+
+# TODO: Should we move this to KratosUnittest?
+class controlledExecutionScope:
+    def __init__(self, scope):
+        self.currentPath = os.getcwd()
+        self.scope = scope
+
+    def __enter__(self):
+        os.chdir(self.scope)
+
+    def __exit__(self, type, value, traceback):
+        os.chdir(self.currentPath)
+
+
 class StructuralMechanicsTestFactory(KratosUnittest.TestCase):
     def setUp(self):
         # Within this location context:
-        with KratosUnittest.WorkFolderScope(".", __file__):
+        with controlledExecutionScope(os.path.dirname(os.path.realpath(__file__))):
 
             # Reading the ProjectParameters
             with open(self.file_name + "_parameters.json",'r') as parameter_file:
@@ -21,7 +40,7 @@ class StructuralMechanicsTestFactory(KratosUnittest.TestCase):
             # the previous default linear-solver is set
             if not ProjectParameters["solver_settings"].Has("linear_solver_settings"):
                 default_lin_solver_settings = KratosMultiphysics.Parameters("""{
-                    "solver_type": "ExternalSolversApplication.super_lu",
+                "solver_type": "ExternalSolversApplication.super_lu",
                     "max_iteration": 500,
                     "tolerance": 1e-9,
                     "scaling": false,
@@ -33,10 +52,8 @@ class StructuralMechanicsTestFactory(KratosUnittest.TestCase):
             self.modify_parameters(ProjectParameters)
 
             # To avoid many prints
-            if ProjectParameters["problem_data"]["echo_level"].GetInt() == 0:
+            if (ProjectParameters["problem_data"]["echo_level"].GetInt() == 0):
                 KratosMultiphysics.Logger.GetDefaultOutput().SetSeverity(KratosMultiphysics.Logger.Severity.WARNING)
-            else:
-                KratosMultiphysics.Logger.GetDefaultOutput().SetSeverity(KratosMultiphysics.Logger.Severity.INFO)
 
             # Creating the test
             model = KratosMultiphysics.Model()
@@ -51,12 +68,12 @@ class StructuralMechanicsTestFactory(KratosUnittest.TestCase):
 
     def test_execution(self):
         # Within this location context:
-        with KratosUnittest.WorkFolderScope(".", __file__):
+        with controlledExecutionScope(os.path.dirname(os.path.realpath(__file__))):
             self.test.RunSolutionLoop()
 
     def tearDown(self):
         # Within this location context:
-        with KratosUnittest.WorkFolderScope(".", __file__):
+        with controlledExecutionScope(os.path.dirname(os.path.realpath(__file__))):
             self.test.Finalize()
 
 class SimpleMeshMovingTest(StructuralMechanicsTestFactory):
@@ -191,9 +208,6 @@ class Simple3D2NBeamCrTest(StructuralMechanicsTestFactory):
 class Simple3D2NBeamCrLinearTest(StructuralMechanicsTestFactory):
     file_name = "beam_test/linear_3D2NBeamCr_test"
 
-class Simple3D2NBeamCrNonLinearTest(StructuralMechanicsTestFactory):
-    file_name = "beam_test/nonlinear_force_3D2NBeamCr_test"
-
 class Simple3D2NBeamCrDynamicTest(StructuralMechanicsTestFactory):
     file_name = "beam_test/dynamic_3D2NBeamCr_test"
 
diff --git a/applications/StructuralMechanicsApplication/tests/structural_mechanics_test_factory_mpi.py b/applications/StructuralMechanicsApplication/tests/structural_mechanics_test_factory_mpi.py
index 6afce270f6..71f12abc17 100644
--- a/applications/StructuralMechanicsApplication/tests/structural_mechanics_test_factory_mpi.py
+++ b/applications/StructuralMechanicsApplication/tests/structural_mechanics_test_factory_mpi.py
@@ -24,9 +24,7 @@ class StructuralMechanicsTestFactoryMPI(StructuralMechanicsTestFactory):
         # Here we append "_mpi" to the name of the results file
         # e.g. "test_results.json" => "test_results_mpi.json"
         # This is necessary becs the node numbering changes with the partitioning
-        if project_parameters["solver_settings"].Has("linear_solver_settings"):
-            project_parameters["solver_settings"].RemoveValue("linear_solver_settings")
-        results_file_param = project_parameters["processes"]["json_check_process"][0]["Parameters"]["input_file_name"]
+        results_file_param = project_parameters["json_check_process"][0]["Parameters"]["input_file_name"]
         results_file_name = results_file_param.GetString()
         raw_path, file_name = os.path.split(results_file_name)
         raw_file_name, file_ext = os.path.splitext(file_name)
diff --git a/applications/StructuralMechanicsApplication/tests/structural_response_function_test_factory.py b/applications/StructuralMechanicsApplication/tests/structural_response_function_test_factory.py
index 5d751fabc0..d6414ab942 100644
--- a/applications/StructuralMechanicsApplication/tests/structural_response_function_test_factory.py
+++ b/applications/StructuralMechanicsApplication/tests/structural_response_function_test_factory.py
@@ -10,7 +10,7 @@ import structural_response_function_factory
 
 import KratosMultiphysics.kratos_utilities as kratos_utils
 
-if kratos_utils.CheckIfApplicationsAvailable("EigenSolversApplication"):
+if kratos_utils.IsApplicationAvailable("EigenSolversApplication"):
     has_eigensolvers_application = True
 else:
     has_eigensolvers_application = False
diff --git a/applications/StructuralMechanicsApplication/tests/test_StructuralMechanicsApplication.py b/applications/StructuralMechanicsApplication/tests/test_StructuralMechanicsApplication.py
index e25a14525d..152f5657e6 100644
--- a/applications/StructuralMechanicsApplication/tests/test_StructuralMechanicsApplication.py
+++ b/applications/StructuralMechanicsApplication/tests/test_StructuralMechanicsApplication.py
@@ -9,7 +9,7 @@ import KratosMultiphysics.KratosUnittest as KratosUnittest
 
 import subprocess
 
-if kratos_utilities.CheckIfApplicationsAvailable("ExternalSolversApplication"):
+if kratos_utilities.IsApplicationAvailable("ExternalSolversApplication"):
     has_external_solvers_application = True
 else:
     has_external_solvers_application = False
@@ -36,15 +36,14 @@ from test_patch_test_cr_beam import TestCrBeam2D2N as TTestCrBeam2D2N
 from test_patch_test_shells_stress import TestPatchTestShellsStressRec as TTestPatchTestShellsStressRec
 from test_patch_test_shells_orthotropic import TestPatchTestShellsOrthotropic as TTestPatchTestShellsOrthotropic
 from test_patch_test_formfinding import TestPatchTestFormfinding as TTestPatchTestFormfinding
-from test_patch_test_membrane import TestPatchTestMembrane as TTestPatchTestMembrane
+from test_patch_test_membrane import StaticPatchTestMembrane as TStaticPatchTestMembrane
+from test_patch_test_membrane import DynamicPatchTestMembrane as TDynamicPatchTestMembrane
 # Test loading conditions
 from test_loading_conditions_point import TestLoadingConditionsPoint as TTestLoadingConditionsPoint
 from test_loading_conditions_line import TestLoadingConditionsLine as TTestLoadingConditionsLine
 from test_loading_conditions_surface import TestLoadingConditionsSurface as TTestLoadingConditionsSurface
 # Nodal damping test
 from test_nodal_damping import NodalDampingTests as TNodalDampingTests
-# RVE test
-from test_rve_analytic import TestRVESimplestTest as TTestRVESimplestTest
 # Spring damper element test
 from test_spring_damper_element import SpringDamperElementTests as TSpringDamperElementTests
 # Harmonic analysis tests
@@ -122,7 +121,6 @@ from structural_mechanics_test_factory import Simple3D2NTrussLinearTensionPlasti
 from structural_mechanics_test_factory import Simple3D2NTrussNonLinearSnapthroughPlasticTest as T3D2NTrussNonLinearSnapthroughPlasticTest
 from structural_mechanics_test_factory import Simple3D2NTrussNonLinearTensionPlasticTest as T3D2NTrussNonLinearTensionPlasticTest
 from structural_mechanics_test_factory import Simple3D2NBeamCrTest as T3D2NBeamCrTest
-from structural_mechanics_test_factory import Simple3D2NBeamCrNonLinearTest as T3D2NBeamCrNonLinearTest
 from structural_mechanics_test_factory import Simple3D2NBeamCrLinearTest as T3D2NBeamCrLinearTest
 from structural_mechanics_test_factory import Simple3D2NBeamCrDynamicTest as T3D2NBeamCrDynamicTest
 from structural_mechanics_test_factory import Simple2D2NBeamCrTest as T2D2NBeamCrTest
@@ -235,7 +233,7 @@ def AssembleTestSuites():
     ### Adding the self-contained tests
     # Constitutive Law tests
     smallSuite.addTests(KratosUnittest.TestLoader().loadTestsFromTestCases([TTestConstitutiveLaw]))
-    smallSuite.addTest(TSimpleSmallDeformationPlasticityMCTest('test_execution'))
+    nightSuite.addTest(TSimpleSmallDeformationPlasticityMCTest('test_execution'))
     smallSuite.addTest(TSimpleSmallDeformationPlasticityVMTest('test_execution'))
     smallSuite.addTest(TSimpleSmallDeformationPlasticityDPTest('test_execution'))
     smallSuite.addTest(TSimpleSmallDeformationPlasticityTTest('test_execution'))
@@ -259,7 +257,8 @@ def AssembleTestSuites():
     nightSuite.addTests(KratosUnittest.TestLoader().loadTestsFromTestCases([TTestPatchTestShellsOrthotropic])) # TODO should be in smallSuite but is too slow
     # Membranes
     smallSuite.addTests(KratosUnittest.TestLoader().loadTestsFromTestCases([TTestPatchTestFormfinding]))
-    smallSuite.addTests(KratosUnittest.TestLoader().loadTestsFromTestCases([TTestPatchTestMembrane]))
+    smallSuite.addTests(KratosUnittest.TestLoader().loadTestsFromTestCases([TStaticPatchTestMembrane]))
+    nightSuite.addTests(KratosUnittest.TestLoader().loadTestsFromTestCases([TDynamicPatchTestMembrane]))
     # Trusses
     smallSuite.addTests(KratosUnittest.TestLoader().loadTestsFromTestCases([TTestTruss3D2N]))
     # Beams
@@ -282,8 +281,6 @@ def AssembleTestSuites():
     smallSuite.addTests(KratosUnittest.TestLoader().loadTestsFromTestCases([TTestShellThinAdjointElement3D3N]))
     smallSuite.addTests(KratosUnittest.TestLoader().loadTestsFromTestCases([TTestTrussAdjointElement]))
     smallSuite.addTests(KratosUnittest.TestLoader().loadTestsFromTestCases([TTestTrussLinearAdjointElement]))
-    # RVE tests
-    nightSuite.addTests(KratosUnittest.TestLoader().loadTestsFromTestCases([TTestRVESimplestTest]))
 
     ### Adding Small Tests
     # Basic moving mesh test (leave these in the smallSuite to have the Exection script tested)
@@ -338,7 +335,6 @@ def AssembleTestSuites():
     nightSuite.addTest(T3D2NTrussNonLinearSnapthroughPlasticTest('test_execution'))
     nightSuite.addTest(T3D2NTrussNonLinearTensionPlasticTest('test_execution'))
     nightSuite.addTest(T3D2NBeamCrTest('test_execution'))
-    nightSuite.addTest(T3D2NBeamCrNonLinearTest('test_execution'))
     nightSuite.addTest(T3D2NBeamCrLinearTest('test_execution'))
     nightSuite.addTest(T3D2NBeamCrDynamicTest('test_execution'))
     # Shell tests
diff --git a/applications/StructuralMechanicsApplication/tests/test_adjoint_sensitity_analysis_beam_3d2n_structure.py b/applications/StructuralMechanicsApplication/tests/test_adjoint_sensitity_analysis_beam_3d2n_structure.py
index 3ca2d40d98..2ef45732ce 100644
--- a/applications/StructuralMechanicsApplication/tests/test_adjoint_sensitity_analysis_beam_3d2n_structure.py
+++ b/applications/StructuralMechanicsApplication/tests/test_adjoint_sensitity_analysis_beam_3d2n_structure.py
@@ -6,7 +6,7 @@ import KratosMultiphysics.KratosUnittest as KratosUnittest
 import structural_mechanics_analysis
 import KratosMultiphysics.kratos_utilities as kratos_utilities
 
-if kratos_utilities.CheckIfApplicationsAvailable("HDF5Application"):
+if kratos_utilities.IsApplicationAvailable("HDF5Application"):
     has_hdf5_application = True
 else:
     has_hdf5_application = False
@@ -64,21 +64,17 @@ class TestAdjointSensitivityAnalysisBeamStructure(KratosUnittest.TestCase):
             adjoint_analysis.Run()
 
             # Check sensitivities for the parameter I22
-            reference_values = [-87.62277093392399, 9.497391494932984, 38.125186783868, 0.6250049974719261, 0.15624887499699122]
+            reference_values = [-87.62277093392399, 38.125186783868, 0.6250049974719261, 0.15624887499699122]
             sensitivities_to_check = []
-            element_list = [1,2,3,4,5,6,10]
+            element_list = [1,6,10]
             for element_id in element_list:
                 sensitivities_to_check.append(model_adjoint.GetModelPart(model_part_name).Elements[element_id].GetValue(I22_SENSITIVITY))
             sensitivities_to_check.append(model_adjoint.GetModelPart(model_part_name).Conditions[1].GetValue(POINT_LOAD_SENSITIVITY)[2])
 
         self.assertAlmostEqual(sensitivities_to_check[0], reference_values[0], 3)
         self.assertAlmostEqual(sensitivities_to_check[1], reference_values[1], 3)
-        self.assertAlmostEqual(sensitivities_to_check[2], reference_values[1], 3)
-        self.assertAlmostEqual(sensitivities_to_check[3], reference_values[1], 3)
-        self.assertAlmostEqual(sensitivities_to_check[4], reference_values[1], 3)
-        self.assertAlmostEqual(sensitivities_to_check[5], reference_values[2], 3)
-        self.assertAlmostEqual(sensitivities_to_check[6], reference_values[3], 3)
-        self.assertAlmostEqual(sensitivities_to_check[7], reference_values[4], 5)
+        self.assertAlmostEqual(sensitivities_to_check[2], reference_values[2], 3)
+        self.assertAlmostEqual(sensitivities_to_check[3], reference_values[3], 5)
 
     def test_nodal_displacement_response(self):
         # Create the adjoint solver
diff --git a/applications/StructuralMechanicsApplication/tests/test_adjoint_sensitity_analysis_shell_3d3n_structure.py b/applications/StructuralMechanicsApplication/tests/test_adjoint_sensitity_analysis_shell_3d3n_structure.py
index 4cad1a1840..dc3da2e7c5 100644
--- a/applications/StructuralMechanicsApplication/tests/test_adjoint_sensitity_analysis_shell_3d3n_structure.py
+++ b/applications/StructuralMechanicsApplication/tests/test_adjoint_sensitity_analysis_shell_3d3n_structure.py
@@ -6,7 +6,7 @@ import KratosMultiphysics.KratosUnittest as KratosUnittest
 import structural_mechanics_analysis
 import KratosMultiphysics.kratos_utilities as kratos_utilities
 
-if kratos_utilities.CheckIfApplicationsAvailable("HDF5Application"):
+if kratos_utilities.IsApplicationAvailable("HDF5Application"):
     has_hdf5_application = True
 else:
     has_hdf5_application = False
diff --git a/applications/StructuralMechanicsApplication/tests/test_adjoint_sensitity_analysis_truss_3d2n_structure.py b/applications/StructuralMechanicsApplication/tests/test_adjoint_sensitity_analysis_truss_3d2n_structure.py
index 78f41fe7ad..c4d1da58ab 100644
--- a/applications/StructuralMechanicsApplication/tests/test_adjoint_sensitity_analysis_truss_3d2n_structure.py
+++ b/applications/StructuralMechanicsApplication/tests/test_adjoint_sensitity_analysis_truss_3d2n_structure.py
@@ -6,7 +6,7 @@ import KratosMultiphysics.KratosUnittest as KratosUnittest
 import structural_mechanics_analysis
 import KratosMultiphysics.kratos_utilities as kratos_utilities
 
-if kratos_utilities.CheckIfApplicationsAvailable("HDF5Application"):
+if kratos_utilities.IsApplicationAvailable("HDF5Application"):
     has_hdf5_application = True
 else:
     has_hdf5_application = False
diff --git a/applications/StructuralMechanicsApplication/tests/test_constitutive_law.py b/applications/StructuralMechanicsApplication/tests/test_constitutive_law.py
index 8115699e48..d2266e65c1 100644
--- a/applications/StructuralMechanicsApplication/tests/test_constitutive_law.py
+++ b/applications/StructuralMechanicsApplication/tests/test_constitutive_law.py
@@ -286,7 +286,7 @@ class TestConstitutiveLaw(KratosUnittest.TestCase):
     def test_Isotropic_Damage_3D(self):
         current_model = KratosMultiphysics.Model()
         model_part = current_model.CreateModelPart("test")
-        deformation_test = DeformationSmallStrainIsotropicDamage3D()
+        deformation_test = DeformationLinearIsotropicDamage3D()
 
         self._generic_constitutive_law_test(model_part, deformation_test)
 
@@ -295,7 +295,7 @@ class TestConstitutiveLaw(KratosUnittest.TestCase):
         current_model = KratosMultiphysics.Model()
         model_part = current_model.CreateModelPart("test")
 
-        deformation_test = DeformationSmallStrainIsotropicDamagePlaneStrain2D()
+        deformation_test = DeformationLinearIsotropicDamagePlaneStrain2D()
 
         self._generic_constitutive_law_test(model_part, deformation_test)
 
@@ -638,7 +638,7 @@ class DeformationSmallStrainJ2PlasticityPlaneStrain2D(DeformationSmallStrainJ2Pl
     def get_reference_stress(self, i):
         return self.reference_stress[i]
 
-class DeformationSmallStrainIsotropicDamage(Deformation):
+class DeformationLinearIsotropicDamage(Deformation):
     def __init__(self):
         Deformation.__init__(self)
         self.nr_timesteps = 10
@@ -647,10 +647,10 @@ class DeformationSmallStrainIsotropicDamage(Deformation):
         self.strain = (i+1)/ self.nr_timesteps * self.initial_strain
         cl_params.SetStrainVector(self.strain)
 
-class DeformationSmallStrainIsotropicDamage3D(DeformationSmallStrainIsotropicDamage):
+class DeformationLinearIsotropicDamage3D(DeformationLinearIsotropicDamage):
     def __init__(self):
-        DeformationSmallStrainIsotropicDamage.__init__(self)
-        self.cl = SmallStrainIsotropicDamage3D()
+        DeformationLinearIsotropicDamage.__init__(self)
+        self.cl = LinearIsotropicDamage3D()
 
     def initialize_reference_stress(self, strain_size):
         self.initial_strain = KratosMultiphysics.Vector(strain_size)
@@ -679,10 +679,10 @@ class DeformationSmallStrainIsotropicDamage3D(DeformationSmallStrainIsotropicDam
     def get_reference_stress(self, i):
         return self.reference_stress[i]
 
-class DeformationSmallStrainIsotropicDamagePlaneStrain2D(DeformationSmallStrainIsotropicDamage):
+class DeformationLinearIsotropicDamagePlaneStrain2D(DeformationLinearIsotropicDamage):
     def __init__(self):
-        DeformationSmallStrainIsotropicDamage.__init__(self)
-        self.cl = SmallStrainIsotropicDamagePlaneStrain2D()
+        DeformationLinearIsotropicDamage.__init__(self)
+        self.cl = LinearIsotropicDamagePlaneStrain2D()
 
     def initialize_reference_stress(self, strain_size):
         self.initial_strain = KratosMultiphysics.Vector(strain_size)
@@ -709,10 +709,10 @@ class DeformationSmallStrainIsotropicDamagePlaneStrain2D(DeformationSmallStrainI
         return self.reference_stress[i]
 
 # todo -****************************
-class DeformationSmallStrainIsotropicPlasticity3D(DeformationSmallStrainIsotropicDamage):
+class DeformationSmallStrainIsotropicPlasticity3D(DeformationLinearIsotropicDamage):
     def __init__(self):
-        DeformationSmallStrainIsotropicDamage.__init__(self)
-        self.cl = SmallStrainIsotropicDamage3D()
+        DeformationLinearIsotropicDamage.__init__(self)
+        self.cl = LinearIsotropicDamage3D()
 
     def initialize_reference_stress(self, strain_size):
         self.initial_strain = KratosMultiphysics.Vector(strain_size)
@@ -848,7 +848,7 @@ class SmallStrainJ2PlasticityPlaneStrain2D(SmallStrainJ2Plasticity):
     def create_constitutive_Law():
         return StructuralMechanicsApplication.SmallStrainJ2PlasticityPlaneStrain2DLaw()
 
-class SmallStrainIsotropicDamage(LinearElastic):
+class LinearIsotropicDamage(LinearElastic):
     def __init__(self):
         self.young_modulus = 3000
         self.poisson_ratio = 0.3
@@ -863,23 +863,23 @@ class SmallStrainIsotropicDamage(LinearElastic):
         properties.SetValue(KratosMultiphysics.ISOTROPIC_HARDENING_MODULUS, self.isotropic_hardening_modulus)
         return properties
 
-class SmallStrainIsotropicDamage3D(SmallStrainIsotropicDamage):
+class LinearIsotropicDamage3D(LinearIsotropicDamage):
     def __init__(self):
-        SmallStrainIsotropicDamage.__init__(self)
+        LinearIsotropicDamage.__init__(self)
         self.dim = 3
 
     @staticmethod
     def create_constitutive_Law():
-        return StructuralMechanicsApplication.SmallStrainIsotropicDamage3DLaw()
+        return StructuralMechanicsApplication.LinearIsotropicDamage3DLaw()
 
-class SmallStrainIsotropicDamagePlaneStrain2D(SmallStrainIsotropicDamage):
+class LinearIsotropicDamagePlaneStrain2D(LinearIsotropicDamage):
     def __init__(self):
-        SmallStrainIsotropicDamage.__init__(self)
+        LinearIsotropicDamage.__init__(self)
         self.dim = 2
 
     @staticmethod
     def create_constitutive_Law():
-        return StructuralMechanicsApplication.SmallStrainIsotropicDamagePlaneStrain2DLaw()
+        return StructuralMechanicsApplication.LinearIsotropicDamagePlaneStrain2DLaw()
 
 if __name__ == '__main__':
     KratosUnittest.main()
diff --git a/applications/StructuralMechanicsApplication/tests/test_harmonic_analysis.py b/applications/StructuralMechanicsApplication/tests/test_harmonic_analysis.py
index d3f312d924..86c10756cf 100644
--- a/applications/StructuralMechanicsApplication/tests/test_harmonic_analysis.py
+++ b/applications/StructuralMechanicsApplication/tests/test_harmonic_analysis.py
@@ -215,7 +215,7 @@ class HarmonicAnalysisTests(KratosUnittest.TestCase):
 
 class HarmonicAnalysisTestsWithHDF5(KratosUnittest.TestCase):
     def test_harmonic_mdpa_input(self):
-        if not kratos_utils.CheckIfApplicationsAvailable("HDF5Application"):
+        if not kratos_utils.IsApplicationAvailable("HDF5Application"):
             self.skipTest("HDF5Application not found: Skipping harmonic analysis mdpa test")
 
         import structural_mechanics_analysis
diff --git a/applications/StructuralMechanicsApplication/tests/test_patch_test_cr_beam.py b/applications/StructuralMechanicsApplication/tests/test_patch_test_cr_beam.py
index e2d7108e27..b27530c4fc 100644
--- a/applications/StructuralMechanicsApplication/tests/test_patch_test_cr_beam.py
+++ b/applications/StructuralMechanicsApplication/tests/test_patch_test_cr_beam.py
@@ -216,11 +216,16 @@ class TestCrBeam3D2N(KratosUnittest.TestCase):
         #check free vibration of cantilever tip
         disp_y_simulated = mp.Nodes[nr_nodes].GetSolutionStepValue(
             KratosMultiphysics.DISPLACEMENT_Y)
-        disp_y_analytical = [-2.8662420382165618e-06, -7.324435068359769e-06,
-         -1.1284349973901058e-05, -1.832745727658638e-05, -2.7392682029790193e-05,
-          -3.725949945576998e-05, -5.039573129445816e-05, -6.550420107648481e-05,
-           -8.13072032132872e-05, -9.994712970365864e-05, -0.00012023689482204995,
-            -0.00014100714864344788]
+        disp_y_analytical = [-2.8662420382165618e-06,-6.5284595740263744e-06,
+            -8.667247023317519e-06,-1.5193910085875024e-05,-2.4013659391608225e-05,
+            -3.2183559803816915e-05,-4.43709426806417e-05,-5.9041345875279067e-05,
+            -7.330044103901265e-05,-9.107969267628107e-05,-0.00011105794571720542,
+            -0.0001304810033530728,-0.00015308391062689988,-0.00017782947133379302,
+            -0.00020200606491067104,-0.00022918489563129963,-0.00025850356356149775,
+            -0.00028714489980093377,-0.0003185138569101933,-0.0003519411006451715,
+            -0.0003845236264241205,-0.000419580648891076,-0.0004566985915125524,
+            -0.0004929004674252967,-0.0005314362205181631,-0.0005721203453514332,
+            -0.0006117811911574032]
 
         self.assertAlmostEqual(disp_y_analytical[time_step], disp_y_simulated,6)
 
@@ -812,16 +817,16 @@ class TestCrBeam2D2N(KratosUnittest.TestCase):
         #check free vibration of cantilever tip
         disp_y_simulated = mp.Nodes[nr_nodes].GetSolutionStepValue(
             KratosMultiphysics.DISPLACEMENT_Y)
-        disp_y_analytical = [-2.8662420382165618e-06, -7.324435639692502e-06,
-         -1.127338906783505e-05, -1.8295247730107807e-05, -2.734628604381698e-05,
-          -3.719359531899879e-05, -5.0300379791890316e-05, -6.539083979597516e-05,
-           -8.117215311130154e-05, -9.977925134032038e-05, -0.000120050918560219,
-            -0.00014080087213487295, -0.00016415937456847792, -0.00018914916567586786,
-             -0.00021458569402846208, -0.00024252485909649984, -0.0002720522349491637,
-              -0.0003018687112562826, -0.00033395260872105294, -0.0003674971920367386,
-               -0.00040114613492046235, -0.0004368853206358216, -0.00047407303279122377,
-                -0.0005112724218782807, -0.0005504051808475501, -0.000590998050641702,
-                 -0.0006317027806857927]
+        disp_y_analytical = [-2.8662420382165618e-06,-6.5284598580628135e-06,
+            -8.661766714284483e-06,-1.5166844659226568e-05,-2.3974692146734503e-05,
+            -3.213060541808351e-05,-4.4284460087458615e-05,-5.8937873140393946e-05,
+            -7.318106720395262e-05,-9.09215604293434e-05,-0.00011088212163774735,
+            -0.00013029114264297788,-0.00015285402390510065,-0.00017758464802435417,
+            -0.0002017526913999827,-0.00022889337656467832,-0.00025820171682640884,
+            -0.0002868413100380328,-0.000318174460796471,-0.0003515951807656998,
+            -0.00038418182365403656,-0.0004192072728098697,-0.0004563324503910268,
+            -0.0004925439930684863,-0.0005309736146781797,-0.0005715335001692381,
+            -0.0006112486419960861]
 
 
         self.assertAlmostEqual(disp_y_analytical[time_step], disp_y_simulated)
diff --git a/applications/StructuralMechanicsApplication/tests/test_patch_test_membrane.py b/applications/StructuralMechanicsApplication/tests/test_patch_test_membrane.py
index 6007ab02bb..abc51bb574 100644
--- a/applications/StructuralMechanicsApplication/tests/test_patch_test_membrane.py
+++ b/applications/StructuralMechanicsApplication/tests/test_patch_test_membrane.py
@@ -4,7 +4,7 @@ import KratosMultiphysics
 import KratosMultiphysics.StructuralMechanicsApplication as StructuralMechanicsApplication
 import KratosMultiphysics.KratosUnittest as KratosUnittest
 
-class TestPatchTestMembrane(KratosUnittest.TestCase):
+class BasePatchTestMembrane(KratosUnittest.TestCase):
 
     def _add_variables(self,mp):
         mp.AddNodalSolutionStepVariable(KratosMultiphysics.DISPLACEMENT)
@@ -292,6 +292,35 @@ class TestPatchTestMembrane(KratosUnittest.TestCase):
 
         return mp
 
+    def __post_process(self, main_model_part):
+        from gid_output_process import GiDOutputProcess
+        self.gid_output = GiDOutputProcess(main_model_part,
+                                    "gid_output",
+                                    KratosMultiphysics.Parameters("""
+                                        {
+                                            "result_file_configuration" : {
+                                                "gidpost_flags": {
+                                                    "GiDPostMode": "GiD_PostBinary",
+                                                    "WriteDeformedMeshFlag": "WriteUndeformed",
+                                                    "WriteConditionsFlag": "WriteConditions",
+                                                    "MultiFileFlag": "SingleFile"
+                                                },
+                                                "nodal_results"       : ["DISPLACEMENT"],
+                                                "gauss_point_results" : []
+                                            }
+                                        }
+                                        """)
+                                    )
+
+        self.gid_output.ExecuteInitialize()
+        self.gid_output.ExecuteBeforeSolutionLoop()
+        self.gid_output.ExecuteInitializeSolutionStep()
+        self.gid_output.PrintOutput()
+        self.gid_output.ExecuteFinalizeSolutionStep()
+        self.gid_output.ExecuteFinalize()
+
+
+class StaticPatchTestMembrane(BasePatchTestMembrane):
 
     def test_membrane_3d3n_static(self):
         displacement_results = [-4.628753e-12 , -0.04937043 , -6.483677e-12]
@@ -319,6 +348,7 @@ class TestPatchTestMembrane(KratosUnittest.TestCase):
 
         #self.__post_process(mp)
 
+class DynamicPatchTestMembrane(BasePatchTestMembrane):
 
     def test_membrane_3d3n_dynamic(self):
 
@@ -378,33 +408,5 @@ class TestPatchTestMembrane(KratosUnittest.TestCase):
 
         #self.__post_process(mp)
 
-
-    def __post_process(self, main_model_part):
-        from gid_output_process import GiDOutputProcess
-        self.gid_output = GiDOutputProcess(main_model_part,
-                                    "gid_output",
-                                    KratosMultiphysics.Parameters("""
-                                        {
-                                            "result_file_configuration" : {
-                                                "gidpost_flags": {
-                                                    "GiDPostMode": "GiD_PostBinary",
-                                                    "WriteDeformedMeshFlag": "WriteUndeformed",
-                                                    "WriteConditionsFlag": "WriteConditions",
-                                                    "MultiFileFlag": "SingleFile"
-                                                },
-                                                "nodal_results"       : ["DISPLACEMENT"],
-                                                "gauss_point_results" : []
-                                            }
-                                        }
-                                        """)
-                                    )
-
-        self.gid_output.ExecuteInitialize()
-        self.gid_output.ExecuteBeforeSolutionLoop()
-        self.gid_output.ExecuteInitializeSolutionStep()
-        self.gid_output.PrintOutput()
-        self.gid_output.ExecuteFinalizeSolutionStep()
-        self.gid_output.ExecuteFinalize()
-
 if __name__ == '__main__':
     KratosUnittest.main()
diff --git a/applications/StructuralMechanicsApplication/tests/test_patch_test_small_strain.py b/applications/StructuralMechanicsApplication/tests/test_patch_test_small_strain.py
index 86cf378302..ef8b42cc0c 100644
--- a/applications/StructuralMechanicsApplication/tests/test_patch_test_small_strain.py
+++ b/applications/StructuralMechanicsApplication/tests/test_patch_test_small_strain.py
@@ -8,7 +8,7 @@ import KratosMultiphysics.KratosUnittest as KratosUnittest
 class TestPatchTestSmallStrain(KratosUnittest.TestCase):
     def setUp(self):
         pass
-
+       
     def _add_variables(self,mp):
         mp.AddNodalSolutionStepVariable(KratosMultiphysics.DISPLACEMENT)
         mp.AddNodalSolutionStepVariable(KratosMultiphysics.REACTION)
@@ -469,7 +469,7 @@ class TestPatchTestSmallStrain(KratosUnittest.TestCase):
         # Testing explicit utilities
         empty_param = KratosMultiphysics.Parameters("""{}""")
         max_delta_time = StructuralMechanicsApplication.CalculateDeltaTime(mp, empty_param)
-        self.assertAlmostEqual(max_delta_time,4.1494033578614815e-07)
+        self.assertAlmostEqual(max_delta_time,4.764516014904737e-07)
 
     def __post_process(self, main_model_part):
         from gid_output_process import GiDOutputProcess
diff --git a/applications/StructuralMechanicsApplication/tests/test_patch_test_truss.py b/applications/StructuralMechanicsApplication/tests/test_patch_test_truss.py
index 8016a28d5a..0d5a78fa2e 100644
--- a/applications/StructuralMechanicsApplication/tests/test_patch_test_truss.py
+++ b/applications/StructuralMechanicsApplication/tests/test_patch_test_truss.py
@@ -262,30 +262,27 @@ class TestTruss3D2N(KratosUnittest.TestCase):
             KratosMultiphysics.DISPLACEMENT_Y)
         test_disp_temp=[]
 
-        if not linear_flag:
-            test_disp_temp = [-0.021876435754392846, -0.08025882554469399,
-             -0.15813185652586725, -0.23777687358088162, -0.3064930326402276,
-              -0.3573326497214386, -0.3873391702109082, -0.395577009293513,
-               -0.3818896310557375, -0.3465605603239489, -0.2908778140223522,
-                -0.21859000122176653, -0.137959254822277, -0.06316757026754098,
-                 -0.012505199445968729, -0.0013936517032937436, -0.033558757863839106,
-                  -0.09855750793342796, -0.1783863153886539, -0.2562575870107372,
-                   -0.32098186673316653, -0.36680529690058933, -0.3914373873640369,
-                    -0.3942176190923876, -0.3750955464878065, -0.33451653033029854,
-                     -0.27421215776065255, -0.19885577070221477, -0.11812448977763666,
-                      -0.047582542658150095, -0.005644700007086029]
+        if (linear_flag==False):
+            test_disp_temp = [-0.02187643575439285,-0.06200584852673985,-0.12659001916294776,
+                -0.19946368685547383,-0.2668662857344121,-0.31996689568889486,
+                -0.3542336049715639,-0.3677972374869337,-0.36013540742558275,
+                -0.3315283526375912,-0.2833671144362512,-0.21927539369421717,
+                -0.14674331873257762,-0.07823551896414549,-0.029752996236702217,
+                -0.015285489977120799,-0.039456188280874,-0.09465825378001311,
+                -0.16565728745639585,-0.2370016587070386,-0.29751601542655876,
+                -0.3408633097298418,-0.36414189975011835,-0.366323940323949,
+                -0.34733143050033766,-0.30794836454906194,-0.25057916520759693,
+                -0.18071645080606016,-0.10848951449562776,-0.048693226040445785,
+                -0.017174322907726747]
         else:
-            test_disp_temp = [-0.021876435754392846, -0.08001480552613088,
-             -0.15450734651949033, -0.21984629437903802, -0.2536582616084091,
-              -0.24436534146715136, -0.19514961922146873, -0.12286356129128417,
-               -0.05225938725829657, -0.007513405377368422, -0.0039475518645423965,
-                -0.04278284764242695, -0.11072129588924451, -0.18449938719258163,
-                 -0.2388539993329007, -0.2551730052486504, -0.22786844469759693,
-                  -0.16628995573849595, -0.09152326809390332, -0.029170019520337,
-                   -0.0005812332236243001, -0.015546292333136365, -0.06894085558946322,
-                    -0.14248153623680793, -0.21098650630318805, -0.2509982677582305,
-                     -0.2488159779533806, -0.2051868973976112, -0.13505051252836275,
-                      -0.06242295105627721, -0.01217337033638198]
+            test_disp_temp = [-0.02187643575439285,-0.061883838517458295,-0.12445382515428678,
+                -0.1881611569285987,-0.23119114494748316,-0.23880944426893233,-0.20840739392784358,
+                -0.15039527562063051,-0.08463762106828532,-0.03365119147293591,-0.01489477954188152,
+                -0.03479096301660944,-0.08652688314806617,-0.15238710639314917,-0.209819749938765,
+                -0.23915870603324285,-0.2303577181183718,-0.18643042383939673,-0.12241842409082543,
+                -0.0602407322897484,-0.02118825742486547,-0.018633362863922306,-0.0534508965788702,
+                -0.11371862536897262,-0.17879965050966987,-0.22640890250055518,-0.2402440030802908,
+                -0.21556753182106447,-0.16082921544195866,-0.09477256915660874,-0.04001673503062233]
 
         self.assertAlmostEqual(simulated_disp_temp, test_disp_temp[time_step],6)
 
diff --git a/applications/StructuralMechanicsApplication/tests/test_rve_analytic.py b/applications/StructuralMechanicsApplication/tests/test_rve_analytic.py
deleted file mode 100644
index 67ec5d2ca8..0000000000
--- a/applications/StructuralMechanicsApplication/tests/test_rve_analytic.py
+++ /dev/null
@@ -1,112 +0,0 @@
-from __future__ import print_function, absolute_import, division
-
-import KratosMultiphysics
-import KratosMultiphysics.StructuralMechanicsApplication as StructuralMechanicsApplication
-import KratosMultiphysics.KratosUnittest as KratosUnittest
-
-import KratosMultiphysics.kratos_utilities as kratos_utilities
-
-from KratosMultiphysics.StructuralMechanicsApplication.rve_analysis import RVEAnalysis
-
-class TestRVESimplestTest(KratosUnittest.TestCase):
-
-    def test_rve_computation_block_version(self):
-        # Within this location context:
-        with KratosUnittest.WorkFolderScope(".", __file__):
-            with open("rve_test/smallest_rve_test_parameters.json", 'r') as parameter_file:
-                parameters = KratosMultiphysics.Parameters(parameter_file.read())
-
-            parameters["solver_settings"]["block_builder"].SetBool(True)
-            parameters["solver_settings"]["multi_point_constraints_used"].SetBool(True)
-
-            self._aux_rve_computation(parameters)
-
-    # FIXME: Commenting until fixed random fail on elimination B&S
-    #def test_rve_computation_elimination_version(self):
-        ## Within this location context:
-        #with KratosUnittest.WorkFolderScope(".", __file__):
-            #with open("rve_test/smallest_rve_test_parameters.json", 'r') as parameter_file:
-                #parameters = KratosMultiphysics.Parameters(parameter_file.read())
-
-            #parameters["solver_settings"]["block_builder"].SetBool(False)
-            #parameters["solver_settings"]["multi_point_constraints_used"].SetBool(True)
-
-            #self._aux_rve_computation(parameters)
-
-    def _aux_rve_computation(self, parameters):
-
-        if parameters["rve_settings"]["print_rve_post"].GetBool():
-            parameters["output_processes"].AddValue("gid_output", KratosMultiphysics.Parameters(R'''[{
-                "python_module" : "gid_output_process",
-                "kratos_module" : "KratosMultiphysics",
-                "process_name"  : "GiDOutputProcess",
-                "help"          : "This process writes postprocessing files for GiD",
-                "Parameters"    : {
-                    "model_part_name"        : "Structure.computing_domain",
-                    "output_name"            : "rve_test/smallest_rve_test",
-                    "postprocess_parameters" : {
-                        "result_file_configuration" : {
-                            "gidpost_flags"       : {
-                                "GiDPostMode"           : "GiD_PostBinary",
-                                "WriteDeformedMeshFlag" : "WriteDeformed",
-                                "WriteConditionsFlag"   : "WriteConditions",
-                                "MultiFileFlag"         : "SingleFile"
-                            },
-                            "file_label"          : "step",
-                            "output_control_type" : "step",
-                            "output_frequency"    : 1,
-                            "body_output"         : true,
-                            "node_output"         : false,
-                            "skin_output"         : false,
-                            "plane_output"        : [],
-                            "nodal_results"       : ["DISPLACEMENT","REACTION"],
-                            "gauss_point_results" : ["PK2_STRESS_TENSOR"]
-                        },
-                        "point_data_configuration"  : []
-                    }
-                }
-            }]'''))
-
-        model = KratosMultiphysics.Model()
-        simulation = RVEAnalysis(model, parameters)
-        simulation.Run()
-
-        model_part = model["Structure.computing_domain"]
-
-        # Compare C
-        Cestimated = model_part.GetValue(StructuralMechanicsApplication.ELASTICITY_TENSOR)
-
-        Canalytic = KratosMultiphysics.Matrix(6, 6)
-        Canalytic.fill(0.0)
-        E = 1e6
-        nu = 0.3
-        l = E*nu/((1+nu)*(1-2*nu))
-        G = E/(2.0*(1.0+nu))
-        Canalytic[0, 0] = l+2*G
-        Canalytic[0, 1] = l
-        Canalytic[0, 2] = l
-
-        Canalytic[1, 0] = l
-        Canalytic[1, 1] = l+2*G
-        Canalytic[1, 2] = l
-
-        Canalytic[2, 0] = l
-        Canalytic[2, 1] = l
-        Canalytic[2, 2] = l+2*G
-
-        Canalytic[3, 3] = G
-        Canalytic[4, 4] = G
-        Canalytic[5, 5] = G
-
-        for i in range(0, Cestimated.Size1()):
-            for j in range(0, Cestimated.Size2()):
-                self.assertAlmostEqual(
-                    abs(Cestimated[i, j] - Canalytic[i, j])/(l+2*G), 0.0, 5)
-
-        if not parameters["rve_settings"]["print_rve_post"].GetBool():
-            kratos_utilities.DeleteFileIfExisting("rve_elasticity_tensor.txt")
-
-
-if __name__ == '__main__':
-    KratosMultiphysics.Logger.GetDefaultOutput().SetSeverity(KratosMultiphysics.Logger.Severity.WARNING)
-    KratosUnittest.main()
diff --git a/applications/StructuralMechanicsApplication/tests/truss_test/nonlinear_3D2NTruss_plastic_snapthrough_test_parameters.json b/applications/StructuralMechanicsApplication/tests/truss_test/nonlinear_3D2NTruss_plastic_snapthrough_test_parameters.json
index 98a7d8b037..9d5ba34a02 100644
--- a/applications/StructuralMechanicsApplication/tests/truss_test/nonlinear_3D2NTruss_plastic_snapthrough_test_parameters.json
+++ b/applications/StructuralMechanicsApplication/tests/truss_test/nonlinear_3D2NTruss_plastic_snapthrough_test_parameters.json
@@ -3,7 +3,7 @@
         "problem_name"    : "nonlinear_3D2NTruss_snapthrough_plasticity_test",
         "parallel_type"   : "OpenMP",
         "start_time"      : 0.0,
-        "end_time"        : 44,
+        "end_time"        : 46,
         "echo_level"      : 0
     },
     "solver_settings"          : {
